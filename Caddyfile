# Caddyfile for sbomify
# This configuration handles reverse proxy, custom domains, and on-demand TLS

# Global options
{
	# Disable admin API for security in production
	# Can be overridden with environment variable for development
	admin {$CADDY_ADMIN:off}

	# On-demand TLS configuration
	on_demand_tls {
		# Ask the Django backend if a certificate should be issued
		ask http://sbomify-backend:8000/_tls/allow-host
	}

	# Email for Let's Encrypt
	email {$ACME_EMAIL:admin@example.com}
}

# HTTP block - redirect to HTTPS (but respect X-Forwarded-Proto for Cloudflare Tunnel)
http://{$APP_BASE_URL:localhost} {
	# Logging
	log {
		output stdout
		format json
		level {$LOG_LEVEL:INFO}
	}

	# Check if already HTTPS via proxy (Cloudflare Tunnel, etc.)
	@already_https {
		header X-Forwarded-Proto https
	}

	# If already HTTPS via proxy, serve normally (don't redirect)
	handle @already_https {
		# Block internal endpoints
		@tls_internal {
			path /_tls/*
		}
		handle @tls_internal {
			respond "Not Found" 404
		}

		# Health check
		@health {
			path /health
		}
		handle @health {
			respond "OK" 200
		}

		reverse_proxy sbomify-backend:8000 {
			header_up X-Forwarded-For {remote_host}
			header_up X-Forwarded-Proto https
			header_up X-Real-IP {remote_host}
			header_up Host {host}
			header_down -Server
		}
	}

	# Otherwise, redirect HTTP to HTTPS
	handle {
		redir https://{host}{uri} permanent
	}
}

# HTTPS block - main application domain
https://{$APP_BASE_URL:localhost} {
	# Uses automatic HTTPS: Let's Encrypt for production domains, internal CA for localhost
	# NOT on-demand TLS - that's only for custom domains in the :443 catch-all block

	# Logging
	log {
		output stdout
		format json
		level {$LOG_LEVEL:INFO}
	}

	# Block direct access to internal TLS verification endpoint from public
	@tls_internal {
		path /_tls/*
	}
	handle @tls_internal {
		respond "Not Found" 404
	}

	# Health check endpoint (bypasses Django)
	@health {
		path /health
	}
	handle @health {
		respond "OK" 200
	}

	# Reverse proxy to Django backend
	reverse_proxy sbomify-backend:8000 {
		# Request headers
		header_up X-Forwarded-For {remote_host}
		header_up X-Forwarded-Proto {scheme}
		header_up X-Real-IP {remote_host}
		header_up Host {host}

		# Trust proxy headers when behind Cloudflare
		trusted_proxies 173.245.48.0/20 103.21.244.0/22 103.22.200.0/22 103.31.4.0/22 141.101.64.0/18 108.162.192.0/18 190.93.240.0/20 188.114.96.0/20 197.234.240.0/22 198.41.128.0/17 162.158.0.0/15 104.16.0.0/13 104.24.0.0/14 172.64.0.0/13 131.0.72.0/22 2400:cb00::/32 2606:4700::/32 2803:f800::/32 2405:b500::/32 2405:8100::/32 2a06:98c0::/29 2c0f:f248::/32

		# Remove server header for security
		header_down -Server
	}

	# Security headers
	header {
		# HSTS (only set on HTTPS)
		Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
		
		# Prevent MIME type sniffing
		X-Content-Type-Options "nosniff"
		
		# XSS Protection
		X-Frame-Options "SAMEORIGIN"
		
		# CSP (adjust as needed for your app)
		Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline';"
		
		# Referrer Policy
		Referrer-Policy "strict-origin-when-cross-origin"
		
		# Remove X-Powered-By
		-X-Powered-By
	}

	# Compression
	encode gzip zstd
}

# Custom domains - HTTP catch-all (redirect to HTTPS, respect X-Forwarded-Proto)
:80 {
	log {
		output stdout
		format json
		level {$LOG_LEVEL:INFO}
	}

	# Check if already HTTPS via proxy (Cloudflare Tunnel, etc.)
	@already_https {
		header X-Forwarded-Proto https
	}

	# If already HTTPS via proxy, serve normally
	handle @already_https {
		@tls_internal {
			path /_tls/*
		}
		handle @tls_internal {
			respond "Not Found" 404
		}

		reverse_proxy sbomify-backend:8000 {
			header_up X-Forwarded-For {remote_host}
			header_up X-Forwarded-Proto https
			header_up X-Real-IP {remote_host}
			header_up Host {host}
			header_down -Server
		}
	}

	# Otherwise, redirect HTTP to HTTPS
	handle {
		redir https://{host}{uri} permanent
	}
}

# Custom domains - HTTPS catch-all
# Any domain not matching the main APP_BASE_URL will be handled here
# These will use on-demand TLS and be verified via the /_tls/allow-host endpoint
# Customers configure their custom domains (e.g., trust.customer.com) to CNAME to APP_BASE_URL
:443 {
	tls {
		on_demand
	}

	log {
		output stdout
		format json
		level {$LOG_LEVEL:INFO}
	}

	# Block internal endpoints on custom domains
	@tls_internal {
		path /_tls/*
	}
	handle @tls_internal {
		respond "Not Found" 404
	}

	reverse_proxy sbomify-backend:8000 {
		header_up X-Forwarded-For {remote_host}
		header_up X-Forwarded-Proto {scheme}
		header_up X-Real-IP {remote_host}
		header_up Host {host}

		# Trust proxy headers when behind Cloudflare
		trusted_proxies 173.245.48.0/20 103.21.244.0/22 103.22.200.0/22 103.31.4.0/22 141.101.64.0/18 108.162.192.0/18 190.93.240.0/20 188.114.96.0/20 197.234.240.0/22 198.41.128.0/17 162.158.0.0/15 104.16.0.0/13 104.24.0.0/14 172.64.0.0/13 131.0.72.0/22 2400:cb00::/32 2606:4700::/32 2803:f800::/32 2405:b500::/32 2405:8100::/32 2a06:98c0::/29 2c0f:f248::/32

		header_down -Server
	}

	header {
		Strict-Transport-Security "max-age=31536000; includeSubDomains"
		X-Content-Type-Options "nosniff"
		X-Frame-Options "SAMEORIGIN"
		Referrer-Policy "strict-origin-when-cross-origin"
		-X-Powered-By
	}

	encode gzip zstd
}

