# ADR-005: Frontend Architecture - Tailwind CSS and Alpine.js

## Status

Accepted

## Date

2025-02-02

## Context

sbomify's frontend was built on Bootstrap 5.3.8+ with custom CSS. As the application grew, several challenges emerged:

### Bootstrap Limitations

1. **Utility-first needs**: Bootstrap's component-centric approach required significant custom CSS for layout and spacing variations
2. **Dark mode complexity**: Implementing theming required overriding Bootstrap's Sass variables and managing duplicate style definitions
3. **Bundle size**: Bootstrap's full CSS bundle added overhead even when only portions were used
4. **Customization friction**: Modifying Bootstrap components often meant fighting against the framework's opinions

### JavaScript Architecture Issues

1. **Scattered state management**: jQuery snippets and vanilla JavaScript mixed with no consistent pattern
2. **Full page reloads**: Navigation between views required complete page refreshes
3. **Client-side fetching**: Some components fetched data directly from the API, bypassing Django's template context and duplicating logic

### Reference: ADR-001 and ADR-002

ADR-001 established Django templates with SSR as the rendering approach, moving away from a Vue SPA. ADR-002 noted the possibility of migrating from Bootstrap to Tailwind. This ADR formalizes that migration and establishes the supporting JavaScript architecture.

## Decision

### 1. Tailwind CSS for Styling

All new styling uses Tailwind CSS with a custom design system built on CSS custom properties.

#### Design Tokens

Core colors are defined as CSS variables in `tailwind.src.css`:

```css
:root {
  --color-primary: 99 102 241;      /* Indigo */
  --color-secondary: 168 85 247;    /* Purple */
  --color-success: 34 197 94;       /* Green */
  --color-warning: 245 158 11;      /* Amber */
  --color-danger: 239 68 68;        /* Red */
  --color-info: 14 165 233;         /* Sky */
  --color-accent: 236 72 153;       /* Pink */

  --color-surface: 255 255 255;     /* Card backgrounds */
  --color-background: 249 250 251;  /* Page background */
  --color-border: 229 231 235;      /* Borders */
  --color-text: 17 24 39;           /* Primary text */
  --color-text-muted: 107 114 128;  /* Secondary text */
}
```

Tailwind is configured to use these via `rgb(var(--color-*))` patterns, enabling alpha variations like `bg-primary/10`.

#### Component Classes

Reusable patterns are defined as `tw-*` classes:

| Class Pattern     | Purpose         | Example                                                 |
| ----------------- | --------------- | ------------------------------------------------------- |
| `tw-btn-*`        | Buttons         | `tw-btn-primary`, `tw-btn-secondary`, `tw-btn-danger`   |
| `tw-badge-*`      | Status badges   | `tw-badge-success`, `tw-badge-info`, `tw-badge-warning` |
| `tw-avatar`       | Icon containers | `tw-avatar`, `tw-avatar-lg`, `tw-avatar-sm`             |
| `tw-form-*`       | Form elements   | `tw-form-input`, `tw-form-select`, `tw-form-textarea`   |
| `tw-card-*`       | Card layouts    | `tw-card-header`, `tw-card-body`, `tw-dashboard-card`   |
| `tw-data-table-*` | Data tables     | `tw-data-table`, `tw-table`, `tw-pagination`            |

These are defined in `sbomify/static/css/tailwind.src.css` using `@apply` directives:

```css
.tw-btn-primary {
  @apply inline-flex items-center justify-center px-4 py-2.5
         text-sm font-medium text-white rounded-lg
         bg-primary hover:bg-primary/90
         focus:outline-none focus:ring-2 focus:ring-primary/50
         transition-colors duration-200;
}
```

#### Jinja2 Component Macros

Complex components are implemented as Jinja2 templates in `sbomify/apps/core/templates/components/tw/`:

- `button.html.j2` - Button variants with icon support
- `badge.html.j2` - Status badges with color variants
- `card.html.j2` - Card containers with header/body/footer
- `modal.html.j2` - Modal dialogs with Alpine.js integration
- `input.html.j2` - Form inputs with validation states
- `dropdown.html.j2` - Dropdown menus
- `pagination.html.j2` - Pagination controls
- `empty_state.html.j2` - Empty state placeholders

### 2. Alpine.js for Client-Side Reactivity

Alpine.js handles component state and client-side interactivity. Key patterns:

#### Data Initialization

Server data is passed to Alpine.js via Django's `json_script` template filter:

```jinja2
{{ items|json_script:"items-data" }}
<div x-data="{ items: [], init() { this.items = window.parseJsonScript('items-data') || []; } }">
```

A utility function `window.parseJsonScript(id)` safely parses JSON script tags:

```typescript
window.parseJsonScript = function(elementId: string): any {
  const el = document.getElementById(elementId);
  if (!el?.textContent) return null;
  try {
    return JSON.parse(el.textContent);
  } catch {
    return null;
  }
};
```

#### Client-Side Data Tables

Tables implement sorting, filtering, and pagination entirely in Alpine.js:

```javascript
x-data="{
  search: '',
  filter: 'all',
  sortColumn: 'name',
  sortDirection: 'asc',
  currentPage: 1,
  perPage: 10,
  allItems: [],

  get filteredData() { /* filter logic */ },
  get sortedData() { /* sort logic */ },
  get paginatedData() { /* pagination logic */ },

  sort(column) { /* toggle sort */ },
  goToPage(page) { /* change page */ }
}"
```

This approach:

- Eliminates server round-trips for sorting/filtering
- Provides instant feedback to user actions
- Reduces backend complexity for list views

#### Modal Dialogs

Modals use Alpine.js for open/close state with custom events:

```jinja2
<div x-data="{ open: false }"
     @open-add-item-modal.window="open = true"
     @keydown.escape.window="open = false">
  <div x-show="open" x-transition class="fixed inset-0 bg-black/50">
    <!-- Modal content -->
  </div>
</div>
```

Triggers dispatch events: `@click="$dispatch('open-add-item-modal')"`.

### 3. HTMX for Server-Driven Updates

HTMX handles dynamic content loading without full page reloads:

#### Partial Rendering

Components can refresh independently via HTMX triggers:

```html
<div id="items-table"
     hx-get="{% url 'core:items_table' %}"
     hx-trigger="refresh-items from:body"
     hx-swap="outerHTML">
```

Django views return partial HTML for HTMX requests.

#### WebSocket Integration

Real-time updates trigger HTMX refreshes:

```html
@ws:message.window="if (['item_created', 'item_deleted'].includes($event.detail.type)) {
  document.body.dispatchEvent(new CustomEvent('refresh-items'));
}"
```

### 4. Architecture Principles

#### Server-Driven Data

Data originates from Django views, not client-side API calls. This:

- Keeps authorization logic server-side
- Enables Django's template context processing
- Avoids duplicating API call patterns in JavaScript

#### Progressive Enhancement

Core functionality works without JavaScript. Alpine.js and HTMX enhance the experience:

- Tables display without sorting/filtering if JS fails
- Forms submit normally without HTMX
- Links work as standard navigation

#### Separation of Concerns

| Layer     | Technology                | Responsibility                             |
| --------- | ------------------------- | ------------------------------------------ |
| Structure | Django Templates (Jinja2) | HTML generation, server-side logic         |
| Styling   | Tailwind CSS              | Visual presentation, responsive layout     |
| State     | Alpine.js                 | Component state, client-side interactivity |
| Updates   | HTMX                      | Partial page updates, server communication |

## Consequences

### Positive

1. **Consistent UI**: The `tw-*` component system ensures visual consistency across all views
2. **Fast interactions**: Client-side sorting/filtering eliminates wait time for common operations
3. **Reduced complexity**: Alpine.js is simpler than Vue/React for the component patterns needed
4. **Maintainable CSS**: Tailwind's utility classes colocate styling with structure
5. **Smaller bundle**: Only used utilities are included in production CSS
6. **Theme support**: CSS custom properties enable dark mode and custom themes

### Negative

1. **Learning curve**: Developers need familiarity with Tailwind, Alpine.js, and HTMX
2. **Migration period**: Bootstrap and Tailwind coexist during transition, increasing bundle size
3. **Template verbosity**: Tailwind classes can make templates longer than semantic CSS

### Migration Path

The migration from Bootstrap to Tailwind is incremental:

1. New components use Tailwind exclusively
2. Existing pages are converted as they are touched
3. Bootstrap CSS is loaded alongside Tailwind during transition
4. Once all pages are converted, Bootstrap is removed

### File Structure

```text
sbomify/
├── static/
│   └── css/
│       └── tailwind.src.css          # Tailwind config and tw-* classes
├── apps/
│   └── core/
│       ├── js/
│       │   ├── main.ts               # Alpine.js initialization
│       │   └── htmx-bundle.ts        # HTMX + extensions
│       └── templates/
│           └── components/
│               └── tw/               # Jinja2 component macros
│                   ├── button.html.j2
│                   ├── badge.html.j2
│                   ├── card.html.j2
│                   └── ...
```
