# Generated by Django 5.2.7 on 2025-12-23 00:00

from django.db import migrations


def drop_legacy_constraint(apps, schema_editor):
    """
    Conditionally drop the legacy unique constraint on (team, link_type, url).
    This handles cases where the constraint might already be missing (avoiding ValueError).
    """
    model = apps.get_model("sboms", "ProductLink")
    db_table = model._meta.db_table
    quote_name = schema_editor.connection.ops.quote_name

    # Introspection to find the constraint
    with schema_editor.connection.cursor() as cursor:
        constraints = schema_editor.connection.introspection.get_constraints(cursor, db_table)

    for name, details in constraints.items():
        # Check for unique constraint on the specific columns
        # Note: 'team_id' is the column name for the 'team' ForeignKey
        if details['unique'] and set(details['columns']) == {'team_id', 'link_type', 'url'}:
            # Found the legacy constraint! Drop it.
            if schema_editor.connection.vendor == 'sqlite':
                schema_editor.execute(f"DROP INDEX {quote_name(name)}")
            elif schema_editor.connection.vendor == 'postgresql':
                schema_editor.execute(
                    f"ALTER TABLE {quote_name(db_table)} DROP CONSTRAINT {quote_name(name)}"
                )
            return


def restore_legacy_constraint(apps, schema_editor):
    """
    Reverse of drop_legacy_constraint: recreate the legacy unique constraint on (team, link_type, url).
    """
    model = apps.get_model("sboms", "ProductLink")
    db_table = model._meta.db_table
    columns_to_check = {'team_id', 'link_type', 'url'}

    with schema_editor.connection.cursor() as cursor:
        constraints = schema_editor.connection.introspection.get_constraints(cursor, db_table)

    for name, details in constraints.items():
        if details['unique'] and set(details['columns']) == columns_to_check:
            # Already exists
            return

    # Create the legacy constraint
    schema_editor.alter_unique_together(
        model,
        set(),  # old
        {('team', 'link_type', 'url')}  # new (legacy)
    )


def ensure_new_constraint(apps, schema_editor):
    """
    Conditionally create the new unique constraint on (product, link_type, url).
    This handles cases where the constraint might already exist (avoiding ProgrammingError).
    """
    model = apps.get_model("sboms", "ProductLink")
    db_table = model._meta.db_table
    columns_to_check = {'product_id', 'link_type', 'url'}

    with schema_editor.connection.cursor() as cursor:
        constraints = schema_editor.connection.introspection.get_constraints(cursor, db_table)

    for name, details in constraints.items():
        if details['unique'] and set(details['columns']) == columns_to_check:
            # Already exists
            return

    # Create it
    schema_editor.alter_unique_together(
        model,
        set(),  # old
        {('product', 'link_type', 'url')}  # new
    )


def drop_new_constraint(apps, schema_editor):
    """
    Reverse of ensure_new_constraint: drop the new unique constraint on (product, link_type, url).
    """
    model = apps.get_model("sboms", "ProductLink")
    db_table = model._meta.db_table
    quote_name = schema_editor.connection.ops.quote_name

    with schema_editor.connection.cursor() as cursor:
        constraints = schema_editor.connection.introspection.get_constraints(cursor, db_table)

    for name, details in constraints.items():
        if details['unique'] and set(details['columns']) == {'product_id', 'link_type', 'url'}:
            # Found the new constraint! Drop it.
            if schema_editor.connection.vendor == 'sqlite':
                schema_editor.execute(f"DROP INDEX {quote_name(name)}")
            elif schema_editor.connection.vendor == 'postgresql':
                schema_editor.execute(
                    f"ALTER TABLE {quote_name(db_table)} DROP CONSTRAINT {quote_name(name)}"
                )
            return


class Migration(migrations.Migration):

    dependencies = [
        ("sboms", "0038_component_is_global"),
    ]

    operations = [
        # Step 1: Tell Django the old constraint is gone (State Only), and attempt to drop it from DB conditionally (DB Only)
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.AlterUniqueTogether(
                    name="productlink",
                    unique_together=set(),
                ),
            ],
            database_operations=[
                migrations.RunPython(drop_legacy_constraint, reverse_code=restore_legacy_constraint),
            ],
        ),
        # Step 2: Add the new constraint (State Only + Conditional DB Creation).
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.AlterUniqueTogether(
                    name="productlink",
                    unique_together={("product", "link_type", "url")},
                ),
            ],
            database_operations=[
                migrations.RunPython(ensure_new_constraint, reverse_code=drop_new_constraint),
            ],
        ),
    ]

