# generated by datamodel-codegen:
#   filename:  cdx_bom-1.7.schema.json
#   timestamp: 2025-11-26T14:27:24+00:00

from __future__ import annotations

from datetime import date
from enum import Enum
from typing import Annotated

from pydantic import (
    AnyUrl,
    AwareDatetime,
    BaseModel,
    ConfigDict,
    EmailStr,
    Field,
    RootModel,
)

from . import spdx


class BomFormat(Enum):
    cyclone_dx = "CycloneDX"


class Confidence(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    score: Annotated[
        float | None,
        Field(
            description="The confidence of the claim between and inclusive of 0 and 1, where 1 is 100% confidence.",
            ge=0.0,
            le=1.0,
            title="Score",
        ),
    ] = None
    rationale: Annotated[
        str | None,
        Field(description="The rationale for the confidence score.", title="Rationale"),
    ] = None


class RefType(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Identifier for referable and therefore interlinkable elements.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            min_length=1,
            title="BOM Reference",
        ),
    ]


class RefLinkType(RootModel[RefType]):
    root: Annotated[
        RefType,
        Field(
            description="Descriptor for an element identified by the attribute 'bom-ref' in the same BOM document.\nIn contrast to `bomLinkElementType`.",
            title="BOM Reference",
        ),
    ]


class BomLinkDocumentType(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Descriptor for another BOM document. See https://cyclonedx.org/capabilities/bomlink/",
            pattern="^urn:cdx:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/[1-9][0-9]*$",
            title="BOM-Link Document",
        ),
    ]


class BomLinkElementType(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Descriptor for an element in a BOM document. See https://cyclonedx.org/capabilities/bomlink/",
            pattern="^urn:cdx:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/[1-9][0-9]*#.+$",
            title="BOM-Link Element",
        ),
    ]


class BomLink(RootModel[BomLinkDocumentType | BomLinkElementType]):
    root: Annotated[BomLinkDocumentType | BomLinkElementType, Field(title="BOM-Link")]


class Phase(Enum):
    design = "design"
    pre_build = "pre-build"
    build = "build"
    post_build = "post-build"
    operations = "operations"
    discovery = "discovery"
    decommission = "decommission"


class Lifecycles(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    phase: Annotated[
        Phase,
        Field(description="A pre-defined phase in the product lifecycle.", title="Phase"),
    ]


class Lifecycles1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[str, Field(description="The name of the lifecycle phase", title="Name")]
    description: Annotated[
        str | None,
        Field(description="The description of the lifecycle phase", title="Description"),
    ] = None


class TlpClassification(Enum):
    clear = "CLEAR"
    green = "GREEN"
    amber = "AMBER"
    amber_and_strict = "AMBER_AND_STRICT"
    red = "RED"


class OrganizationalContact(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the object elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ] = None
    name: Annotated[
        str | None,
        Field(description="The name of a contact", examples=["Contact name"], title="Name"),
    ] = None
    email: Annotated[
        EmailStr | None,
        Field(
            description="The email address of the contact.",
            examples=["firstname.lastname@example.com"],
            title="Email Address",
        ),
    ] = None
    phone: Annotated[
        str | None,
        Field(
            description="The phone number of the contact.",
            examples=["800-555-1212"],
            title="Phone",
        ),
    ] = None


class Type(Enum):
    application = "application"
    framework = "framework"
    library = "library"
    container = "container"
    platform = "platform"
    operating_system = "operating-system"
    device = "device"
    device_driver = "device-driver"
    firmware = "firmware"
    file = "file"
    machine_learning_model = "machine-learning-model"
    data = "data"
    cryptographic_asset = "cryptographic-asset"


class Scope(Enum):
    required = "required"
    optional = "optional"
    excluded = "excluded"


class Encoding(Enum):
    base64 = "base64"


class Attachment(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    content_type: Annotated[
        str | None,
        Field(
            alias="contentType",
            description="Specifies the format and nature of the data being attached, helping systems correctly interpret and process the content. Common content type examples include `application/json` for JSON data and `text/plain` for plan text documents.\n [RFC 2045 section 5.1](https://www.ietf.org/rfc/rfc2045.html#section-5.1) outlines the structure and use of content types. For a comprehensive list of registered content types, refer to the [IANA media types registry](https://www.iana.org/assignments/media-types/media-types.xhtml).",
            examples=["text/plain", "application/json", "image/png"],
            title="Content-Type",
        ),
    ] = "text/plain"
    encoding: Annotated[
        Encoding | None,
        Field(
            description="Specifies the encoding the text is represented in.",
            title="Encoding",
        ),
    ] = None
    content: Annotated[
        str,
        Field(
            description="The attachment data. Proactive controls such as input validation and sanitization should be employed to prevent misuse of attachment text.",
            title="Attachment Text",
        ),
    ]


class HashAlg(Enum):
    md5 = "MD5"
    sha_1 = "SHA-1"
    sha_256 = "SHA-256"
    sha_384 = "SHA-384"
    sha_512 = "SHA-512"
    sha3_256 = "SHA3-256"
    sha3_384 = "SHA3-384"
    sha3_512 = "SHA3-512"
    blake2b_256 = "BLAKE2b-256"
    blake2b_384 = "BLAKE2b-384"
    blake2b_512 = "BLAKE2b-512"
    blake3 = "BLAKE3"
    streebog_256 = "Streebog-256"
    streebog_512 = "Streebog-512"


class HashContent(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="The value of the hash.",
            examples=["3942447fac867ae5cdb3229b658f4d48"],
            pattern="^([a-fA-F0-9]{32}|[a-fA-F0-9]{40}|[a-fA-F0-9]{64}|[a-fA-F0-9]{96}|[a-fA-F0-9]{128})$",
            title="Hash Value",
        ),
    ]


class LicenseType(Enum):
    academic = "academic"
    appliance = "appliance"
    client_access = "client-access"
    concurrent_user = "concurrent-user"
    core_points = "core-points"
    custom_metric = "custom-metric"
    device = "device"
    evaluation = "evaluation"
    named_user = "named-user"
    node_locked = "node-locked"
    oem = "oem"
    perpetual = "perpetual"
    processor_points = "processor-points"
    subscription = "subscription"
    user = "user"
    other = "other"


class LicenseAcknowledgementEnumeration(Enum):
    declared = "declared"
    concluded = "concluded"


class ExpressionDetail(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    license_identifier: Annotated[
        str,
        Field(
            alias="licenseIdentifier",
            description="The valid SPDX license identifier. Refer to https://spdx.org/specifications for syntax requirements.\nThis property serves as the primary key, which uniquely identifies each record.",
            examples=[
                "Apache-2.0",
                "GPL-3.0-only WITH Classpath-exception-2.0",
                "LicenseRef-my-custom-license",
            ],
            title="License Identifier",
        ),
    ]
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the license elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ] = None
    text: Annotated[
        Attachment | None,
        Field(
            description="A way to include the textual content of the license.",
            title="License texts",
        ),
    ] = None
    url: Annotated[
        str | None,
        Field(
            description="The URL to the license file. If specified, a 'license' externalReference should also be specified for completeness",
            examples=["https://www.apache.org/licenses/LICENSE-2.0.txt"],
            title="License URL",
        ),
    ] = None


class Type1(Enum):
    unofficial = "unofficial"
    monkey = "monkey"
    backport = "backport"
    cherry_pick = "cherry-pick"


class Diff(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    text: Annotated[
        Attachment | None,
        Field(description="Specifies the text of the diff", title="Diff text"),
    ] = None
    url: Annotated[str | None, Field(description="Specifies the URL to the diff", title="URL")] = None


class Type2(Enum):
    defect = "defect"
    enhancement = "enhancement"
    security = "security"


class Source(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[
        str | None,
        Field(
            description="The name of the source.",
            examples=["National Vulnerability Database", "NVD", "Apache"],
            title="Name",
        ),
    ] = None
    url: Annotated[
        str | None,
        Field(
            description="The url of the issue documentation as provided by the source",
            title="URL",
        ),
    ] = None


class Issue(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[Type2, Field(description="Specifies the type of issue", title="Issue Type")]
    id: Annotated[
        str | None,
        Field(
            description="The identifier of the issue assigned by the source of the issue",
            title="Issue ID",
        ),
    ] = None
    name: Annotated[str | None, Field(description="The name of the issue", title="Issue Name")] = None
    description: Annotated[
        str | None,
        Field(description="A description of the issue", title="Issue Description"),
    ] = None
    source: Annotated[
        Source | None,
        Field(description="The source of the issue where it is documented", title="Source"),
    ] = None
    references: Annotated[
        list[str] | None,
        Field(
            description="A collection of URL's for reference. Multiple URLs are allowed.",
            examples=["https://example.com"],
            title="References",
        ),
    ] = None


class IdentifiableAction(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    timestamp: Annotated[
        AwareDatetime | None,
        Field(description="The timestamp in which the action occurred", title="Timestamp"),
    ] = None
    name: Annotated[
        str | None,
        Field(
            description="The name of the individual who performed the action",
            title="Name",
        ),
    ] = None
    email: Annotated[
        EmailStr | None,
        Field(
            description="The email address of the individual who performed the action",
            title="E-mail",
        ),
    ] = None


class Type3(Enum):
    vcs = "vcs"
    issue_tracker = "issue-tracker"
    website = "website"
    advisories = "advisories"
    bom = "bom"
    mailing_list = "mailing-list"
    social = "social"
    chat = "chat"
    documentation = "documentation"
    support = "support"
    source_distribution = "source-distribution"
    distribution = "distribution"
    distribution_intake = "distribution-intake"
    license = "license"
    build_meta = "build-meta"
    build_system = "build-system"
    release_notes = "release-notes"
    security_contact = "security-contact"
    model_card = "model-card"
    log = "log"
    configuration = "configuration"
    evidence = "evidence"
    formulation = "formulation"
    attestation = "attestation"
    threat_model = "threat-model"
    adversary_model = "adversary-model"
    risk_assessment = "risk-assessment"
    vulnerability_assertion = "vulnerability-assertion"
    exploitability_statement = "exploitability-statement"
    pentest_report = "pentest-report"
    static_analysis_report = "static-analysis-report"
    dynamic_analysis_report = "dynamic-analysis-report"
    runtime_analysis_report = "runtime-analysis-report"
    component_analysis_report = "component-analysis-report"
    maturity_report = "maturity-report"
    certification_report = "certification-report"
    codified_infrastructure = "codified-infrastructure"
    quality_metrics = "quality-metrics"
    poam = "poam"
    electronic_signature = "electronic-signature"
    digital_signature = "digital-signature"
    rfc_9116 = "rfc-9116"
    patent = "patent"
    patent_family = "patent-family"
    patent_assertion = "patent-assertion"
    citation = "citation"
    other = "other"


class Dependency(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    ref: Annotated[
        RefLinkType,
        Field(
            description="References a component or service by its bom-ref attribute",
            title="Reference",
        ),
    ]
    depends_on: Annotated[
        list[RefLinkType] | None,
        Field(
            alias="dependsOn",
            description="The bom-ref identifiers of the components or services that are dependencies of this dependency object.",
            title="Depends On",
        ),
    ] = None
    provides: Annotated[
        list[RefLinkType] | None,
        Field(
            description="The bom-ref identifiers of the components or services that define a given specification or standard, which are provided or implemented by this dependency object.\nFor example, a cryptographic library which implements a cryptographic algorithm. A component which implements another component does not imply that the implementation is in use.",
            title="Provides",
        ),
    ] = None


class DataFlowDirection(Enum):
    inbound = "inbound"
    outbound = "outbound"
    bi_directional = "bi-directional"
    unknown = "unknown"


class Copyright(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    text: Annotated[
        str,
        Field(description="The textual content of the copyright.", title="Copyright Text"),
    ]


class Occurrence(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the occurrence elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ] = None
    location: Annotated[
        str,
        Field(
            description="The location or path to where the component was found.",
            title="Location",
        ),
    ]
    line: Annotated[
        int | None,
        Field(
            description="The line number where the component was found.",
            ge=0,
            title="Line Number",
        ),
    ] = None
    offset: Annotated[
        int | None,
        Field(
            description="The offset where the component was found.",
            ge=0,
            title="Offset",
        ),
    ] = None
    symbol: Annotated[
        str | None,
        Field(
            description="The symbol name that was found associated with the component.",
            title="Symbol",
        ),
    ] = None
    additional_context: Annotated[
        str | None,
        Field(
            alias="additionalContext",
            description="Any additional context of the detected component (e.g. a code snippet).",
            title="Additional Context",
        ),
    ] = None


class Frame(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    package: Annotated[
        str | None,
        Field(
            description="A package organizes modules into namespaces, providing a unique namespace for each type it contains.",
            title="Package",
        ),
    ] = None
    module: Annotated[
        str,
        Field(
            description="A module or class that encloses functions/methods and other code.",
            title="Module",
        ),
    ]
    function: Annotated[
        str | None,
        Field(
            description="A block of code designed to perform a particular task.",
            title="Function",
        ),
    ] = None
    parameters: Annotated[
        list[str] | None,
        Field(
            description="Arguments that are passed to the module or function.",
            title="Parameters",
        ),
    ] = None
    line: Annotated[
        int | None,
        Field(
            description="The line number the code that is called resides on.",
            title="Line",
        ),
    ] = None
    column: Annotated[
        int | None,
        Field(description="The column the code that is called resides.", title="Column"),
    ] = None
    full_filename: Annotated[
        str | None,
        Field(
            alias="fullFilename",
            description="The full path and filename of the module.",
            title="Full Filename",
        ),
    ] = None


class Callstack(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    frames: Annotated[
        list[Frame] | None,
        Field(
            description="Within a call stack, a frame is a discrete unit that encapsulates an execution context, including local variables, parameters, and the return address. As function calls are made, frames are pushed onto the stack, forming an array-like structure that orchestrates the flow of program execution and manages the sequence of function invocations.",
            title="Frames",
        ),
    ] = None


class AggregateType(Enum):
    complete = "complete"
    incomplete = "incomplete"
    incomplete_first_party_only = "incomplete_first_party_only"
    incomplete_first_party_proprietary_only = "incomplete_first_party_proprietary_only"
    incomplete_first_party_opensource_only = "incomplete_first_party_opensource_only"
    incomplete_third_party_only = "incomplete_third_party_only"
    incomplete_third_party_proprietary_only = "incomplete_third_party_proprietary_only"
    incomplete_third_party_opensource_only = "incomplete_third_party_opensource_only"
    unknown = "unknown"
    not_specified = "not_specified"


class Property(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[
        str,
        Field(
            description="The name of the property. Duplicate names are allowed, each potentially having a different value.",
            title="Name",
        ),
    ]
    value: Annotated[str | None, Field(description="The value of the property.", title="Value")] = None


class LocaleType(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Defines a syntax for representing two character language code (ISO-639) followed by an optional two character country code. The language code must be lower case. If the country code is specified, the country code must be upper case. The language code and country code must be separated by a minus sign. Examples: en, en-US, fr, fr-CA",
            pattern="^([a-z]{2})(-[A-Z]{2})?$",
            title="Locale",
        ),
    ]


class ReleaseType(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="The software versioning type. It is recommended that the release type use one of 'major', 'minor', 'patch', 'pre-release', or 'internal'. Representing all possible software release types is not practical, so standardizing on the recommended values, whenever possible, is strongly encouraged.\n\n* __major__ = A major release may contain significant changes or may introduce breaking changes.\n* __minor__ = A minor release, also known as an update, may contain a smaller number of changes than major releases.\n* __patch__ = Patch releases are typically unplanned and may resolve defects or important security issues.\n* __pre-release__ = A pre-release may include alpha, beta, or release candidates and typically have limited support. They provide the ability to preview a release prior to its general availability.\n* __internal__ = Internal releases are not for public consumption and are intended to be used exclusively by the project or manufacturer that produced it.",
            examples=["major", "minor", "patch", "pre-release", "internal"],
        ),
    ]


class Note(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    locale: Annotated[
        LocaleType | None,
        Field(
            description='The ISO-639 (or higher) language code and optional ISO-3166 (or higher) country code. Examples include: "en", "en-US", "fr" and "fr-CA"',
            title="Locale",
        ),
    ] = None
    text: Annotated[
        Attachment,
        Field(
            description="Specifies the full content of the release note.",
            title="Release note content",
        ),
    ]


class Advisory(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    title: Annotated[str | None, Field(description="A name of the advisory.", title="Title")] = None
    url: Annotated[
        str,
        Field(description="Location where the advisory can be obtained.", title="URL"),
    ]


class Cwe(RootModel[int]):
    root: Annotated[
        int,
        Field(
            description="Integer representation of a Common Weaknesses Enumerations (CWE). For example 399 (of https://cwe.mitre.org/data/definitions/399.html)",
            ge=1,
            title="CWE",
        ),
    ]


class Severity(Enum):
    critical = "critical"
    high = "high"
    medium = "medium"
    low = "low"
    info = "info"
    none = "none"
    unknown = "unknown"


class ScoreMethod(Enum):
    cvs_sv2 = "CVSSv2"
    cvs_sv3 = "CVSSv3"
    cvs_sv31 = "CVSSv31"
    cvs_sv4 = "CVSSv4"
    owasp = "OWASP"
    ssvc = "SSVC"
    other = "other"


class ImpactAnalysisState(Enum):
    resolved = "resolved"
    resolved_with_pedigree = "resolved_with_pedigree"
    exploitable = "exploitable"
    in_triage = "in_triage"
    false_positive = "false_positive"
    not_affected = "not_affected"


class ImpactAnalysisJustification(Enum):
    code_not_present = "code_not_present"
    code_not_reachable = "code_not_reachable"
    requires_configuration = "requires_configuration"
    requires_dependency = "requires_dependency"
    requires_environment = "requires_environment"
    protected_by_compiler = "protected_by_compiler"
    protected_at_runtime = "protected_at_runtime"
    protected_at_perimeter = "protected_at_perimeter"
    protected_by_mitigating_control = "protected_by_mitigating_control"


class VulnerabilitySource(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    url: Annotated[
        str | None,
        Field(
            description="The url of the vulnerability documentation as provided by the source.",
            examples=["https://nvd.nist.gov/vuln/detail/CVE-2021-39182"],
            title="URL",
        ),
    ] = None
    name: Annotated[
        str | None,
        Field(
            description="The name of the source.",
            examples=[
                "NVD",
                "National Vulnerability Database",
                "OSS Index",
                "VulnDB",
                "GitHub Advisories",
            ],
            title="Name",
        ),
    ] = None


class Reference(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Annotated[
        str,
        Field(
            description="An identifier that uniquely identifies the vulnerability.",
            examples=[
                "CVE-2021-39182",
                "GHSA-35m5-8cvj-8783",
                "SNYK-PYTHON-ENROCRYPT-1912876",
            ],
            title="ID",
        ),
    ]
    source: Annotated[
        VulnerabilitySource,
        Field(description="The source that published the vulnerability."),
    ]


class ProofOfConcept(BaseModel):
    reproduction_steps: Annotated[
        str | None,
        Field(
            alias="reproductionSteps",
            description="Precise steps to reproduce the vulnerability.",
            title="Steps to Reproduce",
        ),
    ] = None
    environment: Annotated[
        str | None,
        Field(
            description="A description of the environment in which reproduction was possible.",
            title="Environment",
        ),
    ] = None
    supporting_material: Annotated[
        list[Attachment] | None,
        Field(
            alias="supportingMaterial",
            description="Supporting material that helps in reproducing or understanding how reproduction is possible. This may include screenshots, payloads, and PoC exploit code.",
            title="Supporting Material",
        ),
    ] = None


class ResponseEnum(Enum):
    can_not_fix = "can_not_fix"
    will_not_fix = "will_not_fix"
    update = "update"
    rollback = "rollback"
    workaround_available = "workaround_available"


class Analysis(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    state: ImpactAnalysisState | None = None
    justification: ImpactAnalysisJustification | None = None
    response: Annotated[
        list[ResponseEnum] | None,
        Field(
            description="A response to the vulnerability by the manufacturer, supplier, or project responsible for the affected component or service. More than one response is allowed. Responses are strongly encouraged for vulnerabilities where the analysis state is exploitable.",
            title="Response",
        ),
    ] = None
    detail: Annotated[
        str | None,
        Field(
            description="Detailed description of the impact including methods used during assessment. If a vulnerability is not exploitable, this field should include specific details on why the component or service is not impacted by this vulnerability.",
            title="Detail",
        ),
    ] = None
    first_issued: Annotated[
        AwareDatetime | None,
        Field(
            alias="firstIssued",
            description="The date and time (timestamp) when the analysis was first issued.",
            title="First Issued",
        ),
    ] = None
    last_updated: Annotated[
        AwareDatetime | None,
        Field(
            alias="lastUpdated",
            description="The date and time (timestamp) when the analysis was last updated.",
            title="Last Updated",
        ),
    ] = None


class AffectedStatus(Enum):
    affected = "affected"
    unaffected = "unaffected"
    unknown = "unknown"


class Version(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A single disjunctive version identifier, for a component or service.",
            examples=[
                "9.0.14",
                "v1.33.7",
                "7.0.0-M1",
                "2.0pre1",
                "1.0.0-beta1",
                "0.8.15",
            ],
            max_length=1024,
        ),
    ]


class VersionRange(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A version range specified in Package URL Version Range syntax (vers) which is defined at https://github.com/package-url/vers-spec",
            examples=[
                "vers:cargo/9.0.14",
                "vers:npm/1.2.3|>=2.0.0|<5.0.0",
                "vers:pypi/0.0.0|0.0.1|0.0.2|0.0.3|1.0|2.0pre1",
                "vers:tomee/>=1.0.0-beta1|<=1.7.5|>=7.0.0-M1|<=7.0.7|>=7.1.0|<=7.1.2|>=8.0.0-M1|<=8.0.1",
                "vers:gem/>=2.2.0|!= 2.2.1|<2.3.0",
            ],
            max_length=4096,
            min_length=1,
        ),
    ]


class Range(RootModel[VersionRange]):
    root: Annotated[
        VersionRange,
        Field(description="Deprecated definition. use definition `versionRange` instead."),
    ]


class Type4(Enum):
    supervised = "supervised"
    unsupervised = "unsupervised"
    reinforcement_learning = "reinforcement-learning"
    semi_supervised = "semi-supervised"
    self_supervised = "self-supervised"


class Approach(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[
        Type4 | None,
        Field(
            description="Learning types describing the learning problem or hybrid learning problem.",
            title="Learning Type",
        ),
    ] = None


class Datasets(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    ref: Annotated[
        RefLinkType | BomLinkElementType | None,
        Field(
            description="References a data component by the components bom-ref attribute",
            title="Reference",
        ),
    ] = None


class InputOutputMLParameters(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    format: Annotated[
        str | None,
        Field(
            description="The data format for input/output to the model.",
            examples=["string", "image", "time-series"],
            title="Input/Output Format",
        ),
    ] = None


class Type5(Enum):
    source_code = "source-code"
    configuration = "configuration"
    dataset = "dataset"
    definition = "definition"
    other = "other"


class Contents1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    attachment: Annotated[
        Attachment | None,
        Field(
            description="A way to include textual or encoded data.",
            title="Data Attachment",
        ),
    ] = None
    url: Annotated[
        str | None,
        Field(description="The URL to where the data can be retrieved.", title="Data URL"),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document name-value parameters used for configuration.",
            title="Configuration Properties",
        ),
    ] = None


class Graphic(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[str | None, Field(description="The name of the graphic.", title="Name")] = None
    image: Annotated[
        Attachment | None,
        Field(
            description="The graphic (vector or raster). Base64 encoding must be specified for binary images.",
            title="Graphic Image",
        ),
    ] = None


class ConfidenceInterval(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    lower_bound: Annotated[
        str | None,
        Field(
            alias="lowerBound",
            description="The lower bound of the confidence interval.",
            title="Lower Bound",
        ),
    ] = None
    upper_bound: Annotated[
        str | None,
        Field(
            alias="upperBound",
            description="The upper bound of the confidence interval.",
            title="Upper Bound",
        ),
    ] = None


class PerformanceMetric(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[str | None, Field(description="The type of performance metric.", title="Type")] = None
    value: Annotated[
        str | None,
        Field(description="The value of the performance metric.", title="Value"),
    ] = None
    slice: Annotated[
        str | None,
        Field(
            description="The name of the slice this metric was computed on. By default, assume this metric is not sliced.",
            title="Slice",
        ),
    ] = None
    confidence_interval: Annotated[
        ConfidenceInterval | None,
        Field(
            alias="confidenceInterval",
            description="The confidence interval of the metric.",
            title="Confidence Interval",
        ),
    ] = None


class Risk(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[str | None, Field(description="The name of the risk.", title="Name")] = None
    mitigation_strategy: Annotated[
        str | None,
        Field(
            alias="mitigationStrategy",
            description="Strategy used to address this risk.",
            title="Mitigation Strategy",
        ),
    ] = None


class FairnessAssessment(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    group_at_risk: Annotated[
        str | None,
        Field(
            alias="groupAtRisk",
            description="The groups or individuals at risk of being systematically disadvantaged by the model.",
            title="Group at Risk",
        ),
    ] = None
    benefits: Annotated[
        str | None,
        Field(description="Expected benefits to the identified groups.", title="Benefits"),
    ] = None
    harms: Annotated[
        str | None,
        Field(description="Expected harms to the identified groups.", title="Harms"),
    ] = None
    mitigation_strategy: Annotated[
        str | None,
        Field(
            alias="mitigationStrategy",
            description="With respect to the benefits and harms outlined, please describe any mitigation strategy implemented.",
            title="Mitigation Strategy",
        ),
    ] = None


class DataClassification(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Data classification tags data according to its type, sensitivity, and value if altered, stolen, or destroyed.",
            title="Data Classification",
        ),
    ]


class Activity(Enum):
    design = "design"
    data_collection = "data-collection"
    data_preparation = "data-preparation"
    training = "training"
    fine_tuning = "fine-tuning"
    validation = "validation"
    deployment = "deployment"
    inference = "inference"
    other = "other"


class Unit(Enum):
    k_wh = "kWh"


class EnergyMeasure(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    value: Annotated[float, Field(description="Quantity of energy.", title="Value")]
    unit: Annotated[Unit, Field(description="Unit of energy.", title="Unit")]


class Unit1(Enum):
    t_co2eq = "tCO2eq"


class Co2Measure(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    value: Annotated[float, Field(description="Quantity of carbon dioxide (CO2).", title="Value")]
    unit: Annotated[Unit1, Field(description="Unit of carbon dioxide (CO2).", title="Unit")]


class EnergySource(Enum):
    coal = "coal"
    oil = "oil"
    natural_gas = "natural-gas"
    nuclear = "nuclear"
    wind = "wind"
    solar = "solar"
    geothermal = "geothermal"
    hydropower = "hydropower"
    biofuel = "biofuel"
    unknown = "unknown"
    other = "other"


class PostalAddress(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the address elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ] = None
    country: Annotated[
        str | None,
        Field(
            description="The country name or the two-letter ISO 3166-1 country code.",
            title="Country",
        ),
    ] = None
    region: Annotated[
        str | None,
        Field(
            description="The region or state in the country.",
            examples=["Texas"],
            title="Region",
        ),
    ] = None
    locality: Annotated[
        str | None,
        Field(
            description="The locality or city within the country.",
            examples=["Austin"],
            title="Locality",
        ),
    ] = None
    post_office_box_number: Annotated[
        str | None,
        Field(
            alias="postOfficeBoxNumber",
            description="The post office box number.",
            examples=["901"],
            title="Post Office Box Number",
        ),
    ] = None
    postal_code: Annotated[
        str | None,
        Field(
            alias="postalCode",
            description="The postal code.",
            examples=["78758"],
            title="Postal Code",
        ),
    ] = None
    street_address: Annotated[
        str | None,
        Field(
            alias="streetAddress",
            description="The street address.",
            examples=["100 Main Street"],
            title="Street Address",
        ),
    ] = None


class Command(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    executed: Annotated[
        str | None,
        Field(
            description="A text representation of the executed command.",
            title="Executed",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class AccessMode(Enum):
    read_only = "read-only"
    read_write = "read-write"
    read_write_once = "read-write-once"
    write_once = "write-once"
    write_only = "write-only"


class Mode(Enum):
    filesystem = "filesystem"
    block = "block"


class Volume(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    uid: Annotated[
        str | None,
        Field(
            description="The unique identifier for the volume instance within its deployment context.",
            title="Unique Identifier (UID)",
        ),
    ] = None
    name: Annotated[str | None, Field(description="The name of the volume instance", title="Name")] = None
    mode: Annotated[
        Mode | None,
        Field(description="The mode for the volume instance.", title="Mode"),
    ] = "filesystem"
    path: Annotated[
        str | None,
        Field(
            description="The underlying path created from the actual volume.",
            title="Path",
        ),
    ] = None
    size_allocated: Annotated[
        str | None,
        Field(
            alias="sizeAllocated",
            description="The allocated size of the volume accessible to the associated workspace. This should include the scalar size as well as IEC standard unit in either decimal or binary form.",
            examples=["10GB", "2Ti", "1Pi"],
            title="Size allocated",
        ),
    ] = None
    persistent: Annotated[
        bool | None,
        Field(
            description="Indicates if the volume persists beyond the life of the resource it is associated with.",
            title="Persistent",
        ),
    ] = None
    remote: Annotated[
        bool | None,
        Field(
            description="Indicates if the volume is remotely (i.e., network) attached.",
            title="Remote",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class Type6(Enum):
    manual = "manual"
    api = "api"
    webhook = "webhook"
    scheduled = "scheduled"


class Type7(Enum):
    artifact = "artifact"
    attestation = "attestation"
    log = "log"
    evidence = "evidence"
    metrics = "metrics"
    other = "other"


class Condition(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    description: Annotated[
        str | None,
        Field(
            description="Describes the set of conditions which cause the trigger to activate.",
            title="Description",
        ),
    ] = None
    expression: Annotated[
        str | None,
        Field(
            description="The logical expression that was evaluated that determined the trigger should be fired.",
            title="Expression",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class TaskType(Enum):
    copy = "copy"
    clone = "clone"
    lint = "lint"
    scan = "scan"
    merge = "merge"
    build = "build"
    test = "test"
    deliver = "deliver"
    deploy = "deploy"
    release = "release"
    clean = "clean"
    other = "other"


class Parameter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[str | None, Field(description="The name of the parameter.", title="Name")] = None
    value: Annotated[str | None, Field(description="The value of the parameter.", title="Value")] = None
    data_type: Annotated[
        str | None,
        Field(
            alias="dataType",
            description="The data type of the parameter.",
            title="Data type",
        ),
    ] = None


class FieldModel(Enum):
    group = "group"
    name = "name"
    version = "version"
    purl = "purl"
    cpe = "cpe"
    omnibor_id = "omniborId"
    swhid = "swhid"
    swid = "swid"
    hash = "hash"


class Technique(Enum):
    source_code_analysis = "source-code-analysis"
    binary_analysis = "binary-analysis"
    manifest_analysis = "manifest-analysis"
    ast_fingerprint = "ast-fingerprint"
    hash_comparison = "hash-comparison"
    instrumentation = "instrumentation"
    dynamic_analysis = "dynamic-analysis"
    filename = "filename"
    attestation = "attestation"
    other = "other"


class Method(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    technique: Annotated[
        Technique,
        Field(
            description="The technique used in this method of analysis.",
            title="Technique",
        ),
    ]
    confidence: Annotated[
        float,
        Field(
            description="The confidence of the evidence from 0 - 1, where 1 is 100% confidence. Confidence is specific to the technique used. Each technique of analysis can have independent confidence.",
            ge=0.0,
            le=1.0,
            title="Confidence",
        ),
    ]
    value: Annotated[
        str | None,
        Field(description="The value or contents of the evidence.", title="Value"),
    ] = None


class ComponentIdentityEvidence(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    field: Annotated[
        FieldModel,
        Field(
            description="The identity field of the component which the evidence describes.",
            title="Field",
        ),
    ]
    confidence: Annotated[
        float | None,
        Field(
            description="The overall confidence of the evidence from 0 - 1, where 1 is 100% confidence.",
            ge=0.0,
            le=1.0,
            title="Confidence",
        ),
    ] = None
    concluded_value: Annotated[
        str | None,
        Field(
            alias="concludedValue",
            description="The value of the field (cpe, purl, etc) that has been concluded based on the aggregate of all methods (if available).",
            title="Concluded Value",
        ),
    ] = None
    methods: Annotated[
        list[Method] | None,
        Field(
            description="The methods used to extract and/or analyze the evidence.",
            title="Methods",
        ),
    ] = None
    tools: Annotated[
        list[RefLinkType | BomLinkElementType] | None,
        Field(
            description="The object in the BOM identified by its bom-ref. This is often a component or service but may be any object type supporting bom-refs. Tools used for analysis should already be defined in the BOM, either in the metadata/tools, components, or formulation.",
            title="BOM References",
        ),
    ] = None


class OpenCreItem(RootModel[str]):
    root: Annotated[str, Field(examples=["CRE:764-507"], pattern="^CRE:[0-9]+-[0-9]+$")]


class Level(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the object elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    identifier: Annotated[
        str | None,
        Field(
            description="The identifier used in the standard to identify a specific level.",
            title="Identifier",
        ),
    ] = None
    title: Annotated[str | None, Field(description="The title of the level.", title="Title")] = None
    description: Annotated[
        str | None,
        Field(description="The description of the level.", title="Description"),
    ] = None
    requirements: Annotated[
        list[RefLinkType] | None,
        Field(
            description="The list of requirement `bom-ref`s that comprise the level.",
            title="Requirements",
        ),
    ] = None


class Algorithm(Enum):
    rs256 = "RS256"
    rs384 = "RS384"
    rs512 = "RS512"
    ps256 = "PS256"
    ps384 = "PS384"
    ps512 = "PS512"
    es256 = "ES256"
    es384 = "ES384"
    es512 = "ES512"
    ed25519 = "Ed25519"
    ed448 = "Ed448"
    hs256 = "HS256"
    hs384 = "HS384"
    hs512 = "HS512"


class KeyType(Enum):
    ec = "EC"
    okp = "OKP"
    rsa = "RSA"


class PublicKey(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    kty: KeyType


class AssetType(Enum):
    algorithm = "algorithm"
    certificate = "certificate"
    protocol = "protocol"
    related_crypto_material = "related-crypto-material"


class Primitive(Enum):
    drbg = "drbg"
    mac = "mac"
    block_cipher = "block-cipher"
    stream_cipher = "stream-cipher"
    signature = "signature"
    hash = "hash"
    pke = "pke"
    xof = "xof"
    kdf = "kdf"
    key_agree = "key-agree"
    kem = "kem"
    ae = "ae"
    combiner = "combiner"
    key_wrap = "key-wrap"
    other = "other"
    unknown = "unknown"


class ExecutionEnvironment(Enum):
    software_plain_ram = "software-plain-ram"
    software_encrypted_ram = "software-encrypted-ram"
    software_tee = "software-tee"
    hardware = "hardware"
    other = "other"
    unknown = "unknown"


class ImplementationPlatform(Enum):
    generic = "generic"
    x86_32 = "x86_32"
    x86_64 = "x86_64"
    armv7_a = "armv7-a"
    armv7_m = "armv7-m"
    armv8_a = "armv8-a"
    armv8_m = "armv8-m"
    armv9_a = "armv9-a"
    armv9_m = "armv9-m"
    s390x = "s390x"
    ppc64 = "ppc64"
    ppc64le = "ppc64le"
    other = "other"
    unknown = "unknown"


class CertificationLevelEnum(Enum):
    none = "none"
    fips140_1_l1 = "fips140-1-l1"
    fips140_1_l2 = "fips140-1-l2"
    fips140_1_l3 = "fips140-1-l3"
    fips140_1_l4 = "fips140-1-l4"
    fips140_2_l1 = "fips140-2-l1"
    fips140_2_l2 = "fips140-2-l2"
    fips140_2_l3 = "fips140-2-l3"
    fips140_2_l4 = "fips140-2-l4"
    fips140_3_l1 = "fips140-3-l1"
    fips140_3_l2 = "fips140-3-l2"
    fips140_3_l3 = "fips140-3-l3"
    fips140_3_l4 = "fips140-3-l4"
    cc_eal1 = "cc-eal1"
    cc_eal1_ = "cc-eal1+"
    cc_eal2 = "cc-eal2"
    cc_eal2_ = "cc-eal2+"
    cc_eal3 = "cc-eal3"
    cc_eal3_ = "cc-eal3+"
    cc_eal4 = "cc-eal4"
    cc_eal4_ = "cc-eal4+"
    cc_eal5 = "cc-eal5"
    cc_eal5_ = "cc-eal5+"
    cc_eal6 = "cc-eal6"
    cc_eal6_ = "cc-eal6+"
    cc_eal7 = "cc-eal7"
    cc_eal7_ = "cc-eal7+"
    other = "other"
    unknown = "unknown"


class Mode1(Enum):
    cbc = "cbc"
    ecb = "ecb"
    ccm = "ccm"
    gcm = "gcm"
    cfb = "cfb"
    ofb = "ofb"
    ctr = "ctr"
    other = "other"
    unknown = "unknown"


class Padding(Enum):
    pkcs5 = "pkcs5"
    pkcs7 = "pkcs7"
    pkcs1v15 = "pkcs1v15"
    oaep = "oaep"
    raw = "raw"
    other = "other"
    unknown = "unknown"


class CryptoFunction(Enum):
    generate = "generate"
    keygen = "keygen"
    encrypt = "encrypt"
    decrypt = "decrypt"
    digest = "digest"
    tag = "tag"
    keyderive = "keyderive"
    sign = "sign"
    verify = "verify"
    encapsulate = "encapsulate"
    decapsulate = "decapsulate"
    other = "other"
    unknown = "unknown"


class State(Enum):
    pre_activation = "pre-activation"
    active = "active"
    suspended = "suspended"
    deactivated = "deactivated"
    revoked = "revoked"
    destroyed = "destroyed"


class CertificateState(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    state: Annotated[
        State,
        Field(
            description="A pre-defined state in the certificate lifecycle.",
            title="State",
        ),
    ]
    reason: Annotated[
        str | None,
        Field(
            description="A reason for the certificate being in this state.",
            title="Reason",
        ),
    ] = None


class CertificateState1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[
        str,
        Field(description="The name of the certificate lifecycle state.", title="State"),
    ]
    description: Annotated[
        str | None,
        Field(
            description="The description of the certificate lifecycle state.",
            title="Description",
        ),
    ] = None
    reason: Annotated[
        str | None,
        Field(
            description="A reason for the certificate being in this state.",
            title="Reason",
        ),
    ] = None


class CommonExtensionName(Enum):
    basic_constraints = "basicConstraints"
    key_usage = "keyUsage"
    extended_key_usage = "extendedKeyUsage"
    subject_alternative_name = "subjectAlternativeName"
    authority_key_identifier = "authorityKeyIdentifier"
    subject_key_identifier = "subjectKeyIdentifier"
    authority_information_access = "authorityInformationAccess"
    certificate_policies = "certificatePolicies"
    crl_distribution_points = "crlDistributionPoints"
    signed_certificate_timestamp = "signedCertificateTimestamp"


class CertificateExtensions(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    common_extension_name: Annotated[
        CommonExtensionName,
        Field(
            alias="commonExtensionName",
            description="The name of the extension.",
            title="name",
        ),
    ]
    common_extension_value: Annotated[
        str,
        Field(
            alias="commonExtensionValue",
            description="The value of the certificate extension.",
            title="Value",
        ),
    ]


class CertificateExtensions1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    custom_extension_name: Annotated[
        str,
        Field(
            alias="customExtensionName",
            description="The name for the custom certificate extension.",
            title="Name",
        ),
    ]
    custom_extension_value: Annotated[
        str | None,
        Field(
            alias="customExtensionValue",
            description="The description of the custom certificate extension.",
            title="Value",
        ),
    ] = None


class Type10(Enum):
    private_key = "private-key"
    public_key = "public-key"
    secret_key = "secret-key"
    key = "key"
    ciphertext = "ciphertext"
    signature = "signature"
    digest = "digest"
    initialization_vector = "initialization-vector"
    nonce = "nonce"
    seed = "seed"
    salt = "salt"
    shared_secret = "shared-secret"
    tag = "tag"
    additional_data = "additional-data"
    password = "password"
    credential = "credential"
    token = "token"
    other = "other"
    unknown = "unknown"


class State1(Enum):
    pre_activation = "pre-activation"
    active = "active"
    suspended = "suspended"
    deactivated = "deactivated"
    compromised = "compromised"
    destroyed = "destroyed"


class Type11(Enum):
    tls = "tls"
    ssh = "ssh"
    ipsec = "ipsec"
    ike = "ike"
    sstp = "sstp"
    wpa = "wpa"
    dtls = "dtls"
    quic = "quic"
    eap_aka = "eap-aka"
    eap_aka_prime = "eap-aka-prime"
    prins = "prins"
    field_5g_aka = "5g-aka"
    other = "other"
    unknown = "unknown"


class AlgorithmFamiliesEnum(Enum):
    field_3_des = "3DES"
    field_3_gpp_xor = "3GPP-XOR"
    a5_1 = "A5/1"
    a5_2 = "A5/2"
    aes = "AES"
    aria = "ARIA"
    ascon = "Ascon"
    blake2 = "BLAKE2"
    blake3 = "BLAKE3"
    bls = "BLS"
    blowfish = "Blowfish"
    camellia = "CAMELLIA"
    cast5 = "CAST5"
    cast6 = "CAST6"
    cmac = "CMAC"
    cmea = "CMEA"
    cha_cha = "ChaCha"
    cha_cha20 = "ChaCha20"
    des = "DES"
    dsa = "DSA"
    ecdh = "ECDH"
    ecdsa = "ECDSA"
    ecies = "ECIES"
    ed_dsa = "EdDSA"
    el_gamal = "ElGamal"
    ffdh = "FFDH"
    fortuna = "Fortuna"
    gost = "GOST"
    hc = "HC"
    hkdf = "HKDF"
    hmac = "HMAC"
    idea = "IDEA"
    ike_prf = "IKE-PRF"
    kmac = "KMAC"
    lms = "LMS"
    md2 = "MD2"
    md4 = "MD4"
    md5 = "MD5"
    milenage = "MILENAGE"
    ml_dsa = "ML-DSA"
    ml_kem = "ML-KEM"
    mqv = "MQV"
    pbes1 = "PBES1"
    pbes2 = "PBES2"
    pbkdf1 = "PBKDF1"
    pbkdf2 = "PBKDF2"
    pbmac1 = "PBMAC1"
    poly1305 = "Poly1305"
    rabbit = "RABBIT"
    rc2 = "RC2"
    rc4 = "RC4"
    rc5 = "RC5"
    rc6 = "RC6"
    ripemd = "RIPEMD"
    rsaes_oaep = "RSAES-OAEP"
    rsaes_pkcs1 = "RSAES-PKCS1"
    rsassa_pkcs1 = "RSASSA-PKCS1"
    rsassa_pss = "RSASSA-PSS"
    seed = "SEED"
    sha_1 = "SHA-1"
    sha_2 = "SHA-2"
    sha_3 = "SHA-3"
    slh_dsa = "SLH-DSA"
    snow3_g = "SNOW3G"
    sp800_108 = "SP800-108"
    salsa20 = "Salsa20"
    serpent = "Serpent"
    sip_hash = "SipHash"
    skipjack = "Skipjack"
    tuak = "TUAK"
    twofish = "Twofish"
    whirlpool = "Whirlpool"
    x3_dh = "X3DH"
    xmss = "XMSS"
    yarrow = "Yarrow"
    zuc = "ZUC"
    bcrypt = "bcrypt"


class EllipticCurvesEnum(Enum):
    anssi_frp256v1 = "anssi/FRP256v1"
    bls_bls12_377 = "bls/BLS12-377"
    bls_bls12_381 = "bls/BLS12-381"
    bls_bls12_446 = "bls/BLS12-446"
    bls_bls12_455 = "bls/BLS12-455"
    bls_bls12_638 = "bls/BLS12-638"
    bls_bls24_477 = "bls/BLS24-477"
    bls_bandersnatch = "bls/Bandersnatch"
    bn_bn158 = "bn/bn158"
    bn_bn190 = "bn/bn190"
    bn_bn222 = "bn/bn222"
    bn_bn254 = "bn/bn254"
    bn_bn286 = "bn/bn286"
    bn_bn318 = "bn/bn318"
    bn_bn350 = "bn/bn350"
    bn_bn382 = "bn/bn382"
    bn_bn414 = "bn/bn414"
    bn_bn446 = "bn/bn446"
    bn_bn478 = "bn/bn478"
    bn_bn510 = "bn/bn510"
    bn_bn542 = "bn/bn542"
    bn_bn574 = "bn/bn574"
    bn_bn606 = "bn/bn606"
    bn_bn638 = "bn/bn638"
    brainpool_brainpool_p160r1 = "brainpool/brainpoolP160r1"
    brainpool_brainpool_p160t1 = "brainpool/brainpoolP160t1"
    brainpool_brainpool_p192r1 = "brainpool/brainpoolP192r1"
    brainpool_brainpool_p192t1 = "brainpool/brainpoolP192t1"
    brainpool_brainpool_p224r1 = "brainpool/brainpoolP224r1"
    brainpool_brainpool_p224t1 = "brainpool/brainpoolP224t1"
    brainpool_brainpool_p256r1 = "brainpool/brainpoolP256r1"
    brainpool_brainpool_p256t1 = "brainpool/brainpoolP256t1"
    brainpool_brainpool_p320r1 = "brainpool/brainpoolP320r1"
    brainpool_brainpool_p320t1 = "brainpool/brainpoolP320t1"
    brainpool_brainpool_p384r1 = "brainpool/brainpoolP384r1"
    brainpool_brainpool_p384t1 = "brainpool/brainpoolP384t1"
    brainpool_brainpool_p512r1 = "brainpool/brainpoolP512r1"
    brainpool_brainpool_p512t1 = "brainpool/brainpoolP512t1"
    gost_gost256 = "gost/gost256"
    gost_gost512 = "gost/gost512"
    gost_id_gost_r3410_2001_crypto_pro_a_param_set = "gost/id-GostR3410-2001-CryptoPro-A-ParamSet"
    gost_id_gost_r3410_2001_crypto_pro_b_param_set = "gost/id-GostR3410-2001-CryptoPro-B-ParamSet"
    gost_id_gost_r3410_2001_crypto_pro_c_param_set = "gost/id-GostR3410-2001-CryptoPro-C-ParamSet"
    gost_id_tc26_gost_3410_12_512_param_set_a = "gost/id-tc26-gost-3410-12-512-paramSetA"
    gost_id_tc26_gost_3410_12_512_param_set_b = "gost/id-tc26-gost-3410-12-512-paramSetB"
    gost_id_tc26_gost_3410_2012_256_param_set_a = "gost/id-tc26-gost-3410-2012-256-paramSetA"
    gost_id_tc26_gost_3410_2012_512_param_set_c = "gost/id-tc26-gost-3410-2012-512-paramSetC"
    mnt_mnt1 = "mnt/mnt1"
    mnt_mnt2_1 = "mnt/mnt2/1"
    mnt_mnt2_2 = "mnt/mnt2/2"
    mnt_mnt3_1 = "mnt/mnt3/1"
    mnt_mnt3_2 = "mnt/mnt3/2"
    mnt_mnt3_3 = "mnt/mnt3/3"
    mnt_mnt4 = "mnt/mnt4"
    mnt_mnt5_1 = "mnt/mnt5/1"
    mnt_mnt5_2 = "mnt/mnt5/2"
    mnt_mnt5_3 = "mnt/mnt5/3"
    nist_b_163 = "nist/B-163"
    nist_b_233 = "nist/B-233"
    nist_b_283 = "nist/B-283"
    nist_b_409 = "nist/B-409"
    nist_b_571 = "nist/B-571"
    nist_k_163 = "nist/K-163"
    nist_k_233 = "nist/K-233"
    nist_k_283 = "nist/K-283"
    nist_k_409 = "nist/K-409"
    nist_k_571 = "nist/K-571"
    nist_p_192 = "nist/P-192"
    nist_p_224 = "nist/P-224"
    nist_p_256 = "nist/P-256"
    nist_p_384 = "nist/P-384"
    nist_p_521 = "nist/P-521"
    nums_ed_254_mont = "nums/ed-254-mont"
    nums_ed_255_mers = "nums/ed-255-mers"
    nums_ed_256_mont = "nums/ed-256-mont"
    nums_ed_382_mont = "nums/ed-382-mont"
    nums_ed_383_mers = "nums/ed-383-mers"
    nums_ed_384_mont = "nums/ed-384-mont"
    nums_ed_510_mont = "nums/ed-510-mont"
    nums_ed_511_mers = "nums/ed-511-mers"
    nums_ed_512_mont = "nums/ed-512-mont"
    nums_numsp256d1 = "nums/numsp256d1"
    nums_numsp256t1 = "nums/numsp256t1"
    nums_numsp384d1 = "nums/numsp384d1"
    nums_numsp384t1 = "nums/numsp384t1"
    nums_numsp512d1 = "nums/numsp512d1"
    nums_numsp512t1 = "nums/numsp512t1"
    nums_w_254_mont = "nums/w-254-mont"
    nums_w_255_mers = "nums/w-255-mers"
    nums_w_256_mont = "nums/w-256-mont"
    nums_w_382_mont = "nums/w-382-mont"
    nums_w_383_mers = "nums/w-383-mers"
    nums_w_384_mont = "nums/w-384-mont"
    nums_w_510_mont = "nums/w-510-mont"
    nums_w_511_mers = "nums/w-511-mers"
    nums_w_512_mont = "nums/w-512-mont"
    oakley_192_bit_random_ecp_group = "oakley/192-bit Random ECP Group"
    oakley_224_bit_random_ecp_group = "oakley/224-bit Random ECP Group"
    oakley_256_bit_random_ecp_group = "oakley/256-bit Random ECP Group"
    oakley_384_bit_random_ecp_group = "oakley/384-bit Random ECP Group"
    oakley_521_bit_random_ecp_group = "oakley/521-bit Random ECP Group"
    oakley_oakley_group_3 = "oakley/Oakley Group 3"
    oakley_oakley_group_4 = "oakley/Oakley Group 4"
    oscaa_sm2 = "oscaa/SM2"
    other_bada55_r_256 = "other/BADA55-R-256"
    other_bada55_vpr_224 = "other/BADA55-VPR-224"
    other_bada55_vpr2_224 = "other/BADA55-VPR2-224"
    other_bada55_vr_224 = "other/BADA55-VR-224"
    other_bada55_vr_256 = "other/BADA55-VR-256"
    other_bada55_vr_384 = "other/BADA55-VR-384"
    other_curve1174 = "other/Curve1174"
    other_curve22103 = "other/Curve22103"
    other_curve25519 = "other/Curve25519"
    other_curve383187 = "other/Curve383187"
    other_curve41417 = "other/Curve41417"
    other_curve4417 = "other/Curve4417"
    other_curve448 = "other/Curve448"
    other_curve67254 = "other/Curve67254"
    other_e_222 = "other/E-222"
    other_e_382 = "other/E-382"
    other_e_521 = "other/E-521"
    other_ed25519 = "other/Ed25519"
    other_ed448 = "other/Ed448"
    other_ed448_goldilocks = "other/Ed448-Goldilocks"
    other_four_q = "other/FourQ"
    other_fp224_bn = "other/Fp224BN"
    other_fp254_b_na = "other/Fp254BNa"
    other_fp254_b_nb = "other/Fp254BNb"
    other_fp254n2_b_na = "other/Fp254n2BNa"
    other_fp256_bn = "other/Fp256BN"
    other_fp384_bn = "other/Fp384BN"
    other_fp512_bn = "other/Fp512BN"
    other_jub_jub = "other/JubJub"
    other_m_221 = "other/M-221"
    other_m_383 = "other/M-383"
    other_m_511 = "other/M-511"
    other_mdc201601 = "other/MDC201601"
    other_pallas = "other/Pallas"
    other_tom_256 = "other/Tom-256"
    other_tom_384 = "other/Tom-384"
    other_tom_521 = "other/Tom-521"
    other_tweedledee = "other/Tweedledee"
    other_tweedledum = "other/Tweedledum"
    other_vesta = "other/Vesta"
    other_ssc_160 = "other/ssc-160"
    other_ssc_192 = "other/ssc-192"
    other_ssc_224 = "other/ssc-224"
    other_ssc_256 = "other/ssc-256"
    other_ssc_288 = "other/ssc-288"
    other_ssc_320 = "other/ssc-320"
    other_ssc_384 = "other/ssc-384"
    other_ssc_512 = "other/ssc-512"
    secg_secp112r1 = "secg/secp112r1"
    secg_secp112r2 = "secg/secp112r2"
    secg_secp128r1 = "secg/secp128r1"
    secg_secp128r2 = "secg/secp128r2"
    secg_secp160k1 = "secg/secp160k1"
    secg_secp160r1 = "secg/secp160r1"
    secg_secp160r2 = "secg/secp160r2"
    secg_secp192k1 = "secg/secp192k1"
    secg_secp192r1 = "secg/secp192r1"
    secg_secp224k1 = "secg/secp224k1"
    secg_secp224r1 = "secg/secp224r1"
    secg_secp256k1 = "secg/secp256k1"
    secg_secp256r1 = "secg/secp256r1"
    secg_secp384r1 = "secg/secp384r1"
    secg_secp521r1 = "secg/secp521r1"
    secg_sect113r1 = "secg/sect113r1"
    secg_sect113r2 = "secg/sect113r2"
    secg_sect131r1 = "secg/sect131r1"
    secg_sect131r2 = "secg/sect131r2"
    secg_sect163k1 = "secg/sect163k1"
    secg_sect163r1 = "secg/sect163r1"
    secg_sect163r2 = "secg/sect163r2"
    secg_sect193r1 = "secg/sect193r1"
    secg_sect193r2 = "secg/sect193r2"
    secg_sect233k1 = "secg/sect233k1"
    secg_sect233r1 = "secg/sect233r1"
    secg_sect239k1 = "secg/sect239k1"
    secg_sect283k1 = "secg/sect283k1"
    secg_sect283r1 = "secg/sect283r1"
    secg_sect409k1 = "secg/sect409k1"
    secg_sect409r1 = "secg/sect409r1"
    secg_sect571k1 = "secg/sect571k1"
    secg_sect571r1 = "secg/sect571r1"
    wtls_wap_wsg_idm_ecid_wtls1 = "wtls/wap-wsg-idm-ecid-wtls1"
    wtls_wap_wsg_idm_ecid_wtls10 = "wtls/wap-wsg-idm-ecid-wtls10"
    wtls_wap_wsg_idm_ecid_wtls11 = "wtls/wap-wsg-idm-ecid-wtls11"
    wtls_wap_wsg_idm_ecid_wtls12 = "wtls/wap-wsg-idm-ecid-wtls12"
    wtls_wap_wsg_idm_ecid_wtls3 = "wtls/wap-wsg-idm-ecid-wtls3"
    wtls_wap_wsg_idm_ecid_wtls4 = "wtls/wap-wsg-idm-ecid-wtls4"
    wtls_wap_wsg_idm_ecid_wtls5 = "wtls/wap-wsg-idm-ecid-wtls5"
    wtls_wap_wsg_idm_ecid_wtls6 = "wtls/wap-wsg-idm-ecid-wtls6"
    wtls_wap_wsg_idm_ecid_wtls7 = "wtls/wap-wsg-idm-ecid-wtls7"
    wtls_wap_wsg_idm_ecid_wtls8 = "wtls/wap-wsg-idm-ecid-wtls8"
    wtls_wap_wsg_idm_ecid_wtls9 = "wtls/wap-wsg-idm-ecid-wtls9"
    x962_c2onb191v4 = "x962/c2onb191v4"
    x962_c2onb191v5 = "x962/c2onb191v5"
    x962_c2onb239v4 = "x962/c2onb239v4"
    x962_c2onb239v5 = "x962/c2onb239v5"
    x962_c2pnb163v1 = "x962/c2pnb163v1"
    x962_c2pnb163v2 = "x962/c2pnb163v2"
    x962_c2pnb163v3 = "x962/c2pnb163v3"
    x962_c2pnb176w1 = "x962/c2pnb176w1"
    x962_c2pnb208w1 = "x962/c2pnb208w1"
    x962_c2pnb272w1 = "x962/c2pnb272w1"
    x962_c2pnb304w1 = "x962/c2pnb304w1"
    x962_c2pnb368w1 = "x962/c2pnb368w1"
    x962_c2tnb191v1 = "x962/c2tnb191v1"
    x962_c2tnb191v2 = "x962/c2tnb191v2"
    x962_c2tnb191v3 = "x962/c2tnb191v3"
    x962_c2tnb239v1 = "x962/c2tnb239v1"
    x962_c2tnb239v2 = "x962/c2tnb239v2"
    x962_c2tnb239v3 = "x962/c2tnb239v3"
    x962_c2tnb359v1 = "x962/c2tnb359v1"
    x962_c2tnb431r1 = "x962/c2tnb431r1"
    x962_prime192v1 = "x962/prime192v1"
    x962_prime192v2 = "x962/prime192v2"
    x962_prime192v3 = "x962/prime192v3"
    x962_prime239v1 = "x962/prime239v1"
    x962_prime239v2 = "x962/prime239v2"
    x962_prime239v3 = "x962/prime239v3"
    x962_prime256v1 = "x962/prime256v1"
    x963_ansip160k1 = "x963/ansip160k1"
    x963_ansip160r1 = "x963/ansip160r1"
    x963_ansip160r2 = "x963/ansip160r2"
    x963_ansip192k1 = "x963/ansip192k1"
    x963_ansip224k1 = "x963/ansip224k1"
    x963_ansip224r1 = "x963/ansip224r1"
    x963_ansip256k1 = "x963/ansip256k1"
    x963_ansip384r1 = "x963/ansip384r1"
    x963_ansip521r1 = "x963/ansip521r1"
    x963_ansit163k1 = "x963/ansit163k1"
    x963_ansit163r1 = "x963/ansit163r1"
    x963_ansit163r2 = "x963/ansit163r2"
    x963_ansit193r1 = "x963/ansit193r1"
    x963_ansit193r2 = "x963/ansit193r2"
    x963_ansit233k1 = "x963/ansit233k1"
    x963_ansit233r1 = "x963/ansit233r1"
    x963_ansit239k1 = "x963/ansit239k1"
    x963_ansit283k1 = "x963/ansit283k1"
    x963_ansit283r1 = "x963/ansit283r1"
    x963_ansit409k1 = "x963/ansit409k1"
    x963_ansit409r1 = "x963/ansit409r1"
    x963_ansit571k1 = "x963/ansit571k1"
    x963_ansit571r1 = "x963/ansit571r1"


class CipherSuite(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[
        str | None,
        Field(
            description="A common name for the cipher suite.",
            examples=["TLS_DHE_RSA_WITH_AES_128_CCM"],
            title="Common Name",
        ),
    ] = None
    algorithms: Annotated[
        list[RefType] | None,
        Field(
            description="A list of algorithms related to the cipher suite.",
            title="Related Algorithms",
        ),
    ] = None
    identifiers: Annotated[
        list[str] | None,
        Field(
            description="A list of common identifiers for the cipher suite.",
            title="Cipher Suite Identifiers",
        ),
    ] = None
    tls_groups: Annotated[
        list[str] | None,
        Field(
            alias="tlsGroups",
            description="A list of TLS named groups (formerly known as curves) for this cipher suite. These groups define the parameters for key exchange algorithms like ECDHE.",
            title="TLS Groups",
        ),
    ] = None
    tls_signature_schemes: Annotated[
        list[str] | None,
        Field(
            alias="tlsSignatureSchemes",
            description="A list of signature schemes supported for cipher suite. These schemes specify the algorithms used for digital signatures in TLS handshakes and certificate verification.",
            title="TLS Signature Schemes",
        ),
    ] = None


class IkeV2Enc(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[
        str | None,
        Field(
            description="A name for the encryption method.",
            examples=["ENCR_AES_GCM_16"],
            title="Name",
        ),
    ] = None
    key_length: Annotated[
        int | None,
        Field(
            alias="keyLength",
            description="The key length of the encryption algorithm.",
            title="Encryption algorithm key length",
        ),
    ] = None
    algorithm: Annotated[
        RefType | None,
        Field(
            description="The bom-ref to algorithm cryptographic asset.",
            title="Algorithm reference",
        ),
    ] = None


class IkeV2Prf(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[
        str | None,
        Field(
            description="A name for the pseudorandom function.",
            examples=["PRF_HMAC_SHA2_256"],
            title="Name",
        ),
    ] = None
    algorithm: Annotated[
        RefType | None,
        Field(
            description="The bom-ref to algorithm cryptographic asset.",
            title="Algorithm reference",
        ),
    ] = None


class IkeV2Integ(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[
        str | None,
        Field(
            description="A name for the integrity algorithm.",
            examples=["AUTH_HMAC_SHA2_256_128"],
            title="Name",
        ),
    ] = None
    algorithm: Annotated[
        RefType | None,
        Field(
            description="The bom-ref to algorithm cryptographic asset.",
            title="Algorithm reference",
        ),
    ] = None


class IkeV2Ke(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    group: Annotated[
        int | None,
        Field(
            description="A group identifier for the key exchange algorithm.",
            title="Group Identifier",
        ),
    ] = None
    algorithm: Annotated[
        RefType | None,
        Field(
            description="The bom-ref to algorithm cryptographic asset.",
            title="Algorithm reference",
        ),
    ] = None


class IkeV2Auth(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[
        str | None,
        Field(description="A name for the authentication method.", title="Name"),
    ] = None
    algorithm: Annotated[
        RefType | None,
        Field(
            description="The bom-ref to algorithm cryptographic asset.",
            title="Algorithm reference",
        ),
    ] = None


class CryptoRefArray(RootModel[list[RefType]]):
    root: Annotated[
        list[RefType],
        Field(
            description="Deprecated definition.",
            title="Encryption Algorithm (ENCR) Reference Array",
        ),
    ]


class RelatedCryptographicAsset(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[
        str | None,
        Field(
            description="Specifies the mechanism by which the cryptographic asset is secured by.",
            examples=["publicKey", "privateKey", "algorithm"],
            title="Type",
        ),
    ] = None
    ref: Annotated[
        RefType | None,
        Field(
            description="The bom-ref to cryptographic asset.",
            title="Reference to cryptographic asset",
        ),
    ] = None


class SecuredBy(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    mechanism: Annotated[
        str | None,
        Field(
            description="Specifies the mechanism by which the cryptographic asset is secured by.",
            examples=["HSM", "TPM", "SGX", "Software", "None"],
            title="Mechanism",
        ),
    ] = None
    algorithm_ref: Annotated[
        RefType | None,
        Field(
            alias="algorithmRef",
            description="The bom-ref to the algorithm.",
            title="Algorithm Reference",
        ),
    ] = None


class Tags(RootModel[list[str]]):
    root: Annotated[
        list[str],
        Field(
            description="Textual strings that aid in discovery, search, and retrieval of the associated object. Tags often serve as a way to group or categorize similar or related objects by various attributes.",
            examples=[
                "json-parser",
                "object-persistence",
                "text-to-image",
                "translation",
                "object-detection",
            ],
            title="Tags",
        ),
    ]


class PatentLegalStatus(Enum):
    pending = "pending"
    granted = "granted"
    revoked = "revoked"
    expired = "expired"
    lapsed = "lapsed"
    withdrawn = "withdrawn"
    abandoned = "abandoned"
    suspended = "suspended"
    reinstated = "reinstated"
    opposed = "opposed"
    terminated = "terminated"
    invalidated = "invalidated"
    in_force = "in-force"


class AssertionType(Enum):
    ownership = "ownership"
    license = "license"
    third_party_claim = "third-party-claim"
    standards_inclusion = "standards-inclusion"
    prior_art = "prior-art"
    exclusive_rights = "exclusive-rights"
    non_assertion = "non-assertion"
    research_or_evaluation = "research-or-evaluation"


class PatentApplicationNumber(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="The unique number assigned to a patent application when it is filed with a patent office. It is used to identify the specific application and track its progress through the examination process. Aligned with `ApplicationNumber` in ST.96. Refer to [ApplicationIdentificationType in ST.96](https://www.wipo.int/standards/XMLSchema/ST96/V8_0/Patent/ApplicationIdentificationType.xsd).",
            examples=["US20240000123", "EP23123456"],
            pattern="^[A-Za-z0-9][A-Za-z0-9\\-/.()\\s]{0,28}[A-Za-z0-9]$",
            title="Patent Application Number",
        ),
    ]


class PatentJurisdiction(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="The jurisdiction or patent office where the priority application was filed, specified using WIPO ST.3 codes. Aligned with `IPOfficeCode` in ST.96. Refer to [IPOfficeCode in ST.96](https://www.wipo.int/standards/XMLSchema/ST96/V8_0/Common/IPOfficeCode.xsd).",
            examples=["US", "EP", "JP"],
            pattern="^[A-Z]{2}$",
            title="Jurisdiction",
        ),
    ]


class PatentFilingDate(RootModel[date]):
    root: Annotated[
        date,
        Field(
            description="The date the priority application was filed, aligned with `FilingDate` in ST.96. Refer to [FilingDate in ST.96](https://www.wipo.int/standards/XMLSchema/ST96/V8_0/Patent/FilingDate.xsd).",
            title="Filing Date",
        ),
    ]


class PriorityApplication(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    application_number: Annotated[PatentApplicationNumber, Field(alias="applicationNumber")]
    jurisdiction: PatentJurisdiction
    filing_date: Annotated[PatentFilingDate, Field(alias="filingDate")]


class Conformance(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    score: Annotated[
        float | None,
        Field(
            description="The conformance of the claim between and inclusive of 0 and 1, where 1 is 100% conformance.",
            ge=0.0,
            le=1.0,
            title="Score",
        ),
    ] = None
    rationale: Annotated[
        str | None,
        Field(description="The rationale for the conformance score.", title="Rationale"),
    ] = None
    mitigation_strategies: Annotated[
        list[RefLinkType] | None,
        Field(
            alias="mitigationStrategies",
            description="The list of  `bom-ref` to the evidence provided describing the mitigation strategies.",
            title="Mitigation Strategies",
        ),
    ] = None


class MapItem(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    requirement: Annotated[
        RefLinkType | None,
        Field(
            description="The `bom-ref` to the requirement being attested to.",
            title="Requirement",
        ),
    ] = None
    claims: Annotated[
        list[RefLinkType] | None,
        Field(
            description="The list of `bom-ref` to the claims being attested to.",
            title="Claims",
        ),
    ] = None
    counter_claims: Annotated[
        list[RefLinkType] | None,
        Field(
            alias="counterClaims",
            description="The list of  `bom-ref` to the counter claims being attested to.",
            title="Counter Claims",
        ),
    ] = None
    conformance: Annotated[
        Conformance | None,
        Field(
            description="The conformance of the claim meeting a requirement.",
            title="Conformance",
        ),
    ] = None
    confidence: Annotated[
        Confidence | None,
        Field(
            description="The confidence of the claim meeting the requirement.",
            title="Confidence",
        ),
    ] = None


class Contents(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    attachment: Annotated[
        Attachment | None,
        Field(
            description="A way to include textual or encoded data.",
            title="Data Attachment",
        ),
    ] = None
    url: Annotated[
        str | None,
        Field(description="The URL to where the data can be retrieved.", title="Data URL"),
    ] = None


class DistributionConstraints(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    tlp: Annotated[
        TlpClassification | None,
        Field(
            description="The Traffic Light Protocol (TLP) classification that controls the sharing and distribution of the data that the BOM describes."
        ),
    ] = "CLEAR"


class OrganizationalEntity(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the object elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ] = None
    name: Annotated[
        str | None,
        Field(
            description="The name of the organization",
            examples=["Example Inc."],
            title="Organization Name",
        ),
    ] = None
    address: Annotated[
        PostalAddress | None,
        Field(
            description="The physical address (location) of the organization",
            title="Organization Address",
        ),
    ] = None
    url: Annotated[
        list[str] | None,
        Field(
            description="The URL of the organization. Multiple URLs are allowed.",
            examples=["https://example.com"],
            title="Organization URL(s)",
        ),
    ] = None
    contact: Annotated[
        list[OrganizationalContact] | None,
        Field(
            description="A contact at the organization. Multiple contacts are allowed.",
            title="Organizational Contact",
        ),
    ] = None


class Swid(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    tag_id: Annotated[
        str,
        Field(
            alias="tagId",
            description="Maps to the tagId of a SoftwareIdentity.",
            title="Tag ID",
        ),
    ]
    name: Annotated[str, Field(description="Maps to the name of a SoftwareIdentity.", title="Name")]
    version: Annotated[
        str | None,
        Field(description="Maps to the version of a SoftwareIdentity.", title="Version"),
    ] = "0.0"
    tag_version: Annotated[
        int | None,
        Field(
            alias="tagVersion",
            description="Maps to the tagVersion of a SoftwareIdentity.",
            title="Tag Version",
        ),
    ] = 0
    patch: Annotated[
        bool | None,
        Field(description="Maps to the patch of a SoftwareIdentity.", title="Patch"),
    ] = False
    text: Annotated[
        Attachment | None,
        Field(
            description="Specifies the metadata and content of the SWID tag.",
            title="Attachment text",
        ),
    ] = None
    url: Annotated[str | None, Field(description="The URL to the SWID file.", title="URL")] = None


class Hash(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    alg: HashAlg
    content: HashContent


class Licensor(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        OrganizationalEntity,
        Field(
            description="The organization that granted the license",
            title="Licensor (Organization)",
        ),
    ]
    individual: Annotated[
        OrganizationalContact | None,
        Field(
            description="The individual, not associated with an organization, that granted the license",
            title="Licensor (Individual)",
        ),
    ] = None


class Licensor1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        OrganizationalEntity | None,
        Field(
            description="The organization that granted the license",
            title="Licensor (Organization)",
        ),
    ] = None
    individual: Annotated[
        OrganizationalContact,
        Field(
            description="The individual, not associated with an organization, that granted the license",
            title="Licensor (Individual)",
        ),
    ]


class Licensee(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        OrganizationalEntity,
        Field(
            description="The organization that was granted the license",
            title="Licensee (Organization)",
        ),
    ]
    individual: Annotated[
        OrganizationalContact | None,
        Field(
            description="The individual, not associated with an organization, that was granted the license",
            title="Licensee (Individual)",
        ),
    ] = None


class Licensee1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        OrganizationalEntity | None,
        Field(
            description="The organization that was granted the license",
            title="Licensee (Organization)",
        ),
    ] = None
    individual: Annotated[
        OrganizationalContact,
        Field(
            description="The individual, not associated with an organization, that was granted the license",
            title="Licensee (Individual)",
        ),
    ]


class Purchaser(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        OrganizationalEntity,
        Field(
            description="The organization that purchased the license",
            title="Purchaser (Organization)",
        ),
    ]
    individual: Annotated[
        OrganizationalContact | None,
        Field(
            description="The individual, not associated with an organization, that purchased the license",
            title="Purchaser (Individual)",
        ),
    ] = None


class Purchaser1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        OrganizationalEntity | None,
        Field(
            description="The organization that purchased the license",
            title="Purchaser (Organization)",
        ),
    ] = None
    individual: Annotated[
        OrganizationalContact,
        Field(
            description="The individual, not associated with an organization, that purchased the license",
            title="Purchaser (Individual)",
        ),
    ]


class Licensing(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    alt_ids: Annotated[
        list[str] | None,
        Field(
            alias="altIds",
            description="License identifiers that may be used to manage licenses and their lifecycle",
            title="Alternate License Identifiers",
        ),
    ] = None
    licensor: Annotated[
        Licensor | Licensor1 | None,
        Field(
            description="The individual or organization that grants a license to another individual or organization",
            title="Licensor",
        ),
    ] = None
    licensee: Annotated[
        Licensee | Licensee1 | None,
        Field(
            description="The individual or organization for which a license was granted to",
            title="Licensee",
        ),
    ] = None
    purchaser: Annotated[
        Purchaser | Purchaser1 | None,
        Field(
            description="The individual or organization that purchased the license",
            title="Purchaser",
        ),
    ] = None
    purchase_order: Annotated[
        str | None,
        Field(
            alias="purchaseOrder",
            description="The purchase order identifier the purchaser sent to a supplier or vendor to authorize a purchase",
            title="Purchase Order",
        ),
    ] = None
    license_types: Annotated[
        list[LicenseType] | None,
        Field(
            alias="licenseTypes",
            description="The type of license(s) that was granted to the licensee.",
            title="License Type",
        ),
    ] = None
    last_renewal: Annotated[
        AwareDatetime | None,
        Field(
            alias="lastRenewal",
            description="The timestamp indicating when the license was last renewed. For new purchases, this is often the purchase or acquisition date. For non-perpetual licenses or subscriptions, this is the timestamp of when the license was last renewed.",
            title="Last Renewal",
        ),
    ] = None
    expiration: Annotated[
        AwareDatetime | None,
        Field(
            description="The timestamp indicating when the current license expires (if applicable).",
            title="Expiration",
        ),
    ] = None


class License1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the license elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ] = None
    id: Annotated[
        spdx.Schema,
        Field(
            description="A valid SPDX license identifier. If specified, this value must be one of the enumeration of valid SPDX license identifiers defined in the spdx.schema.json (or spdx.xml) subschema which is synchronized with the official SPDX license list.",
            examples=["Apache-2.0"],
            title="License ID (SPDX)",
        ),
    ]
    name: Annotated[
        str | None,
        Field(
            description="The name of the license. This may include the name of a commercial or proprietary license or an open source license that may not be defined by SPDX.",
            examples=["Acme Software License"],
            title="License Name",
        ),
    ] = None
    acknowledgement: LicenseAcknowledgementEnumeration | None = None
    text: Annotated[
        Attachment | None,
        Field(
            description="A way to include the textual content of a license.",
            title="License text",
        ),
    ] = None
    url: Annotated[
        str | None,
        Field(
            description="The URL to the license file. If specified, a 'license' externalReference should also be specified for completeness",
            examples=["https://www.apache.org/licenses/LICENSE-2.0.txt"],
            title="License URL",
        ),
    ] = None
    licensing: Licensing | None = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class License2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the license elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ] = None
    id: Annotated[
        spdx.Schema | None,
        Field(
            description="A valid SPDX license identifier. If specified, this value must be one of the enumeration of valid SPDX license identifiers defined in the spdx.schema.json (or spdx.xml) subschema which is synchronized with the official SPDX license list.",
            examples=["Apache-2.0"],
            title="License ID (SPDX)",
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description="The name of the license. This may include the name of a commercial or proprietary license or an open source license that may not be defined by SPDX.",
            examples=["Acme Software License"],
            title="License Name",
        ),
    ]
    acknowledgement: LicenseAcknowledgementEnumeration | None = None
    text: Annotated[
        Attachment | None,
        Field(
            description="A way to include the textual content of a license.",
            title="License text",
        ),
    ] = None
    url: Annotated[
        str | None,
        Field(
            description="The URL to the license file. If specified, a 'license' externalReference should also be specified for completeness",
            examples=["https://www.apache.org/licenses/LICENSE-2.0.txt"],
            title="License URL",
        ),
    ] = None
    licensing: Licensing | None = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class License(RootModel[License1 | License2]):
    root: Annotated[
        License1 | License2,
        Field(
            description="Specifies the details and attributes related to a software license. It can either include a valid SPDX license identifier or a named license, along with additional properties such as license acknowledgment, comprehensive commercial licensing information, and the full text of the license.",
            title="License",
        ),
    ]


class LicenseChoice1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    license: License


class LicenseChoice2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expression: Annotated[
        str,
        Field(
            description="A valid SPDX license expression.\nRefer to https://spdx.org/specifications for syntax requirements.",
            examples=[
                "Apache-2.0 AND (MIT OR GPL-2.0-only)",
                "GPL-3.0-only WITH Classpath-exception-2.0",
            ],
            title="SPDX License Expression",
        ),
    ]
    expression_details: Annotated[
        list[ExpressionDetail] | None,
        Field(
            alias="expressionDetails",
            description="Details for parts of the `expression`.",
            title="Expression Details",
        ),
    ] = None
    acknowledgement: LicenseAcknowledgementEnumeration | None = None
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the license elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ] = None
    licensing: Licensing | None = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class LicenseChoice(RootModel[list[LicenseChoice1 | LicenseChoice2]]):
    root: Annotated[
        list[LicenseChoice1 | LicenseChoice2],
        Field(
            description="A list of SPDX licenses and/or named licenses and/or SPDX License Expression.",
            title="License Choice",
        ),
    ]


class Commit(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    uid: Annotated[
        str | None,
        Field(
            description="A unique identifier of the commit. This may be version control specific. For example, Subversion uses revision numbers whereas git uses commit hashes.",
            title="UID",
        ),
    ] = None
    url: Annotated[
        str | None,
        Field(
            description="The URL to the commit. This URL will typically point to a commit in a version control system.",
            title="URL",
        ),
    ] = None
    author: Annotated[
        IdentifiableAction | None,
        Field(
            description="The author who created the changes in the commit",
            title="Author",
        ),
    ] = None
    committer: Annotated[
        IdentifiableAction | None,
        Field(
            description="The person who committed or pushed the commit",
            title="Committer",
        ),
    ] = None
    message: Annotated[
        str | None,
        Field(
            description="The text description of the contents of the commit",
            title="Message",
        ),
    ] = None


class Patch(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[
        Type1,
        Field(
            description="Specifies the purpose for the patch including the resolution of defects, security issues, or new behavior or functionality.",
            title="Patch Type",
        ),
    ]
    diff: Annotated[
        Diff | None,
        Field(
            description="The patch file (or diff) that shows changes. Refer to [https://en.wikipedia.org/wiki/Diff](https://en.wikipedia.org/wiki/Diff)",
            title="Diff",
        ),
    ] = None
    resolves: Annotated[
        list[Issue] | None,
        Field(description="A collection of issues the patch resolves", title="Resolves"),
    ] = None


class ExternalReference(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    url: Annotated[
        str | BomLink,
        Field(
            description="The URI (URL or URN) to the external reference. External references are URIs and therefore can accept any URL scheme including https ([RFC-7230](https://www.ietf.org/rfc/rfc7230.txt)), mailto ([RFC-2368](https://www.ietf.org/rfc/rfc2368.txt)), tel ([RFC-3966](https://www.ietf.org/rfc/rfc3966.txt)), and dns ([RFC-4501](https://www.ietf.org/rfc/rfc4501.txt)). External references may also include formally registered URNs such as [CycloneDX BOM-Link](https://cyclonedx.org/capabilities/bomlink/) to reference CycloneDX BOMs or any object within a BOM. BOM-Link transforms applicable external references into relationships that can be expressed in a BOM or across BOMs.",
            title="URL",
        ),
    ]
    comment: Annotated[
        str | None,
        Field(description="A comment describing the external reference", title="Comment"),
    ] = None
    type: Annotated[
        Type3,
        Field(description="Specifies the type of external reference.", title="Type"),
    ]
    hashes: Annotated[
        list[Hash] | None,
        Field(
            description="The hashes of the external reference (if applicable).",
            title="Hashes",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class ComponentEvidence(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    identity: Annotated[
        list[ComponentIdentityEvidence] | ComponentIdentityEvidence | None,
        Field(
            description="Evidence that substantiates the identity of a component. The identity may be an object or an array of identity objects. Support for specifying identity as a single object was introduced in CycloneDX v1.5. Arrays were introduced in v1.6. It is recommended that all implementations use arrays, even if only one identity object is specified.",
            title="Identity Evidence",
        ),
    ] = None
    occurrences: Annotated[
        list[Occurrence] | None,
        Field(
            description="Evidence of individual instances of a component spread across multiple locations.",
            title="Occurrences",
        ),
    ] = None
    callstack: Annotated[
        Callstack | None,
        Field(
            description="Evidence of the components use through the callstack.",
            title="Call Stack",
        ),
    ] = None
    licenses: Annotated[LicenseChoice | None, Field(title="License Evidence")] = None
    copyright: Annotated[
        list[Copyright] | None,
        Field(
            description="Copyright evidence captures intellectual property assertions, providing evidence of possible ownership and legal protection.",
            title="Copyright Evidence",
        ),
    ] = None


class ReleaseNotes(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[
        ReleaseType,
        Field(
            description="The software versioning type the release note describes.",
            title="Type",
        ),
    ]
    title: Annotated[str | None, Field(description="The title of the release.", title="Title")] = None
    featured_image: Annotated[
        str | None,
        Field(
            alias="featuredImage",
            description="The URL to an image that may be prominently displayed with the release note.",
            title="Featured image",
        ),
    ] = None
    social_image: Annotated[
        str | None,
        Field(
            alias="socialImage",
            description="The URL to an image that may be used in messaging on social media platforms.",
            title="Social image",
        ),
    ] = None
    description: Annotated[
        str | None,
        Field(description="A short description of the release.", title="Description"),
    ] = None
    timestamp: Annotated[
        AwareDatetime | None,
        Field(
            description="The date and time (timestamp) when the release note was created.",
            title="Timestamp",
        ),
    ] = None
    aliases: Annotated[
        list[str] | None,
        Field(
            description="One or more alternate names the release may be referred to. This may include unofficial terms used by development and marketing teams (e.g. code names).",
            title="Aliases",
        ),
    ] = None
    tags: Annotated[Tags | None, Field(title="Tags")] = None
    resolves: Annotated[
        list[Issue] | None,
        Field(
            description="A collection of issues that have been resolved.",
            title="Resolves",
        ),
    ] = None
    notes: Annotated[
        list[Note] | None,
        Field(
            description="Zero or more release notes containing the locale and content. Multiple note objects may be specified to support release notes in a wide variety of languages.",
            title="Notes",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class Rating(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    source: Annotated[
        VulnerabilitySource | None,
        Field(description="The source that calculated the severity or risk rating of the vulnerability."),
    ] = None
    score: Annotated[
        float | None,
        Field(description="The numerical score of the rating.", title="Score"),
    ] = None
    severity: Annotated[
        Severity | None,
        Field(
            description="Textual representation of the severity that corresponds to the numerical score of the rating."
        ),
    ] = None
    method: ScoreMethod | None = None
    vector: Annotated[
        str | None,
        Field(
            description="Textual representation of the metric values used to score the vulnerability",
            title="Vector",
        ),
    ] = None
    justification: Annotated[
        str | None,
        Field(
            description="A reason for rating the vulnerability as it was",
            title="Justification",
        ),
    ] = None


class Credits(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    organizations: Annotated[
        list[OrganizationalEntity] | None,
        Field(
            description="The organizations credited with vulnerability discovery.",
            title="Organizations",
        ),
    ] = None
    individuals: Annotated[
        list[OrganizationalContact] | None,
        Field(
            description="The individuals, not associated with organizations, that are credited with vulnerability discovery.",
            title="Individuals",
        ),
    ] = None


class Versions(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    version: Annotated[
        Version,
        Field(description="A single version of a component or service.", title="Version"),
    ]
    range: Annotated[
        VersionRange | None,
        Field(
            description="A version range specified in Package URL Version Range syntax (vers) which is defined at https://github.com/package-url/vers-spec",
            title="Version Range",
        ),
    ] = None
    status: Annotated[
        AffectedStatus | None,
        Field(
            description="The vulnerability status for the version or range of versions.",
            title="Status",
        ),
    ] = "affected"


class Versions1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    version: Annotated[
        Version | None,
        Field(description="A single version of a component or service.", title="Version"),
    ] = None
    range: Annotated[
        VersionRange,
        Field(
            description="A version range specified in Package URL Version Range syntax (vers) which is defined at https://github.com/package-url/vers-spec",
            title="Version Range",
        ),
    ]
    status: Annotated[
        AffectedStatus | None,
        Field(
            description="The vulnerability status for the version or range of versions.",
            title="Status",
        ),
    ] = "affected"


class Affect(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    ref: Annotated[
        RefLinkType | BomLinkElementType,
        Field(
            description="References a component or service by the objects bom-ref",
            title="Reference",
        ),
    ]
    versions: Annotated[
        list[Versions | Versions1] | None,
        Field(
            description="Zero or more individual versions or range of versions.",
            title="Versions",
        ),
    ] = None


class DataGovernanceResponsibleParty1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        OrganizationalEntity,
        Field(
            description="The organization that is responsible for specific data governance role(s).",
            title="Organization",
        ),
    ]
    contact: Annotated[
        OrganizationalContact | None,
        Field(
            description="The individual that is responsible for specific data governance role(s).",
            title="Individual",
        ),
    ] = None


class DataGovernanceResponsibleParty2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        OrganizationalEntity | None,
        Field(
            description="The organization that is responsible for specific data governance role(s).",
            title="Organization",
        ),
    ] = None
    contact: Annotated[
        OrganizationalContact,
        Field(
            description="The individual that is responsible for specific data governance role(s).",
            title="Individual",
        ),
    ]


class DataGovernanceResponsibleParty(RootModel[DataGovernanceResponsibleParty1 | DataGovernanceResponsibleParty2]):
    root: DataGovernanceResponsibleParty1 | DataGovernanceResponsibleParty2


class GraphicsCollection(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    description: Annotated[
        str | None,
        Field(
            description="A description of this collection of graphics.",
            title="Description",
        ),
    ] = None
    collection: Annotated[
        list[Graphic] | None,
        Field(description="A collection of graphics.", title="Collection"),
    ] = None


class EnergyProvider(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the energy provider elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ] = None
    description: Annotated[
        str | None,
        Field(description="A description of the energy provider.", title="Description"),
    ] = None
    organization: Annotated[
        OrganizationalEntity,
        Field(description="The organization that provides energy.", title="Organization"),
    ]
    energy_source: Annotated[
        EnergySource,
        Field(
            alias="energySource",
            description="The energy source for the energy provider.",
            title="Energy Source",
        ),
    ]
    energy_provided: Annotated[
        EnergyMeasure,
        Field(
            alias="energyProvided",
            description="The energy provided by the energy source for an associated activity.",
            title="Energy Provided",
        ),
    ]
    external_references: Annotated[
        list[ExternalReference] | None,
        Field(
            alias="externalReferences",
            description="External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.",
            title="External References",
        ),
    ] = None


class Step(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[str | None, Field(description="A name for the step.", title="Name")] = None
    description: Annotated[str | None, Field(description="A description of the step.", title="Description")] = None
    commands: Annotated[
        list[Command] | None,
        Field(
            description="Ordered list of commands or directives for the step",
            title="Commands",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class ResourceReferenceChoice1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    ref: Annotated[
        RefLinkType | BomLinkElementType,
        Field(
            description="References an object by its bom-ref attribute",
            title="BOM Reference",
        ),
    ]
    external_reference: Annotated[
        ExternalReference | None,
        Field(
            alias="externalReference",
            description="Reference to an externally accessible resource.",
            title="External reference",
        ),
    ] = None


class ResourceReferenceChoice2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    ref: Annotated[
        RefLinkType | BomLinkElementType | None,
        Field(
            description="References an object by its bom-ref attribute",
            title="BOM Reference",
        ),
    ] = None
    external_reference: Annotated[
        ExternalReference,
        Field(
            alias="externalReference",
            description="Reference to an externally accessible resource.",
            title="External reference",
        ),
    ]


class ResourceReferenceChoice(RootModel[ResourceReferenceChoice1 | ResourceReferenceChoice2]):
    root: Annotated[
        ResourceReferenceChoice1 | ResourceReferenceChoice2,
        Field(
            description="A reference to a locally defined resource (e.g., a bom-ref) or an externally accessible resource.",
            title="Resource reference choice",
        ),
    ]


class Requirement(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the object elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    identifier: Annotated[
        str | None,
        Field(
            description="The unique identifier used in the standard to identify a specific requirement. This should match what is in the standard and should not be the requirements bom-ref.",
            title="Identifier",
        ),
    ] = None
    title: Annotated[str | None, Field(description="The title of the requirement.", title="Title")] = None
    text: Annotated[
        str | None,
        Field(description="The textual content of the requirement.", title="Text"),
    ] = None
    descriptions: Annotated[
        list[str] | None,
        Field(
            description="The supplemental text that provides additional guidance or context to the requirement, but is not directly part of the requirement.",
            title="Descriptions",
        ),
    ] = None
    open_cre: Annotated[
        list[OpenCreItem] | None,
        Field(
            alias="openCre",
            description="The Common Requirements Enumeration (CRE) identifier(s). CRE is a structured and standardized framework for uniting security standards and guidelines. CRE links each section of a resource to a shared topic identifier (a Common Requirement). Through this shared topic link, all resources map to each other. Use of CRE promotes clear and unambiguous communication among stakeholders.",
            title="OWASP OpenCRE Identifier(s)",
        ),
    ] = None
    parent: Annotated[
        RefLinkType | None,
        Field(
            description="The `bom-ref` to a parent requirement. This establishes a hierarchy of requirements. Top-level requirements must not define a parent. Only child requirements should define parents.",
            title="Parent BOM Reference",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None
    external_references: Annotated[
        list[ExternalReference] | None,
        Field(
            alias="externalReferences",
            description="External references provide a way to document systems, sites, and information that may be relevant, but are not included with the BOM. They may also establish specific relationships within or external to the BOM.",
            title="External References",
        ),
    ] = None


class Signer(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    algorithm: Algorithm | AnyUrl
    key_id: Annotated[
        str | None,
        Field(
            alias="keyId",
            description="Optional. Application specific string identifying the signature key.",
            title="Key ID",
        ),
    ] = None
    public_key: Annotated[
        PublicKey | None,
        Field(
            alias="publicKey",
            description="Optional. Public key object.",
            title="Public key",
        ),
    ] = None
    certificate_path: Annotated[
        list[str] | None,
        Field(
            alias="certificatePath",
            description="Optional. Sorted array of X.509 [RFC5280] certificates, where the first element must contain the signature certificate. The certificate path must be contiguous but is not required to be complete.",
            title="Certificate path",
        ),
    ] = None
    excludes: Annotated[
        list[str] | None,
        Field(
            description='Optional. Array holding the names of one or more application level properties that must be excluded from the signature process. Note that the "excludes" property itself, must also be excluded from the signature process. Since both the "excludes" property and the associated data it points to are unsigned, a conforming JSF implementation must provide options for specifying which properties to accept.',
            title="Excludes",
        ),
    ] = None
    value: Annotated[
        str,
        Field(
            description="The signature data. Note that the binary representation must follow the JWA [RFC7518] specifications.",
            title="Signature",
        ),
    ]


class AlgorithmProperties(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    primitive: Annotated[
        Primitive | None,
        Field(
            description="Cryptographic building blocks used in higher-level cryptographic systems and protocols. Primitives represent different cryptographic routines: deterministic random bit generators (drbg, e.g. CTR_DRBG from NIST SP800-90A-r1), message authentication codes (mac, e.g. HMAC-SHA-256), blockciphers (e.g. AES), streamciphers (e.g. Salsa20), signatures (e.g. ECDSA), hash functions (e.g. SHA-256), public-key encryption schemes (pke, e.g. RSA), extended output functions (xof, e.g. SHAKE256), key derivation functions (e.g. pbkdf2), key agreement algorithms (e.g. ECDH), key encapsulation mechanisms (e.g. ML-KEM), authenticated encryption (ae, e.g. AES-GCM) and the combination of multiple algorithms (combiner, e.g. SP800-56Cr2).",
            title="primitive",
        ),
    ] = None
    algorithm_family: Annotated[
        AlgorithmFamiliesEnum | None,
        Field(
            alias="algorithmFamily",
            description="A valid algorithm family identifier. If specified, this value must be one of the enumeration of valid algorithm Family identifiers defined in the `cryptography-defs.schema.json` subschema.",
            examples=["3DES", "Blowfish", "ECDH"],
            title="Algorithm Family",
        ),
    ] = None
    parameter_set_identifier: Annotated[
        str | None,
        Field(
            alias="parameterSetIdentifier",
            description="An identifier for the parameter set of the cryptographic algorithm. Examples: in AES128, '128' identifies the key length in bits, in SHA256, '256' identifies the digest length, '128' in SHAKE128 identifies its maximum security level in bits, and 'SHA2-128s' identifies a parameter set used in SLH-DSA (FIPS205).",
            title="Parameter Set Identifier",
        ),
    ] = None
    curve: Annotated[
        str | None,
        Field(
            description="[Deprecated] This will be removed in a future version. Use `@.ellipticCurve` instead.\nThe specific underlying Elliptic Curve (EC) definition employed which is an indicator of the level of security strength, performance and complexity. Absent an authoritative source of curve names, CycloneDX recommends using curve names as defined at [https://neuromancer.sk/std/](https://neuromancer.sk/std/), the source of which can be found at [https://github.com/J08nY/std-curves](https://github.com/J08nY/std-curves).",
            title="Elliptic Curve",
        ),
    ] = None
    elliptic_curve: Annotated[
        EllipticCurvesEnum | None,
        Field(
            alias="ellipticCurve",
            description="The specific underlying Elliptic Curve (EC) definition employed which is an indicator of the level of security strength, performance and complexity. If specified, this value must be one of the enumeration of valid elliptic curves identifiers defined in the `cryptography-defs.schema.json` subschema.",
            title="Elliptic Curve",
        ),
    ] = None
    execution_environment: Annotated[
        ExecutionEnvironment | None,
        Field(
            alias="executionEnvironment",
            description="The target and execution environment in which the algorithm is implemented in.",
            title="Execution Environment",
        ),
    ] = None
    implementation_platform: Annotated[
        ImplementationPlatform | None,
        Field(
            alias="implementationPlatform",
            description="The target platform for which the algorithm is implemented. The implementation can be 'generic', running on any platform or for a specific platform.",
            title="Implementation platform",
        ),
    ] = None
    certification_level: Annotated[
        list[CertificationLevelEnum] | None,
        Field(
            alias="certificationLevel",
            description="The certification that the implementation of the cryptographic algorithm has received, if any. Certifications include revisions and levels of FIPS 140 or Common Criteria of different Extended Assurance Levels (CC-EAL).",
            title="Certification Level",
        ),
    ] = None
    mode: Annotated[
        Mode1 | None,
        Field(
            description="The mode of operation in which the cryptographic algorithm (block cipher) is used.",
            title="Mode",
        ),
    ] = None
    padding: Annotated[
        Padding | None,
        Field(
            description="The padding scheme that is used for the cryptographic algorithm.",
            title="Padding",
        ),
    ] = None
    crypto_functions: Annotated[
        list[CryptoFunction] | None,
        Field(
            alias="cryptoFunctions",
            description="The cryptographic functions implemented by the cryptographic algorithm.",
            title="Cryptographic functions",
        ),
    ] = None
    classical_security_level: Annotated[
        int | None,
        Field(
            alias="classicalSecurityLevel",
            description="The classical security level that a cryptographic algorithm provides (in bits).",
            ge=0,
            title="classical security level",
        ),
    ] = None
    nist_quantum_security_level: Annotated[
        int | None,
        Field(
            alias="nistQuantumSecurityLevel",
            description="The NIST security strength category as defined in https://csrc.nist.gov/projects/post-quantum-cryptography/post-quantum-cryptography-standardization/evaluation-criteria/security-(evaluation-criteria). A value of 0 indicates that none of the categories are met.",
            ge=0,
            le=6,
            title="NIST security strength category",
        ),
    ] = None


class Ikev2TransformTypes(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    encr: Annotated[
        list[IkeV2Enc] | CryptoRefArray | None,
        Field(
            description="Transform Type 1: encryption algorithms",
            title="Encryption Algorithms (ENCR)",
        ),
    ] = None
    prf: Annotated[
        list[IkeV2Prf] | CryptoRefArray | None,
        Field(
            description="Transform Type 2: pseudorandom functions",
            title="Pseudorandom Functions (PRF)",
        ),
    ] = None
    integ: Annotated[
        list[IkeV2Integ] | CryptoRefArray | None,
        Field(
            description="Transform Type 3: integrity algorithms",
            title="Integrity Algorithms (INTEG)",
        ),
    ] = None
    ke: Annotated[
        list[IkeV2Ke] | CryptoRefArray | None,
        Field(
            description="Transform Type 4: Key Exchange Method (KE) per [RFC 9370](https://www.ietf.org/rfc/rfc9370.html), formerly called Diffie-Hellman Group (D-H).",
            title="Key Exchange Methods (KE)",
        ),
    ] = None
    esn: Annotated[
        bool | None,
        Field(
            description="Specifies if an Extended Sequence Number (ESN) is used.",
            title="Extended Sequence Number (ESN)",
        ),
    ] = None
    auth: Annotated[
        list[IkeV2Auth] | CryptoRefArray | None,
        Field(
            description="IKEv2 Authentication method per [RFC9593](https://www.ietf.org/rfc/rfc9593.html).",
            title="IKEv2 Authentication methods",
        ),
    ] = None


class RelatedCryptographicAssets(RootModel[list[RelatedCryptographicAsset]]):
    root: Annotated[
        list[RelatedCryptographicAsset],
        Field(
            description="A list of cryptographic assets related to this component.",
            title="Related Cryptographic Assets",
        ),
    ]


class PatentFamily(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the object elsewhere in the BOM. Every `bom-ref` must be unique within the BOM. \n\nFor a patent, it might be a good idea to use a patent number as the BOM reference ID.",
            title="BOM Reference",
        ),
    ] = None
    family_id: Annotated[
        str,
        Field(
            alias="familyId",
            description="The unique identifier for the patent family, aligned with the `id` attribute in WIPO ST.96 v8.0's `PatentFamilyType`. Refer to [PatentFamilyType in ST.96](https://www.wipo.int/standards/XMLSchema/ST96/V8_0/Patent/PatentFamilyType.xsd).",
            title="Patent Family ID",
        ),
    ]
    priority_application: Annotated[PriorityApplication | None, Field(alias="priorityApplication")] = None
    members: Annotated[
        list[RefLinkType] | None,
        Field(
            description="A collection of patents or applications that belong to this family, each identified by a `bom-ref` pointing to a patent object defined elsewhere in the BOM.",
            title="Family Members",
        ),
    ] = None
    external_references: Annotated[
        list[ExternalReference] | None,
        Field(
            alias="externalReferences",
            description="External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.",
            title="External References",
        ),
    ] = None


class Patent(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the object elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    patent_number: Annotated[
        str,
        Field(
            alias="patentNumber",
            description="The unique number assigned to the granted patent by the issuing authority. Aligned with `PatentNumber` in WIPO ST.96. Refer to [PatentNumber in ST.96](https://www.wipo.int/standards/XMLSchema/ST96/V8_0/Patent/PatentNumber.xsd).",
            examples=["US987654321", "EP1234567B1"],
            pattern="^[A-Za-z0-9][A-Za-z0-9\\-/.()\\s]{0,28}[A-Za-z0-9]$",
            title="Patent Number",
        ),
    ]
    application_number: Annotated[PatentApplicationNumber | None, Field(alias="applicationNumber")] = None
    jurisdiction: PatentJurisdiction
    priority_application: Annotated[PriorityApplication | None, Field(alias="priorityApplication")] = None
    publication_number: Annotated[
        str | None,
        Field(
            alias="publicationNumber",
            description="This is the number assigned to a patent application once it is published. Patent applications are generally published 18 months after filing (unless an applicant requests non-publication). This number is distinct from the application number. \n\nPurpose: Identifies the publicly available version of the application. \n\nFormat: Varies by jurisdiction, often similar to application numbers but includes an additional suffix indicating publication. \n\nExample:\n - US: US20240000123A1 (indicates the first publication of application US20240000123) \n - Europe: EP23123456A1 (first publication of European application EP23123456). \n\nWIPO ST.96 v8.0: \n - Publication Number field: https://www.wipo.int/standards/XMLSchema/ST96/V8_0/Patent/PublicationNumber.xsd",
            pattern="^[A-Za-z0-9][A-Za-z0-9\\-/.()\\s]{0,28}[A-Za-z0-9]$",
            title="Patent Publication Number",
        ),
    ] = None
    title: Annotated[
        str | None,
        Field(
            description="The title of the patent, summarising the invention it protects. Aligned with `InventionTitle` in WIPO ST.96. Refer to [InventionTitle in ST.96](https://www.wipo.int/standards/XMLSchema/ST96/V8_0/Patent/InventionTitle.xsd).",
            title="Patent Title",
        ),
    ] = None
    abstract: Annotated[
        str | None,
        Field(
            description="A brief summary of the invention described in the patent. Aligned with `Abstract` and `P` in WIPO ST.96. Refer to [Abstract in ST.96](https://www.wipo.int/standards/XMLSchema/ST96/V8_0/Patent/Abstract.xsd).",
            title="Patent Abstract",
        ),
    ] = None
    filing_date: Annotated[
        date | None,
        Field(
            alias="filingDate",
            description="The date the patent application was filed with the jurisdiction. Aligned with `FilingDate` in WIPO ST.96. Refer to [FilingDate in ST.96](https://www.wipo.int/standards/XMLSchema/ST96/V8_0/Patent/FilingDate.xsd).",
            title="Filing Date",
        ),
    ] = None
    grant_date: Annotated[
        date | None,
        Field(
            alias="grantDate",
            description="The date the patent was granted by the jurisdiction. Aligned with `GrantDate` in WIPO ST.96. Refer to [GrantDate in ST.96](https://www.wipo.int/standards/XMLSchema/ST96/V8_0/Patent/GrantDate.xsd).",
            title="Grant Date",
        ),
    ] = None
    patent_expiration_date: Annotated[
        date | None,
        Field(
            alias="patentExpirationDate",
            description="The date the patent expires. Derived from grant or filing date according to jurisdiction-specific rules.",
            title="Expiration Date",
        ),
    ] = None
    patent_legal_status: Annotated[
        PatentLegalStatus,
        Field(
            alias="patentLegalStatus",
            description="Indicates the current legal status of the patent or patent application, based on the WIPO ST.27 standard. This status reflects administrative, procedural, or legal events. Values include both active and inactive states and are useful for determining enforceability, procedural history, and maintenance status.",
            title="Legal Status",
        ),
    ]
    patent_assignee: Annotated[
        list[OrganizationalContact | OrganizationalEntity] | None,
        Field(
            alias="patentAssignee",
            description="A collection of organisations or individuals to whom the patent rights are assigned. This supports joint ownership and allows for flexible representation of both corporate entities and individual inventors.",
            title="Patent Assignees",
        ),
    ] = None
    external_references: Annotated[
        list[ExternalReference] | None,
        Field(
            alias="externalReferences",
            description="External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.",
            title="External References",
        ),
    ] = None


class PatentAssertion(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="A reference to the patent or patent family object within the BOM. This must match the `bom-ref` of a `patent` or `patentFamily` object.",
            title="BOM Reference",
        ),
    ] = None
    assertion_type: Annotated[
        AssertionType,
        Field(
            alias="assertionType",
            description="The type of assertion being made about the patent or patent family. Examples include ownership, licensing, and standards inclusion.",
            title="Assertion Type",
        ),
    ]
    patent_refs: Annotated[
        list[RefType] | None,
        Field(
            alias="patentRefs",
            description="A list of BOM references (`bom-ref`) linking to patents or patent families associated with this assertion.",
            title="Patent References",
        ),
    ] = None
    asserter: OrganizationalEntity | OrganizationalContact | RefLinkType
    notes: Annotated[
        str | None,
        Field(
            description="Additional notes or clarifications regarding the assertion, if necessary. For example, geographical restrictions, duration, or limitations of a license.",
            title="Notes",
        ),
    ] = None


class PatentAssertions(RootModel[list[PatentAssertion]]):
    root: Annotated[
        list[PatentAssertion],
        Field(
            description="A list of assertions made regarding patents associated with this component or service. Assertions distinguish between ownership, licensing, and other relevant interactions with patents.",
            title="Patent Assertions",
        ),
    ]


class Assessor(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the object elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    third_party: Annotated[
        bool | None,
        Field(
            alias="thirdParty",
            description="The boolean indicating if the assessor is outside the organization generating claims. A value of false indicates a self assessor.",
            title="Third Party",
        ),
    ] = None
    organization: Annotated[
        OrganizationalEntity | None,
        Field(description="The entity issuing the assessment.", title="Organization"),
    ] = None


class Tool(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    vendor: Annotated[
        str | None,
        Field(
            description="The name of the vendor who created the tool",
            title="Tool Vendor",
        ),
    ] = None
    name: Annotated[str | None, Field(description="The name of the tool", title="Tool Name")] = None
    version: Annotated[
        Version | None,
        Field(description="The version of the tool", title="Tool Version"),
    ] = None
    hashes: Annotated[
        list[Hash] | None,
        Field(description="The hashes of the tool (if applicable).", title="Hashes"),
    ] = None
    external_references: Annotated[
        list[ExternalReference] | None,
        Field(
            alias="externalReferences",
            description="External references provide a way to document systems, sites, and information that may be relevant, but are not included with the BOM. They may also establish specific relationships within or external to the BOM.",
            title="External References",
        ),
    ] = None


class QuantitativeAnalysis(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    performance_metrics: Annotated[
        list[PerformanceMetric] | None,
        Field(
            alias="performanceMetrics",
            description="The model performance metrics being reported. Examples may include accuracy, F1 score, precision, top-3 error rates, MSC, etc.",
            title="Performance Metrics",
        ),
    ] = None
    graphics: GraphicsCollection | None = None


class DataGovernance(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    custodians: Annotated[
        list[DataGovernanceResponsibleParty] | None,
        Field(
            description="Data custodians are responsible for the safe custody, transport, and storage of data.",
            title="Data Custodians",
        ),
    ] = None
    stewards: Annotated[
        list[DataGovernanceResponsibleParty] | None,
        Field(
            description="Data stewards are responsible for data content, context, and associated business rules.",
            title="Data Stewards",
        ),
    ] = None
    owners: Annotated[
        list[DataGovernanceResponsibleParty] | None,
        Field(
            description="Data owners are concerned with risk and appropriate access to data.",
            title="Data Owners",
        ),
    ] = None


class EnergyConsumption(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    activity: Annotated[
        Activity,
        Field(
            description="The type of activity that is part of a machine learning model development or operational lifecycle.",
            title="Activity",
        ),
    ]
    energy_providers: Annotated[
        list[EnergyProvider],
        Field(
            alias="energyProviders",
            description="The provider(s) of the energy consumed by the associated model development lifecycle activity.",
            title="Energy Providers",
        ),
    ]
    activity_energy_cost: Annotated[
        EnergyMeasure,
        Field(
            alias="activityEnergyCost",
            description="The total energy cost associated with the model lifecycle activity.",
            title="Activity Energy Cost",
        ),
    ]
    co2_cost_equivalent: Annotated[
        Co2Measure | None,
        Field(
            alias="co2CostEquivalent",
            description="The CO2 cost (debit) equivalent to the total energy cost.",
            title="CO2 Equivalent Cost",
        ),
    ] = None
    co2_cost_offset: Annotated[
        Co2Measure | None,
        Field(
            alias="co2CostOffset",
            description="The CO2 offset (credit) for the CO2 equivalent cost.",
            title="CO2 Cost Offset",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class Workspace(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the workspace elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ]
    uid: Annotated[
        str,
        Field(
            description="The unique identifier for the resource instance within its deployment context.",
            title="Unique Identifier (UID)",
        ),
    ]
    name: Annotated[
        str | None,
        Field(description="The name of the resource instance.", title="Name"),
    ] = None
    aliases: Annotated[
        list[str] | None,
        Field(
            description="The names for the workspace as referenced by other workflow tasks. Effectively, a name mapping so other tasks can use their own local name in their steps.",
            title="Aliases",
        ),
    ] = None
    description: Annotated[
        str | None,
        Field(description="A description of the resource instance.", title="Description"),
    ] = None
    resource_references: Annotated[
        list[ResourceReferenceChoice] | None,
        Field(
            alias="resourceReferences",
            description="References to component or service resources that are used to realize the resource instance.",
            title="Resource references",
        ),
    ] = None
    access_mode: Annotated[
        AccessMode | None,
        Field(
            alias="accessMode",
            description="Describes the read-write access control for the workspace relative to the owning resource instance.",
            title="Access mode",
        ),
    ] = None
    mount_path: Annotated[
        str | None,
        Field(
            alias="mountPath",
            description="A path to a location on disk where the workspace will be available to the associated task's steps.",
            title="Mount path",
        ),
    ] = None
    managed_data_type: Annotated[
        str | None,
        Field(
            alias="managedDataType",
            description="The name of a domain-specific data type the workspace represents.",
            examples=["ConfigMap", "Secret"],
            title="Managed data type",
        ),
    ] = None
    volume_request: Annotated[
        str | None,
        Field(
            alias="volumeRequest",
            description="Identifies the reference to the request for a specific volume type and parameters.",
            examples=["a kubernetes Persistent Volume Claim (PVC) name"],
            title="Volume request",
        ),
    ] = None
    volume: Annotated[
        Volume | None,
        Field(
            description="Information about the actual volume instance allocated to the workspace.",
            examples=["see https://kubernetes.io/docs/concepts/storage/persistent-volumes/"],
            title="Volume",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class Event(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    uid: Annotated[
        str | None,
        Field(
            description="The unique identifier of the event.",
            title="Unique Identifier (UID)",
        ),
    ] = None
    description: Annotated[
        str | None,
        Field(description="A description of the event.", title="Description"),
    ] = None
    time_received: Annotated[
        AwareDatetime | None,
        Field(
            alias="timeReceived",
            description="The date and time (timestamp) when the event was received.",
            title="Time Received",
        ),
    ] = None
    data: Annotated[
        Attachment | None,
        Field(description="Encoding of the raw event data.", title="Data"),
    ] = None
    source: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="References the component or service that was the source of the event",
            title="Source",
        ),
    ] = None
    target: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="References the component or service that was the target of the event",
            title="Target",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class InputType1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    source: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="A reference to the component or service that provided the input to the task (e.g., reference to a service with data flow value of `inbound`)",
            examples=["source code repository", "database"],
            title="Source",
        ),
    ] = None
    target: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="A reference to the component or service that received or stored the input if not the task itself (e.g., a local, named storage workspace)",
            examples=["workspace", "directory"],
            title="Target",
        ),
    ] = None
    resource: Annotated[
        ResourceReferenceChoice,
        Field(
            description="A reference to an independent resource provided as an input to a task by the workflow runtime.",
            examples=[
                "a reference to a configuration file in a repository (i.e., a bom-ref)",
                "a reference to a scanning service used in a task (i.e., a bom-ref)",
            ],
            title="Resource",
        ),
    ]
    parameters: Annotated[
        list[Parameter] | None,
        Field(
            description="Inputs that have the form of parameters with names and values.",
            title="Parameters",
        ),
    ] = None
    environment_vars: Annotated[
        list[Property | str] | None,
        Field(
            alias="environmentVars",
            description="Inputs that have the form of parameters with names and values.",
            title="Environment variables",
        ),
    ] = None
    data: Annotated[
        Attachment | None,
        Field(description="Inputs that have the form of data.", title="Data"),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class InputType2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    source: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="A reference to the component or service that provided the input to the task (e.g., reference to a service with data flow value of `inbound`)",
            examples=["source code repository", "database"],
            title="Source",
        ),
    ] = None
    target: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="A reference to the component or service that received or stored the input if not the task itself (e.g., a local, named storage workspace)",
            examples=["workspace", "directory"],
            title="Target",
        ),
    ] = None
    resource: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="A reference to an independent resource provided as an input to a task by the workflow runtime.",
            examples=[
                "a reference to a configuration file in a repository (i.e., a bom-ref)",
                "a reference to a scanning service used in a task (i.e., a bom-ref)",
            ],
            title="Resource",
        ),
    ] = None
    parameters: Annotated[
        list[Parameter],
        Field(
            description="Inputs that have the form of parameters with names and values.",
            title="Parameters",
        ),
    ]
    environment_vars: Annotated[
        list[Property | str] | None,
        Field(
            alias="environmentVars",
            description="Inputs that have the form of parameters with names and values.",
            title="Environment variables",
        ),
    ] = None
    data: Annotated[
        Attachment | None,
        Field(description="Inputs that have the form of data.", title="Data"),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class InputType3(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    source: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="A reference to the component or service that provided the input to the task (e.g., reference to a service with data flow value of `inbound`)",
            examples=["source code repository", "database"],
            title="Source",
        ),
    ] = None
    target: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="A reference to the component or service that received or stored the input if not the task itself (e.g., a local, named storage workspace)",
            examples=["workspace", "directory"],
            title="Target",
        ),
    ] = None
    resource: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="A reference to an independent resource provided as an input to a task by the workflow runtime.",
            examples=[
                "a reference to a configuration file in a repository (i.e., a bom-ref)",
                "a reference to a scanning service used in a task (i.e., a bom-ref)",
            ],
            title="Resource",
        ),
    ] = None
    parameters: Annotated[
        list[Parameter] | None,
        Field(
            description="Inputs that have the form of parameters with names and values.",
            title="Parameters",
        ),
    ] = None
    environment_vars: Annotated[
        list[Property | str],
        Field(
            alias="environmentVars",
            description="Inputs that have the form of parameters with names and values.",
            title="Environment variables",
        ),
    ]
    data: Annotated[
        Attachment | None,
        Field(description="Inputs that have the form of data.", title="Data"),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class InputType4(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    source: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="A reference to the component or service that provided the input to the task (e.g., reference to a service with data flow value of `inbound`)",
            examples=["source code repository", "database"],
            title="Source",
        ),
    ] = None
    target: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="A reference to the component or service that received or stored the input if not the task itself (e.g., a local, named storage workspace)",
            examples=["workspace", "directory"],
            title="Target",
        ),
    ] = None
    resource: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="A reference to an independent resource provided as an input to a task by the workflow runtime.",
            examples=[
                "a reference to a configuration file in a repository (i.e., a bom-ref)",
                "a reference to a scanning service used in a task (i.e., a bom-ref)",
            ],
            title="Resource",
        ),
    ] = None
    parameters: Annotated[
        list[Parameter] | None,
        Field(
            description="Inputs that have the form of parameters with names and values.",
            title="Parameters",
        ),
    ] = None
    environment_vars: Annotated[
        list[Property | str] | None,
        Field(
            alias="environmentVars",
            description="Inputs that have the form of parameters with names and values.",
            title="Environment variables",
        ),
    ] = None
    data: Annotated[
        Attachment,
        Field(description="Inputs that have the form of data.", title="Data"),
    ]
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class InputType(RootModel[InputType1 | InputType2 | InputType3 | InputType4]):
    root: Annotated[
        InputType1 | InputType2 | InputType3 | InputType4,
        Field(
            description="Type that represents various input data types and formats.",
            title="Input type",
        ),
    ]


class OutputType1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[
        Type7 | None,
        Field(description="Describes the type of data output.", title="Type"),
    ] = None
    source: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="Component or service that generated or provided the output from the task (e.g., a build tool)",
            title="Source",
        ),
    ] = None
    target: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="Component or service that received the output from the task (e.g., reference to an artifactory service with data flow value of `outbound`)",
            examples=["a log file described as an `externalReference` within its target domain."],
            title="Target",
        ),
    ] = None
    resource: Annotated[
        ResourceReferenceChoice,
        Field(
            description="A reference to an independent resource generated as output by the task.",
            examples=["configuration file", "source code", "scanning service"],
            title="Resource",
        ),
    ]
    data: Annotated[
        Attachment | None,
        Field(description="Outputs that have the form of data.", title="Data"),
    ] = None
    environment_vars: Annotated[
        list[Property | str] | None,
        Field(
            alias="environmentVars",
            description="Outputs that have the form of environment variables.",
            title="Environment variables",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class OutputType2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[
        Type7 | None,
        Field(description="Describes the type of data output.", title="Type"),
    ] = None
    source: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="Component or service that generated or provided the output from the task (e.g., a build tool)",
            title="Source",
        ),
    ] = None
    target: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="Component or service that received the output from the task (e.g., reference to an artifactory service with data flow value of `outbound`)",
            examples=["a log file described as an `externalReference` within its target domain."],
            title="Target",
        ),
    ] = None
    resource: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="A reference to an independent resource generated as output by the task.",
            examples=["configuration file", "source code", "scanning service"],
            title="Resource",
        ),
    ] = None
    data: Annotated[
        Attachment | None,
        Field(description="Outputs that have the form of data.", title="Data"),
    ] = None
    environment_vars: Annotated[
        list[Property | str],
        Field(
            alias="environmentVars",
            description="Outputs that have the form of environment variables.",
            title="Environment variables",
        ),
    ]
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class OutputType3(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[
        Type7 | None,
        Field(description="Describes the type of data output.", title="Type"),
    ] = None
    source: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="Component or service that generated or provided the output from the task (e.g., a build tool)",
            title="Source",
        ),
    ] = None
    target: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="Component or service that received the output from the task (e.g., reference to an artifactory service with data flow value of `outbound`)",
            examples=["a log file described as an `externalReference` within its target domain."],
            title="Target",
        ),
    ] = None
    resource: Annotated[
        ResourceReferenceChoice | None,
        Field(
            description="A reference to an independent resource generated as output by the task.",
            examples=["configuration file", "source code", "scanning service"],
            title="Resource",
        ),
    ] = None
    data: Annotated[
        Attachment,
        Field(description="Outputs that have the form of data.", title="Data"),
    ]
    environment_vars: Annotated[
        list[Property | str] | None,
        Field(
            alias="environmentVars",
            description="Outputs that have the form of environment variables.",
            title="Environment variables",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class OutputType(RootModel[OutputType1 | OutputType2 | OutputType3]):
    root: OutputType1 | OutputType2 | OutputType3


class Signature1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    signers: Annotated[
        list[Signer] | None,
        Field(
            description="Unique top level property for Multiple Signatures. (multisignature)",
            title="Signature",
        ),
    ] = None


class Signature2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    chain: Annotated[
        list[Signer] | None,
        Field(
            description="Unique top level property for Signature Chains. (signaturechain)",
            title="Signature",
        ),
    ] = None


class Signature(RootModel[Signature1 | Signature2 | Signer]):
    root: Annotated[Signature1 | Signature2 | Signer, Field(title="Signature")]


class CertificateProperties(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    serial_number: Annotated[
        str | None,
        Field(
            alias="serialNumber",
            description="The serial number is a unique identifier for the certificate issued by a CA.",
            title="Serial Number",
        ),
    ] = None
    subject_name: Annotated[
        str | None,
        Field(
            alias="subjectName",
            description="The subject name for the certificate",
            title="Subject Name",
        ),
    ] = None
    issuer_name: Annotated[
        str | None,
        Field(
            alias="issuerName",
            description="The issuer name for the certificate",
            title="Issuer Name",
        ),
    ] = None
    not_valid_before: Annotated[
        AwareDatetime | None,
        Field(
            alias="notValidBefore",
            description="The date and time according to ISO-8601 standard from which the certificate is valid",
            title="Not Valid Before",
        ),
    ] = None
    not_valid_after: Annotated[
        AwareDatetime | None,
        Field(
            alias="notValidAfter",
            description="The date and time according to ISO-8601 standard from which the certificate is not valid anymore",
            title="Not Valid After",
        ),
    ] = None
    signature_algorithm_ref: Annotated[
        RefType | None,
        Field(
            alias="signatureAlgorithmRef",
            description="[DEPRECATED] This will be removed in a future version. Use `@.relatedCryptographicAssets` instead.\nThe bom-ref to signature algorithm used by the certificate",
            title="Algorithm Reference",
        ),
    ] = None
    subject_public_key_ref: Annotated[
        RefType | None,
        Field(
            alias="subjectPublicKeyRef",
            description="[DEPRECATED] This will be removed in a future version. Use `@.relatedCryptographicAssets` instead.\nThe bom-ref to the public key of the subject",
            title="Key reference",
        ),
    ] = None
    certificate_format: Annotated[
        str | None,
        Field(
            alias="certificateFormat",
            description="The format of the certificate",
            examples=["X.509", "PEM", "DER", "CVC"],
            title="Certificate Format",
        ),
    ] = None
    certificate_extension: Annotated[
        str | None,
        Field(
            alias="certificateExtension",
            description="[DEPRECATED] This will be removed in a future version. Use `@.certificateFileExtension` instead.\nThe file extension of the certificate",
            examples=["crt", "pem", "cer", "der", "p12"],
            title="Certificate File Extension",
        ),
    ] = None
    certificate_file_extension: Annotated[
        str | None,
        Field(
            alias="certificateFileExtension",
            description="The file extension of the certificate.",
            examples=["crt", "pem", "cer", "der", "p12"],
            title="Certificate File Extension",
        ),
    ] = None
    fingerprint: Annotated[
        Hash | None,
        Field(
            description="The fingerprint is a cryptographic hash of the certificate excluding it's signature.",
            title="Certificate Fingerprint",
        ),
    ] = None
    certificate_state: Annotated[
        list[CertificateState | CertificateState1] | None,
        Field(
            alias="certificateState",
            description="The certificate lifecycle is a comprehensive process that manages digital certificates from their initial creation to eventual expiration or revocation. It typically involves several stages",
            title="Certificate Lifecycle State",
        ),
    ] = None
    creation_date: Annotated[
        AwareDatetime | None,
        Field(
            alias="creationDate",
            description="The date and time (timestamp) when the certificate was created or pre-activated.",
            title="Creation Date",
        ),
    ] = None
    activation_date: Annotated[
        AwareDatetime | None,
        Field(
            alias="activationDate",
            description="The date and time (timestamp) when the certificate was activated.",
            title="Activation Date",
        ),
    ] = None
    deactivation_date: Annotated[
        AwareDatetime | None,
        Field(
            alias="deactivationDate",
            description="The date and time (timestamp) when the related certificate was deactivated.",
            title="Deactivation Date",
        ),
    ] = None
    revocation_date: Annotated[
        AwareDatetime | None,
        Field(
            alias="revocationDate",
            description="The date and time (timestamp) when the certificate was revoked.",
            title="Revocation Date",
        ),
    ] = None
    destruction_date: Annotated[
        AwareDatetime | None,
        Field(
            alias="destructionDate",
            description="The date and time (timestamp) when the certificate was destroyed.",
            title="Destruction Date",
        ),
    ] = None
    certificate_extensions: Annotated[
        list[CertificateExtensions | CertificateExtensions1] | None,
        Field(
            alias="certificateExtensions",
            description="A certificate extension is a field that provides additional information about the certificate or its use. Extensions are used to convey additional information beyond the standard fields.",
            title="Certificate Extensions",
        ),
    ] = None
    related_cryptographic_assets: Annotated[
        RelatedCryptographicAssets | None,
        Field(
            alias="relatedCryptographicAssets",
            description="A list of cryptographic assets related to this component.",
            title="Related Cryptographic Assets",
        ),
    ] = None


class RelatedCryptoMaterialProperties(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[
        Type10 | None,
        Field(
            description="The type for the related cryptographic material",
            title="relatedCryptoMaterialType",
        ),
    ] = None
    id: Annotated[
        str | None,
        Field(
            description="The unique identifier for the related cryptographic material.",
            title="ID",
        ),
    ] = None
    state: Annotated[
        State1 | None,
        Field(description="The key state as defined by NIST SP 800-57.", title="State"),
    ] = None
    algorithm_ref: Annotated[
        RefType | None,
        Field(
            alias="algorithmRef",
            description="[DEPRECATED] Use `@.relatedCryptographicAssets` instead.\nThe bom-ref to the algorithm used to generate the related cryptographic material.",
            title="Algorithm Reference",
        ),
    ] = None
    creation_date: Annotated[
        AwareDatetime | None,
        Field(
            alias="creationDate",
            description="The date and time (timestamp) when the related cryptographic material was created.",
            title="Creation Date",
        ),
    ] = None
    activation_date: Annotated[
        AwareDatetime | None,
        Field(
            alias="activationDate",
            description="The date and time (timestamp) when the related cryptographic material was activated.",
            title="Activation Date",
        ),
    ] = None
    update_date: Annotated[
        AwareDatetime | None,
        Field(
            alias="updateDate",
            description="The date and time (timestamp) when the related cryptographic material was updated.",
            title="Update Date",
        ),
    ] = None
    expiration_date: Annotated[
        AwareDatetime | None,
        Field(
            alias="expirationDate",
            description="The date and time (timestamp) when the related cryptographic material expires.",
            title="Expiration Date",
        ),
    ] = None
    value: Annotated[
        str | None,
        Field(
            description="The associated value of the cryptographic material.",
            title="Value",
        ),
    ] = None
    size: Annotated[
        int | None,
        Field(description="The size of the cryptographic asset (in bits).", title="Size"),
    ] = None
    format: Annotated[
        str | None,
        Field(
            description="The format of the related cryptographic material (e.g. P8, PEM, DER).",
            title="Format",
        ),
    ] = None
    secured_by: Annotated[
        SecuredBy | None,
        Field(
            alias="securedBy",
            description="The mechanism by which the cryptographic asset is secured by.",
            title="Secured By",
        ),
    ] = None
    fingerprint: Annotated[
        Hash | None,
        Field(
            description="The fingerprint is a cryptographic hash of the asset.",
            title="Fingerprint",
        ),
    ] = None
    related_cryptographic_assets: Annotated[
        RelatedCryptographicAssets | None,
        Field(
            alias="relatedCryptographicAssets",
            description="A list of cryptographic assets related to this component.",
            title="Related Cryptographic Assets",
        ),
    ] = None


class ProtocolProperties(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[Type11 | None, Field(description="The concrete protocol type.", title="Type")] = None
    version: Annotated[
        str | None,
        Field(
            description="The version of the protocol.",
            examples=["1.0", "1.2", "1.99"],
            title="Protocol Version",
        ),
    ] = None
    cipher_suites: Annotated[
        list[CipherSuite] | None,
        Field(
            alias="cipherSuites",
            description="A list of cipher suites related to the protocol.",
            title="Cipher Suites",
        ),
    ] = None
    ikev2_transform_types: Annotated[
        Ikev2TransformTypes | None,
        Field(
            alias="ikev2TransformTypes",
            description="The IKEv2 transform types supported (types 1-4), defined in [RFC 7296 section 3.3.2](https://www.ietf.org/rfc/rfc7296.html#section-3.3.2), and additional properties.",
            title="IKEv2 Transform Types",
        ),
    ] = None
    crypto_ref_array: Annotated[
        CryptoRefArray | None,
        Field(
            alias="cryptoRefArray",
            description="[DEPRECATED] Use `@.relatedCryptographicAssets` instead.\nA list of protocol-related cryptographic assets",
            title="Cryptographic References",
        ),
    ] = None
    related_cryptographic_assets: Annotated[
        RelatedCryptographicAssets | None,
        Field(
            alias="relatedCryptographicAssets",
            description="A list of cryptographic assets related to this component.",
            title="Related Cryptographic Assets",
        ),
    ] = None


class CryptoProperties(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    asset_type: Annotated[
        AssetType,
        Field(
            alias="assetType",
            description="Cryptographic assets occur in several forms. Algorithms and protocols are most commonly implemented in specialized cryptographic libraries. They may, however, also be 'hardcoded' in software components. Certificates and related cryptographic material like keys, tokens, secrets or passwords are other cryptographic assets to be modelled.",
            title="Asset Type",
        ),
    ]
    algorithm_properties: Annotated[
        AlgorithmProperties | None,
        Field(
            alias="algorithmProperties",
            description="Additional properties specific to a cryptographic algorithm.",
            title="Algorithm Properties",
        ),
    ] = None
    certificate_properties: Annotated[
        CertificateProperties | None,
        Field(
            alias="certificateProperties",
            description="Properties for cryptographic assets of asset type 'certificate'",
            title="Certificate Properties",
        ),
    ] = None
    related_crypto_material_properties: Annotated[
        RelatedCryptoMaterialProperties | None,
        Field(
            alias="relatedCryptoMaterialProperties",
            description="Properties for cryptographic assets of asset type: `related-crypto-material`",
            title="Related Cryptographic Material Properties",
        ),
    ] = None
    protocol_properties: Annotated[
        ProtocolProperties | None,
        Field(
            alias="protocolProperties",
            description="Properties specific to cryptographic assets of type: `protocol`.",
            title="Protocol Properties",
        ),
    ] = None
    oid: Annotated[
        str | None,
        Field(
            description="The object identifier (OID) of the cryptographic asset.",
            title="OID",
        ),
    ] = None


class Datum(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[str | None, Field(description="The name of the data.", title="Data Name")] = None
    contents: Annotated[
        Contents | None,
        Field(
            description="The contents or references to the contents of the data being described.",
            title="Data Contents",
        ),
    ] = None
    classification: DataClassification | None = None
    sensitive_data: Annotated[
        list[str] | None,
        Field(
            alias="sensitiveData",
            description="A description of any sensitive data included.",
            title="Sensitive Data",
        ),
    ] = None
    governance: Annotated[DataGovernance | None, Field(title="Data Governance")] = None


class ServiceData(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    flow: Annotated[
        DataFlowDirection,
        Field(
            description="Specifies the flow direction of the data. Direction is relative to the service. Inbound flow states that data enters the service. Outbound flow states that data leaves the service. Bi-directional states that data flows both ways and unknown states that the direction is not known.",
            title="Directional Flow",
        ),
    ]
    classification: DataClassification
    name: Annotated[
        str | None,
        Field(
            description="Name for the defined data",
            examples=["Credit card reporting"],
            title="Name",
        ),
    ] = None
    description: Annotated[
        str | None,
        Field(
            description="Short description of the data content and usage",
            examples=["Credit card information being exchanged in between the web app and the database"],
            title="Description",
        ),
    ] = None
    governance: Annotated[DataGovernance | None, Field(title="Data Governance")] = None
    source: Annotated[
        list[str | BomLinkElementType] | None,
        Field(
            description="The URI, URL, or BOM-Link of the components or services the data came in from",
            title="Source",
        ),
    ] = None
    destination: Annotated[
        list[str | BomLinkElementType] | None,
        Field(
            description="The URI, URL, or BOM-Link of the components or services the data is sent to",
            title="Destination",
        ),
    ] = None


class ComponentData(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the dataset elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ] = None
    type: Annotated[
        Type5,
        Field(
            description="The general theme or subject matter of the data being specified.",
            title="Type of Data",
        ),
    ]
    name: Annotated[str | None, Field(description="The name of the dataset.", title="Dataset Name")] = None
    contents: Annotated[
        Contents1 | None,
        Field(
            description="The contents or references to the contents of the data being described.",
            title="Data Contents",
        ),
    ] = None
    classification: DataClassification | None = None
    sensitive_data: Annotated[
        list[str] | None,
        Field(
            alias="sensitiveData",
            description="A description of any sensitive data in a dataset.",
            title="Sensitive Data",
        ),
    ] = None
    graphics: GraphicsCollection | None = None
    description: Annotated[
        str | None,
        Field(
            description="A description of the dataset. Can describe size of dataset, whether it's used for source code, training, testing, or validation, etc.",
            title="Dataset Description",
        ),
    ] = None
    governance: Annotated[DataGovernance | None, Field(title="Data Governance")] = None


class EnvironmentalConsiderations(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    energy_consumptions: Annotated[
        list[EnergyConsumption] | None,
        Field(
            alias="energyConsumptions",
            description="Describes energy consumption information incurred for one or more component lifecycle activities.",
            title="Energy Consumptions",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class Trigger(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the trigger elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ]
    uid: Annotated[
        str,
        Field(
            description="The unique identifier for the resource instance within its deployment context.",
            title="Unique Identifier (UID)",
        ),
    ]
    name: Annotated[
        str | None,
        Field(description="The name of the resource instance.", title="Name"),
    ] = None
    description: Annotated[
        str | None,
        Field(description="A description of the resource instance.", title="Description"),
    ] = None
    resource_references: Annotated[
        list[ResourceReferenceChoice] | None,
        Field(
            alias="resourceReferences",
            description="References to component or service resources that are used to realize the resource instance.",
            title="Resource references",
        ),
    ] = None
    type: Annotated[
        Type6,
        Field(
            description="The source type of event which caused the trigger to fire.",
            title="Type",
        ),
    ]
    event: Annotated[
        Event | None,
        Field(
            description="The event data that caused the associated trigger to activate.",
            title="Event",
        ),
    ] = None
    conditions: Annotated[
        list[Condition] | None,
        Field(
            description="A list of conditions used to determine if a trigger should be activated.",
            title="Conditions",
        ),
    ] = None
    time_activated: Annotated[
        AwareDatetime | None,
        Field(
            alias="timeActivated",
            description="The date and time (timestamp) when the trigger was activated.",
            title="Time activated",
        ),
    ] = None
    inputs: Annotated[
        list[InputType] | None,
        Field(
            description="Represents resources and data brought into a task at runtime by executor or task commands",
            examples=["a `configuration` file which was declared as a local `component` or `externalReference`"],
            title="Inputs",
        ),
    ] = None
    outputs: Annotated[
        list[OutputType] | None,
        Field(
            description="Represents resources and data output from a task at runtime by executor or task commands",
            examples=["a log file or metrics data produced by the task"],
            title="Outputs",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class Citation1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[RefType | None, Field(alias="bom-ref", title="BOM Reference")] = None
    pointers: Annotated[
        list[str],
        Field(
            description='One or more [JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901) identifying the BOM fields to which the attribution applies.\nExactly one of the "pointers" or "expressions" elements must be present.',
            min_length=1,
            title="Field References",
        ),
    ]
    expressions: Annotated[
        list[str] | None,
        Field(
            description='One or more path expressions used to locate values within a BOM.\nExactly one of the "pointers" or "expressions" elements must be present.',
            min_length=1,
            title="Path Expressions",
        ),
    ] = None
    timestamp: Annotated[
        AwareDatetime,
        Field(
            description="The date and time when the attribution was made or the information was supplied.",
            title="Timestamp",
        ),
    ]
    attributed_to: Annotated[
        RefLinkType,
        Field(
            alias="attributedTo",
            description='The `bom-ref` of an object, such as a component, service, tool, organisational entity, or person that supplied the cited information.\nAt least one of the "attributedTo" or "process" elements must be present.',
            title="Attributed To",
        ),
    ]
    process: Annotated[
        RefLinkType | None,
        Field(
            description='The `bom-ref` to a process (such as a formula, workflow, task, or step) defined in the `formulation` section that executed or generated the attributed data.\nAt least one of the "attributedTo" or "process" elements must be present.',
            title="Process Reference",
        ),
    ] = None
    note: Annotated[
        str | None,
        Field(
            description="A description or comment about the context or quality of the data attribution.",
            title="Note",
        ),
    ] = None
    signature: Annotated[
        Signature | None,
        Field(
            description="A digital signature verifying the authenticity or integrity of the attribution.",
            title="Signature",
        ),
    ] = None


class Citation2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[RefType | None, Field(alias="bom-ref", title="BOM Reference")] = None
    pointers: Annotated[
        list[str] | None,
        Field(
            description='One or more [JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901) identifying the BOM fields to which the attribution applies.\nExactly one of the "pointers" or "expressions" elements must be present.',
            min_length=1,
            title="Field References",
        ),
    ] = None
    expressions: Annotated[
        list[str],
        Field(
            description='One or more path expressions used to locate values within a BOM.\nExactly one of the "pointers" or "expressions" elements must be present.',
            min_length=1,
            title="Path Expressions",
        ),
    ]
    timestamp: Annotated[
        AwareDatetime,
        Field(
            description="The date and time when the attribution was made or the information was supplied.",
            title="Timestamp",
        ),
    ]
    attributed_to: Annotated[
        RefLinkType,
        Field(
            alias="attributedTo",
            description='The `bom-ref` of an object, such as a component, service, tool, organisational entity, or person that supplied the cited information.\nAt least one of the "attributedTo" or "process" elements must be present.',
            title="Attributed To",
        ),
    ]
    process: Annotated[
        RefLinkType | None,
        Field(
            description='The `bom-ref` to a process (such as a formula, workflow, task, or step) defined in the `formulation` section that executed or generated the attributed data.\nAt least one of the "attributedTo" or "process" elements must be present.',
            title="Process Reference",
        ),
    ] = None
    note: Annotated[
        str | None,
        Field(
            description="A description or comment about the context or quality of the data attribution.",
            title="Note",
        ),
    ] = None
    signature: Annotated[
        Signature | None,
        Field(
            description="A digital signature verifying the authenticity or integrity of the attribution.",
            title="Signature",
        ),
    ] = None


class Citation3(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[RefType | None, Field(alias="bom-ref", title="BOM Reference")] = None
    pointers: Annotated[
        list[str],
        Field(
            description='One or more [JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901) identifying the BOM fields to which the attribution applies.\nExactly one of the "pointers" or "expressions" elements must be present.',
            min_length=1,
            title="Field References",
        ),
    ]
    expressions: Annotated[
        list[str] | None,
        Field(
            description='One or more path expressions used to locate values within a BOM.\nExactly one of the "pointers" or "expressions" elements must be present.',
            min_length=1,
            title="Path Expressions",
        ),
    ] = None
    timestamp: Annotated[
        AwareDatetime,
        Field(
            description="The date and time when the attribution was made or the information was supplied.",
            title="Timestamp",
        ),
    ]
    attributed_to: Annotated[
        RefLinkType | None,
        Field(
            alias="attributedTo",
            description='The `bom-ref` of an object, such as a component, service, tool, organisational entity, or person that supplied the cited information.\nAt least one of the "attributedTo" or "process" elements must be present.',
            title="Attributed To",
        ),
    ] = None
    process: Annotated[
        RefLinkType,
        Field(
            description='The `bom-ref` to a process (such as a formula, workflow, task, or step) defined in the `formulation` section that executed or generated the attributed data.\nAt least one of the "attributedTo" or "process" elements must be present.',
            title="Process Reference",
        ),
    ]
    note: Annotated[
        str | None,
        Field(
            description="A description or comment about the context or quality of the data attribution.",
            title="Note",
        ),
    ] = None
    signature: Annotated[
        Signature | None,
        Field(
            description="A digital signature verifying the authenticity or integrity of the attribution.",
            title="Signature",
        ),
    ] = None


class Citation4(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[RefType | None, Field(alias="bom-ref", title="BOM Reference")] = None
    pointers: Annotated[
        list[str] | None,
        Field(
            description='One or more [JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901) identifying the BOM fields to which the attribution applies.\nExactly one of the "pointers" or "expressions" elements must be present.',
            min_length=1,
            title="Field References",
        ),
    ] = None
    expressions: Annotated[
        list[str],
        Field(
            description='One or more path expressions used to locate values within a BOM.\nExactly one of the "pointers" or "expressions" elements must be present.',
            min_length=1,
            title="Path Expressions",
        ),
    ]
    timestamp: Annotated[
        AwareDatetime,
        Field(
            description="The date and time when the attribution was made or the information was supplied.",
            title="Timestamp",
        ),
    ]
    attributed_to: Annotated[
        RefLinkType | None,
        Field(
            alias="attributedTo",
            description='The `bom-ref` of an object, such as a component, service, tool, organisational entity, or person that supplied the cited information.\nAt least one of the "attributedTo" or "process" elements must be present.',
            title="Attributed To",
        ),
    ] = None
    process: Annotated[
        RefLinkType,
        Field(
            description='The `bom-ref` to a process (such as a formula, workflow, task, or step) defined in the `formulation` section that executed or generated the attributed data.\nAt least one of the "attributedTo" or "process" elements must be present.',
            title="Process Reference",
        ),
    ]
    note: Annotated[
        str | None,
        Field(
            description="A description or comment about the context or quality of the data attribution.",
            title="Note",
        ),
    ] = None
    signature: Annotated[
        Signature | None,
        Field(
            description="A digital signature verifying the authenticity or integrity of the attribution.",
            title="Signature",
        ),
    ] = None


class Citation(RootModel[Citation1 | Citation2 | Citation3 | Citation4]):
    root: Annotated[
        Citation1 | Citation2 | Citation3 | Citation4,
        Field(
            description="Details a specific attribution of data within the BOM to a contributing entity or process.",
            title="Citation",
        ),
    ]


class Attestation(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    summary: Annotated[
        str | None,
        Field(
            description="The short description explaining the main points of the attestation.",
            title="Summary",
        ),
    ] = None
    assessor: Annotated[
        RefLinkType | None,
        Field(
            description="The `bom-ref` to the assessor asserting the attestation.",
            title="Assessor",
        ),
    ] = None
    map: Annotated[
        list[MapItem] | None,
        Field(
            description="The grouping of requirements to claims and the attestors declared conformance and confidence thereof.",
            title="Map",
        ),
    ] = None
    signature: Annotated[
        Signature | None,
        Field(
            description="Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).",
            title="Signature",
        ),
    ] = None


class Claim(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the object elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    target: Annotated[
        RefLinkType | None,
        Field(
            description="The `bom-ref` to a target representing a specific system, application, API, module, team, person, process, business unit, company, etc...  that this claim is being applied to.",
            title="Target",
        ),
    ] = None
    predicate: Annotated[
        str | None,
        Field(
            description="The specific statement or assertion about the target.",
            title="Predicate",
        ),
    ] = None
    mitigation_strategies: Annotated[
        list[RefLinkType] | None,
        Field(
            alias="mitigationStrategies",
            description="The list of  `bom-ref` to the evidence provided describing the mitigation strategies. Each mitigation strategy should include an explanation of how any weaknesses in the evidence will be mitigated.",
            title="Mitigation Strategies",
        ),
    ] = None
    reasoning: Annotated[
        str | None,
        Field(
            description="The written explanation of why the evidence provided substantiates the claim.",
            title="Reasoning",
        ),
    ] = None
    evidence: Annotated[
        list[RefLinkType] | None,
        Field(
            description="The list of `bom-ref` to evidence that supports this claim.",
            title="Evidence",
        ),
    ] = None
    counter_evidence: Annotated[
        list[RefLinkType] | None,
        Field(
            alias="counterEvidence",
            description="The list of `bom-ref` to counterEvidence that supports this claim.",
            title="Counter Evidence",
        ),
    ] = None
    external_references: Annotated[
        list[ExternalReference] | None,
        Field(
            alias="externalReferences",
            description="External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.",
            title="External References",
        ),
    ] = None
    signature: Annotated[
        Signature | None,
        Field(
            description="Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).",
            title="Signature",
        ),
    ] = None


class EvidenceItem(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the object elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    property_name: Annotated[
        str | None,
        Field(
            alias="propertyName",
            description="The reference to the property name as defined in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy/).",
            title="Property Name",
        ),
    ] = None
    description: Annotated[
        str | None,
        Field(
            description="The written description of what this evidence is and how it was created.",
            title="Description",
        ),
    ] = None
    data: Annotated[
        list[Datum] | None,
        Field(description="The output or analysis that supports claims.", title="Data"),
    ] = None
    created: Annotated[
        AwareDatetime | None,
        Field(
            description="The date and time (timestamp) when the evidence was created.",
            title="Created",
        ),
    ] = None
    expires: Annotated[
        AwareDatetime | None,
        Field(
            description="The date and time (timestamp) when the evidence is no longer valid.",
            title="Expires",
        ),
    ] = None
    author: Annotated[
        OrganizationalContact | None,
        Field(description="The author of the evidence.", title="Author"),
    ] = None
    reviewer: Annotated[
        OrganizationalContact | None,
        Field(description="The reviewer of the evidence.", title="Reviewer"),
    ] = None
    signature: Annotated[
        Signature | None,
        Field(
            description="Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).",
            title="Signature",
        ),
    ] = None


class Signatories(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[str | None, Field(description="The signatory's name.", title="Name")] = None
    role: Annotated[
        str | None,
        Field(description="The signatory's role within an organization.", title="Role"),
    ] = None
    signature: Annotated[
        Signature,
        Field(
            description="Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).",
            title="Signature",
        ),
    ]
    organization: Annotated[
        OrganizationalEntity | None,
        Field(description="The signatory's organization.", title="Organization"),
    ] = None
    external_reference: Annotated[
        ExternalReference | None,
        Field(
            alias="externalReference",
            description="External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.",
            title="External Reference",
        ),
    ] = None


class Signatories1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[str | None, Field(description="The signatory's name.", title="Name")] = None
    role: Annotated[
        str | None,
        Field(description="The signatory's role within an organization.", title="Role"),
    ] = None
    signature: Annotated[
        Signature | None,
        Field(
            description="Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).",
            title="Signature",
        ),
    ] = None
    organization: Annotated[
        OrganizationalEntity,
        Field(description="The signatory's organization.", title="Organization"),
    ]
    external_reference: Annotated[
        ExternalReference,
        Field(
            alias="externalReference",
            description="External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.",
            title="External Reference",
        ),
    ]


class Affirmation(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    statement: Annotated[
        str | None,
        Field(
            description="The brief statement affirmed by an individual regarding all declarations.\n*- Notes This could be an affirmation of acceptance by a third-party auditor or receiving individual of a file.",
            examples=["I certify, to the best of my knowledge, that all information is correct."],
            title="Statement",
        ),
    ] = None
    signatories: Annotated[
        list[Signatories | Signatories1] | None,
        Field(
            description="The list of signatories authorized on behalf of an organization to assert validity of this document.",
            title="Signatories",
        ),
    ] = None
    signature: Annotated[
        Signature | None,
        Field(
            description="Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).",
            title="Signature",
        ),
    ] = None


class Service(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the service elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ] = None
    provider: Annotated[
        OrganizationalEntity | None,
        Field(description="The organization that provides the service.", title="Provider"),
    ] = None
    group: Annotated[
        str | None,
        Field(
            description="The grouping name, namespace, or identifier. This will often be a shortened, single name of the company or project that produced the service or domain name. Whitespace and special characters should be avoided.",
            examples=["com.acme"],
            title="Service Group",
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description="The name of the service. This will often be a shortened, single name of the service.",
            examples=["ticker-service"],
            title="Service Name",
        ),
    ]
    version: Annotated[
        Version | None,
        Field(description="The service version.", title="Service Version"),
    ] = None
    description: Annotated[
        str | None,
        Field(
            description="Specifies a description for the service",
            title="Service Description",
        ),
    ] = None
    endpoints: Annotated[
        list[str] | None,
        Field(
            description="The endpoint URIs of the service. Multiple endpoints are allowed.",
            examples=["https://example.com/api/v1/ticker"],
            title="Endpoints",
        ),
    ] = None
    authenticated: Annotated[
        bool | None,
        Field(
            description="A boolean value indicating if the service requires authentication. A value of true indicates the service requires authentication prior to use. A value of false indicates the service does not require authentication.",
            title="Authentication Required",
        ),
    ] = None
    x_trust_boundary: Annotated[
        bool | None,
        Field(
            alias="x-trust-boundary",
            description="A boolean value indicating if use of the service crosses a trust zone or boundary. A value of true indicates that by using the service, a trust boundary is crossed. A value of false indicates that by using the service, a trust boundary is not crossed.",
            title="Crosses Trust Boundary",
        ),
    ] = None
    trust_zone: Annotated[
        str | None,
        Field(
            alias="trustZone",
            description="The name of the trust zone the service resides in.",
            title="Trust Zone",
        ),
    ] = None
    data: Annotated[
        list[ServiceData] | None,
        Field(
            description="Specifies information about the data including the directional flow of data and the data classification.",
            title="Data",
        ),
    ] = None
    licenses: Annotated[LicenseChoice | None, Field(title="Service License(s)")] = None
    patent_assertions: Annotated[
        PatentAssertions | None,
        Field(alias="patentAssertions", title="Service Patent(s)"),
    ] = None
    external_references: Annotated[
        list[ExternalReference] | None,
        Field(
            alias="externalReferences",
            description="External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.",
            title="External References",
        ),
    ] = None
    services: Annotated[
        list[Service] | None,
        Field(
            description="A list of services included or deployed behind the parent service. This is not a dependency tree. It provides a way to specify a hierarchical representation of service assemblies.",
            title="Services",
        ),
    ] = None
    release_notes: Annotated[
        ReleaseNotes | None,
        Field(
            alias="releaseNotes",
            description="Specifies release notes.",
            title="Release notes",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None
    tags: Annotated[Tags | None, Field(title="Tags")] = None
    signature: Annotated[
        Signature | None,
        Field(
            description="Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).",
            title="Signature",
        ),
    ] = None


class Compositions(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the composition elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ] = None
    aggregate: Annotated[
        AggregateType,
        Field(
            description="Specifies an aggregate type that describes how complete a relationship is.",
            title="Aggregate",
        ),
    ]
    assemblies: Annotated[
        list[RefLinkType | BomLinkElementType] | None,
        Field(
            description="The bom-ref identifiers of the components or services being described. Assemblies refer to nested relationships whereby a constituent part may include other constituent parts. References do not cascade to child parts. References are explicit for the specified constituent part only.",
            title="BOM references",
        ),
    ] = None
    dependencies: Annotated[
        list[str] | None,
        Field(
            description="The bom-ref identifiers of the components or services being described. Dependencies refer to a relationship whereby an independent constituent part requires another independent constituent part. References do not cascade to transitive dependencies. References are explicit for the specified dependency only.",
            title="BOM references",
        ),
    ] = None
    vulnerabilities: Annotated[
        list[str] | None,
        Field(
            description="The bom-ref identifiers of the vulnerabilities being described.",
            title="BOM references",
        ),
    ] = None
    signature: Annotated[
        Signature | None,
        Field(
            description="Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).",
            title="Signature",
        ),
    ] = None


class ModelParameters(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    approach: Annotated[
        Approach | None,
        Field(
            description="The overall approach to learning used by the model for problem solving.",
            title="Approach",
        ),
    ] = None
    task: Annotated[
        str | None,
        Field(
            description="Directly influences the input and/or output. Examples include classification, regression, clustering, etc.",
            title="Task",
        ),
    ] = None
    architecture_family: Annotated[
        str | None,
        Field(
            alias="architectureFamily",
            description="The model architecture family such as transformer network, convolutional neural network, residual neural network, LSTM neural network, etc.",
            title="Architecture Family",
        ),
    ] = None
    model_architecture: Annotated[
        str | None,
        Field(
            alias="modelArchitecture",
            description="The specific architecture of the model such as GPT-1, ResNet-50, YOLOv3, etc.",
            title="Model Architecture",
        ),
    ] = None
    datasets: Annotated[
        list[ComponentData | Datasets] | None,
        Field(
            description="The datasets used to train and evaluate the model.",
            title="Datasets",
        ),
    ] = None
    inputs: Annotated[
        list[InputOutputMLParameters] | None,
        Field(description="The input format(s) of the model", title="Inputs"),
    ] = None
    outputs: Annotated[
        list[InputOutputMLParameters] | None,
        Field(description="The output format(s) from the model", title="Outputs"),
    ] = None


class Considerations(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    users: Annotated[
        list[str] | None,
        Field(description="Who are the intended users of the model?", title="Users"),
    ] = None
    use_cases: Annotated[
        list[str] | None,
        Field(
            alias="useCases",
            description="What are the intended use cases of the model?",
            title="Use Cases",
        ),
    ] = None
    technical_limitations: Annotated[
        list[str] | None,
        Field(
            alias="technicalLimitations",
            description="What are the known technical limitations of the model? E.g. What kind(s) of data should the model be expected not to perform well on? What are the factors that might degrade model performance?",
            title="Technical Limitations",
        ),
    ] = None
    performance_tradeoffs: Annotated[
        list[str] | None,
        Field(
            alias="performanceTradeoffs",
            description="What are the known tradeoffs in accuracy/performance of the model?",
            title="Performance Tradeoffs",
        ),
    ] = None
    ethical_considerations: Annotated[
        list[Risk] | None,
        Field(
            alias="ethicalConsiderations",
            description="What are the ethical risks involved in the application of this model?",
            title="Ethical Considerations",
        ),
    ] = None
    environmental_considerations: Annotated[
        EnvironmentalConsiderations | None,
        Field(
            alias="environmentalConsiderations",
            description="What are the various environmental impacts the corresponding machine learning model has exhibited across its lifecycle?",
            title="Environmental Considerations",
        ),
    ] = None
    fairness_assessments: Annotated[
        list[FairnessAssessment] | None,
        Field(
            alias="fairnessAssessments",
            description="How does the model affect groups at risk of being systematically disadvantaged? What are the harms and benefits to the various affected groups?",
            title="Fairness Assessments",
        ),
    ] = None


class ModelCard(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the model card elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ] = None
    model_parameters: Annotated[
        ModelParameters | None,
        Field(
            alias="modelParameters",
            description="Hyper-parameters for construction of the model.",
            title="Model Parameters",
        ),
    ] = None
    quantitative_analysis: Annotated[
        QuantitativeAnalysis | None,
        Field(
            alias="quantitativeAnalysis",
            description="A quantitative analysis of the model",
            title="Quantitative Analysis",
        ),
    ] = None
    considerations: Annotated[
        Considerations | None,
        Field(
            description="What considerations should be taken into account regarding the model's construction, training, and application?",
            title="Considerations",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class Task(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the task elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ]
    uid: Annotated[
        str,
        Field(
            description="The unique identifier for the resource instance within its deployment context.",
            title="Unique Identifier (UID)",
        ),
    ]
    name: Annotated[
        str | None,
        Field(description="The name of the resource instance.", title="Name"),
    ] = None
    description: Annotated[
        str | None,
        Field(description="A description of the resource instance.", title="Description"),
    ] = None
    resource_references: Annotated[
        list[ResourceReferenceChoice] | None,
        Field(
            alias="resourceReferences",
            description="References to component or service resources that are used to realize the resource instance.",
            title="Resource references",
        ),
    ] = None
    task_types: Annotated[
        list[TaskType],
        Field(
            alias="taskTypes",
            description="Indicates the types of activities performed by the set of workflow tasks.",
            title="Task types",
        ),
    ]
    trigger: Annotated[
        Trigger | None,
        Field(description="The trigger that initiated the task.", title="Trigger"),
    ] = None
    steps: Annotated[
        list[Step] | None,
        Field(description="The sequence of steps for the task.", title="Steps"),
    ] = None
    inputs: Annotated[
        list[InputType] | None,
        Field(
            description="Represents resources and data brought into a task at runtime by executor or task commands",
            examples=["a `configuration` file which was declared as a local `component` or `externalReference`"],
            title="Inputs",
        ),
    ] = None
    outputs: Annotated[
        list[OutputType] | None,
        Field(
            description="Represents resources and data output from a task at runtime by executor or task commands",
            examples=["a log file or metrics data produced by the task"],
            title="Outputs",
        ),
    ] = None
    time_start: Annotated[
        AwareDatetime | None,
        Field(
            alias="timeStart",
            description="The date and time (timestamp) when the task started.",
            title="Time start",
        ),
    ] = None
    time_end: Annotated[
        AwareDatetime | None,
        Field(
            alias="timeEnd",
            description="The date and time (timestamp) when the task ended.",
            title="Time end",
        ),
    ] = None
    workspaces: Annotated[
        list[Workspace] | None,
        Field(
            description="A set of named filesystem or data resource shareable by workflow tasks.",
            title="Workspaces",
        ),
    ] = None
    runtime_topology: Annotated[
        list[Dependency] | None,
        Field(
            alias="runtimeTopology",
            description="A graph of the component runtime topology for task's instance.",
            title="Runtime topology",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class Standard(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the object elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    name: Annotated[
        str | None,
        Field(
            description="The name of the standard. This will often be a shortened, single name of the standard.",
            title="Name",
        ),
    ] = None
    version: Annotated[str | None, Field(description="The version of the standard.", title="Version")] = None
    description: Annotated[
        str | None,
        Field(description="The description of the standard.", title="Description"),
    ] = None
    owner: Annotated[
        str | None,
        Field(
            description="The owner of the standard, often the entity responsible for its release.",
            title="Owner",
        ),
    ] = None
    requirements: Annotated[
        list[Requirement] | None,
        Field(
            description="The list of requirements comprising the standard.",
            title="Requirements",
        ),
    ] = None
    levels: Annotated[
        list[Level] | None,
        Field(
            description="The list of levels associated with the standard. Some standards have different levels of compliance.",
            title="Levels",
        ),
    ] = None
    external_references: Annotated[
        list[ExternalReference] | None,
        Field(
            alias="externalReferences",
            description="External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.",
            title="External References",
        ),
    ] = None
    signature: Annotated[
        Signature | None,
        Field(
            description="Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).",
            title="Signature",
        ),
    ] = None


class Definitions(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    standards: Annotated[
        list[Standard] | None,
        Field(
            description="The list of standards which may consist of regulations, industry or organizational-specific standards, maturity models, best practices, or any other requirements which can be evaluated against or attested to.",
            title="Standards",
        ),
    ] = None
    patents: Annotated[
        list[Patent | PatentFamily] | None,
        Field(
            description="The list of either individual patents or patent families.",
            title="Patents",
        ),
    ] = None


class Workflow(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the workflow elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ]
    uid: Annotated[
        str,
        Field(
            description="The unique identifier for the resource instance within its deployment context.",
            title="Unique Identifier (UID)",
        ),
    ]
    name: Annotated[
        str | None,
        Field(description="The name of the resource instance.", title="Name"),
    ] = None
    description: Annotated[
        str | None,
        Field(description="A description of the resource instance.", title="Description"),
    ] = None
    resource_references: Annotated[
        list[ResourceReferenceChoice] | None,
        Field(
            alias="resourceReferences",
            description="References to component or service resources that are used to realize the resource instance.",
            title="Resource references",
        ),
    ] = None
    tasks: Annotated[
        list[Task] | None,
        Field(description="The tasks that comprise the workflow.", title="Tasks"),
    ] = None
    task_dependencies: Annotated[
        list[Dependency] | None,
        Field(
            alias="taskDependencies",
            description="The graph of dependencies between tasks within the workflow.",
            title="Task dependency graph",
        ),
    ] = None
    task_types: Annotated[
        list[TaskType],
        Field(
            alias="taskTypes",
            description="Indicates the types of activities performed by the set of workflow tasks.",
            title="Task types",
        ),
    ]
    trigger: Annotated[
        Trigger | None,
        Field(description="The trigger that initiated the task.", title="Trigger"),
    ] = None
    steps: Annotated[
        list[Step] | None,
        Field(description="The sequence of steps for the task.", title="Steps"),
    ] = None
    inputs: Annotated[
        list[InputType] | None,
        Field(
            description="Represents resources and data brought into a task at runtime by executor or task commands",
            examples=["a `configuration` file which was declared as a local `component` or `externalReference`"],
            title="Inputs",
        ),
    ] = None
    outputs: Annotated[
        list[OutputType] | None,
        Field(
            description="Represents resources and data output from a task at runtime by executor or task commands",
            examples=["a log file or metrics data produced by the task"],
            title="Outputs",
        ),
    ] = None
    time_start: Annotated[
        AwareDatetime | None,
        Field(
            alias="timeStart",
            description="The date and time (timestamp) when the task started.",
            title="Time start",
        ),
    ] = None
    time_end: Annotated[
        AwareDatetime | None,
        Field(
            alias="timeEnd",
            description="The date and time (timestamp) when the task ended.",
            title="Time end",
        ),
    ] = None
    workspaces: Annotated[
        list[Workspace] | None,
        Field(
            description="A set of named filesystem or data resource shareable by workflow tasks.",
            title="Workspaces",
        ),
    ] = None
    runtime_topology: Annotated[
        list[Dependency] | None,
        Field(
            alias="runtimeTopology",
            description="A graph of the component runtime topology for workflow's instance.",
            title="Runtime topology",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class Targets(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    organizations: Annotated[
        list[OrganizationalEntity] | None,
        Field(
            description="The list of organizations which claims are made against.",
            title="Organizations",
        ),
    ] = None
    components: Annotated[
        list[Component] | None,
        Field(
            description="The list of components which claims are made against.",
            title="Components",
        ),
    ] = None
    services: Annotated[
        list[Service] | None,
        Field(
            description="The list of services which claims are made against.",
            title="Services",
        ),
    ] = None


class Declarations(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    assessors: Annotated[
        list[Assessor] | None,
        Field(
            description="The list of assessors evaluating claims and determining conformance to requirements and confidence in that assessment.",
            title="Assessors",
        ),
    ] = None
    attestations: Annotated[
        list[Attestation] | None,
        Field(
            description="The list of attestations asserted by an assessor that maps requirements to claims.",
            title="Attestations",
        ),
    ] = None
    claims: Annotated[list[Claim] | None, Field(description="The list of claims.", title="Claims")] = None
    evidence: Annotated[
        list[EvidenceItem] | None,
        Field(description="The list of evidence", title="Evidence"),
    ] = None
    targets: Annotated[
        Targets | None,
        Field(
            description="The list of targets which claims are made against.",
            title="Targets",
        ),
    ] = None
    affirmation: Annotated[
        Affirmation | None,
        Field(
            description="A concise statement affirmed by an individual regarding all declarations, often used for third-party auditor acceptance or recipient acknowledgment. It includes a list of authorized signatories who assert the validity of the document on behalf of the organization.",
            title="Affirmation",
        ),
    ] = None
    signature: Annotated[
        Signature | None,
        Field(
            description="Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).",
            title="Signature",
        ),
    ] = None


class CyclonedxBillOfMaterialsStandard(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    field_schema: Annotated[str | None, Field(alias="$schema")] = None
    bom_format: Annotated[
        BomFormat,
        Field(
            alias="bomFormat",
            description='Specifies the format of the BOM. This helps to identify the file as CycloneDX since BOMs do not have a filename convention, nor does JSON schema support namespaces. This value must be "CycloneDX".',
            title="BOM Format",
        ),
    ]
    spec_version: Annotated[
        str,
        Field(
            alias="specVersion",
            description="The version of the CycloneDX specification the BOM conforms to.",
            examples=["1.7"],
            title="CycloneDX Specification Version",
        ),
    ]
    serial_number: Annotated[
        str | None,
        Field(
            alias="serialNumber",
            description="Every BOM generated SHOULD have a unique serial number, even if the contents of the BOM have not changed over time. If specified, the serial number must conform to [RFC 4122](https://www.ietf.org/rfc/rfc4122.html). Use of serial numbers is recommended.",
            examples=["urn:uuid:3e671687-395b-41f5-a30f-a58921a69b79"],
            pattern="^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$",
            title="BOM Serial Number",
        ),
    ] = None
    version: Annotated[
        int | None,
        Field(
            description="Whenever an existing BOM is modified, either manually or through automated processes, the version of the BOM SHOULD be incremented by 1. When a system is presented with multiple BOMs with identical serial numbers, the system SHOULD use the most recent version of the BOM. The default version is '1'.",
            examples=[1],
            ge=1,
            title="BOM Version",
        ),
    ] = 1
    metadata: Annotated[
        Metadata | None,
        Field(
            description="Provides additional information about a BOM.",
            title="BOM Metadata",
        ),
    ] = None
    components: Annotated[
        list[Component] | None,
        Field(
            description="A list of software and hardware components.",
            title="Components",
        ),
    ] = None
    services: Annotated[
        list[Service] | None,
        Field(
            description="A list of services. This may include microservices, function-as-a-service, and other types of network or intra-process services.",
            title="Services",
        ),
    ] = None
    external_references: Annotated[
        list[ExternalReference] | None,
        Field(
            alias="externalReferences",
            description="External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.",
            title="External References",
        ),
    ] = None
    dependencies: Annotated[
        list[Dependency] | None,
        Field(
            description="Provides the ability to document dependency relationships including provided & implemented components.",
            title="Dependencies",
        ),
    ] = None
    compositions: Annotated[
        list[Compositions] | None,
        Field(
            description="Compositions describe constituent parts (including components, services, and dependency relationships) and their completeness. The completeness of vulnerabilities expressed in a BOM may also be described.",
            title="Compositions",
        ),
    ] = None
    vulnerabilities: Annotated[
        list[Vulnerability] | None,
        Field(
            description="Vulnerabilities identified in components or services.",
            title="Vulnerabilities",
        ),
    ] = None
    annotations: Annotated[
        list[Annotations] | None,
        Field(
            description="Comments made by people, organizations, or tools about any object with a bom-ref, such as components, services, vulnerabilities, or the BOM itself. Unlike inventory information, annotations may contain opinions or commentary from various stakeholders. Annotations may be inline (with inventory) or externalized via BOM-Link and may optionally be signed.",
            title="Annotations",
        ),
    ] = None
    formulation: Annotated[
        list[Formula] | None,
        Field(
            description="Describes the formulation of any referencable object within the BOM, including components, services, metadata, declarations, or the BOM itself. This may encompass how the object was created, assembled, deployed, tested, certified, or otherwise brought into its present form. Common examples include software build pipelines, deployment processes, AI/ML model training, cryptographic key generation or certification, and third-party audits. Processes are modeled using declared and observed formulas, composed of workflows, tasks, and individual steps.",
            title="Formulation",
        ),
    ] = None
    declarations: Annotated[
        Declarations | None,
        Field(
            description="The list of declarations which describe the conformance to standards. Each declaration may include attestations, claims, and evidence.",
            title="Declarations",
        ),
    ] = None
    definitions: Annotated[
        Definitions | None,
        Field(
            description="A collection of reusable objects that are defined and may be used elsewhere in the BOM.",
            title="Definitions",
        ),
    ] = None
    citations: Annotated[
        list[Citation] | None,
        Field(
            description="A collection of attributions indicating which entity supplied information for specific fields within the BOM.",
            title="Citations",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None
    signature: Annotated[
        Signature | None,
        Field(
            description="Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).",
            title="Signature",
        ),
    ] = None


class Tools(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    components: Annotated[
        list[Component] | None,
        Field(
            description="A list of software and hardware components used as tools.",
            title="Components",
        ),
    ] = None
    services: Annotated[
        list[Service] | None,
        Field(
            description="A list of services used as tools. This may include microservices, function-as-a-service, and other types of network or intra-process services.",
            title="Services",
        ),
    ] = None


class Metadata(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    timestamp: Annotated[
        AwareDatetime | None,
        Field(
            description="The date and time (timestamp) when the BOM was created.",
            title="Timestamp",
        ),
    ] = None
    lifecycles: Annotated[
        list[Lifecycles | Lifecycles1] | None,
        Field(
            description="Lifecycles communicate the stage(s) in which data in the BOM was captured. Different types of data may be available at various phases of a lifecycle, such as the Software Development Lifecycle (SDLC), IT Asset Management (ITAM), and Software Asset Management (SAM). Thus, a BOM may include data specific to or only obtainable in a given lifecycle.",
            title="Lifecycles",
        ),
    ] = None
    tools: Annotated[
        Tools | list[Tool] | None,
        Field(
            description="The tool(s) used in the creation, enrichment, and validation of the BOM.",
            title="Tools",
        ),
    ] = None
    manufacturer: Annotated[
        OrganizationalEntity | None,
        Field(
            description="The organization that created the BOM.\nManufacturer is common in BOMs created through automated processes. BOMs created through manual means may have `@.authors` instead.",
            title="BOM Manufacturer",
        ),
    ] = None
    authors: Annotated[
        list[OrganizationalContact] | None,
        Field(
            description="The person(s) who created the BOM.\nAuthors are common in BOMs created through manual processes. BOMs created through automated means may have `@.manufacturer` instead.",
            title="BOM Authors",
        ),
    ] = None
    component: Annotated[
        Component | None,
        Field(description="The component that the BOM describes.", title="Component"),
    ] = None
    manufacture: Annotated[
        OrganizationalEntity | None,
        Field(
            description="[Deprecated] This will be removed in a future version. Use the `@.component.manufacturer` instead.\nThe organization that manufactured the component that the BOM describes.",
            title="Component Manufacture (legacy)",
        ),
    ] = None
    supplier: Annotated[
        OrganizationalEntity | None,
        Field(
            description=" The organization that supplied the component that the BOM describes. The supplier may often be the manufacturer, but may also be a distributor or repackager.",
            title="Supplier",
        ),
    ] = None
    licenses: Annotated[
        LicenseChoice | None,
        Field(
            description="The license information for the BOM document.\nThis may be different from the license(s) of the component(s) that the BOM describes.",
            title="BOM License(s)",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None
    distribution_constraints: Annotated[
        DistributionConstraints | None,
        Field(
            alias="distributionConstraints",
            description="Conditions and constraints governing the sharing and distribution of the data or components described by this BOM.",
            title="Distribution Constraints",
        ),
    ] = None


class Pedigree(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    ancestors: Annotated[
        list[Component] | None,
        Field(
            description="Describes zero or more components in which a component is derived from. This is commonly used to describe forks from existing projects where the forked version contains an ancestor node containing the original component it was forked from. For example, Component A is the original component. Component B is the component being used and documented in the BOM. However, Component B contains a pedigree node with a single ancestor documenting Component A - the original component from which Component B is derived from.",
            title="Ancestors",
        ),
    ] = None
    descendants: Annotated[
        list[Component] | None,
        Field(
            description="Descendants are the exact opposite of ancestors. This provides a way to document all forks (and their forks) of an original or root component.",
            title="Descendants",
        ),
    ] = None
    variants: Annotated[
        list[Component] | None,
        Field(
            description="Variants describe relations where the relationship between the components is not known. For example, if Component A contains nearly identical code to Component B. They are both related, but it is unclear if one is derived from the other, or if they share a common ancestor.",
            title="Variants",
        ),
    ] = None
    commits: Annotated[
        list[Commit] | None,
        Field(
            description="A list of zero or more commits which provide a trail describing how the component deviates from an ancestor, descendant, or variant.",
            title="Commits",
        ),
    ] = None
    patches: Annotated[
        list[Patch] | None,
        Field(
            description="A list of zero or more patches describing how the component deviates from an ancestor, descendant, or variant. Patches may be complementary to commits or may be used in place of commits.",
            title="Patches",
        ),
    ] = None
    notes: Annotated[
        str | None,
        Field(
            description="Notes, observations, and other non-structured commentary describing the components pedigree.",
            title="Notes",
        ),
    ] = None


class Component(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[
        Type,
        Field(
            description="Specifies the type of component. For software components, classify as application if no more specific appropriate classification is available or cannot be determined for the component.",
            examples=["library"],
            title="Component Type",
        ),
    ]
    mime_type: Annotated[
        str | None,
        Field(
            alias="mime-type",
            description="The mime-type of the component. When used on file components, the mime-type can provide additional context about the kind of file being represented, such as an image, font, or executable. Some library or framework components may also have an associated mime-type.",
            examples=["image/jpeg"],
            pattern="^[-+a-z0-9.]+/[-+a-z0-9.]+$",
            title="Mime-Type",
        ),
    ] = None
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the component elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ] = None
    supplier: Annotated[
        OrganizationalEntity | None,
        Field(
            description=" The organization that supplied the component. The supplier may often be the manufacturer, but may also be a distributor or repackager.",
            title="Component Supplier",
        ),
    ] = None
    manufacturer: Annotated[
        OrganizationalEntity | None,
        Field(
            description="The organization that created the component.\nManufacturer is common in components created through automated processes. Components created through manual means may have `@.authors` instead.",
            title="Component Manufacturer",
        ),
    ] = None
    authors: Annotated[
        list[OrganizationalContact] | None,
        Field(
            description="The person(s) who created the component.\nAuthors are common in components created through manual processes. Components created through automated means may have `@.manufacturer` instead.",
            title="Component Authors",
        ),
    ] = None
    author: Annotated[
        str | None,
        Field(
            description="[Deprecated] This will be removed in a future version. Use `@.authors` or `@.manufacturer` instead.\nThe person(s) or organization(s) that authored the component",
            examples=["Acme Inc"],
            title="Component Author (legacy)",
        ),
    ] = None
    publisher: Annotated[
        str | None,
        Field(
            description="The person(s) or organization(s) that published the component",
            examples=["Acme Inc"],
            title="Component Publisher",
        ),
    ] = None
    group: Annotated[
        str | None,
        Field(
            description="The grouping name or identifier. This will often be a shortened, single name of the company or project that produced the component, or the source package or domain name. Whitespace and special characters should be avoided. Examples include: apache, org.apache.commons, and apache.org.",
            examples=["com.acme"],
            title="Component Group",
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description="The name of the component. This will often be a shortened, single name of the component. Examples: commons-lang3 and jquery",
            examples=["tomcat-catalina"],
            title="Component Name",
        ),
    ]
    version: Annotated[
        Version | None,
        Field(
            description="The component version. The version should ideally comply with semantic versioning but is not enforced.\nMust be used exclusively, either 'version' or 'versionRange', but not both.",
            title="Component Version",
        ),
    ] = None
    version_range: Annotated[
        VersionRange | None,
        Field(
            alias="versionRange",
            description="For an external component, this specifies the accepted version range.\nThe value must adhere to the Package URL Version Range syntax (vers), as defined at https://github.com/package-url/vers-spec\nMay only be used if `.isExternal` is set to `true`.\nMust be used exclusively, either 'version' or 'versionRange', but not both.",
            title="Component Version Range",
        ),
    ] = None
    is_external: Annotated[
        bool | None,
        Field(
            alias="isExternal",
            description="Determine whether this component is external.\nAn external component is one that is not part of an assembly, but is expected to be provided by the environment, regardless of the component's `.scope`. This setting can be useful for distinguishing which components are bundled with the product and which can be relied upon to be present in the deployment environment.\nThis may be set to `true` for runtime components only. For `$.metadata.component`, it must be set to `false`.",
            title="Component Is External",
        ),
    ] = False
    description: Annotated[
        str | None,
        Field(
            description="Specifies a description for the component",
            title="Component Description",
        ),
    ] = None
    scope: Annotated[
        Scope | None,
        Field(
            description="Specifies the scope of the component. If scope is not specified, 'required' scope SHOULD be assumed by the consumer of the BOM.",
            title="Component Scope",
        ),
    ] = "required"
    hashes: Annotated[
        list[Hash] | None,
        Field(description="The hashes of the component.", title="Component Hashes"),
    ] = None
    licenses: Annotated[LicenseChoice | None, Field(title="Component License(s)")] = None
    copyright: Annotated[
        str | None,
        Field(
            description="A copyright notice informing users of the underlying claims to copyright ownership in a published work.",
            examples=["Acme Inc"],
            title="Component Copyright",
        ),
    ] = None
    patent_assertions: Annotated[
        PatentAssertions | None,
        Field(alias="patentAssertions", title="Component Patent(s)"),
    ] = None
    cpe: Annotated[
        str | None,
        Field(
            description="Asserts the identity of the component using CPE. The CPE must conform to the CPE 2.2 or 2.3 specification. See [https://nvd.nist.gov/products/cpe](https://nvd.nist.gov/products/cpe). Refer to `@.evidence.identity` to optionally provide evidence that substantiates the assertion of the component's identity.",
            examples=["cpe:2.3:a:acme:component_framework:-:*:*:*:*:*:*:*"],
            title="Common Platform Enumeration (CPE)",
        ),
    ] = None
    purl: Annotated[
        str | None,
        Field(
            description="Asserts the identity of the component using package-url (purl). The purl, if specified, must be valid and conform to the specification defined at: [https://github.com/package-url/purl-spec](https://github.com/package-url/purl-spec). Refer to `@.evidence.identity` to optionally provide evidence that substantiates the assertion of the component's identity.",
            examples=["pkg:maven/com.acme/tomcat-catalina@9.0.14?packaging=jar"],
            title="Package URL (purl)",
        ),
    ] = None
    omnibor_id: Annotated[
        list[str] | None,
        Field(
            alias="omniborId",
            description="Asserts the identity of the component using the OmniBOR Artifact ID. The OmniBOR, if specified, must be valid and conform to the specification defined at: [https://www.iana.org/assignments/uri-schemes/prov/gitoid](https://www.iana.org/assignments/uri-schemes/prov/gitoid). Refer to `@.evidence.identity` to optionally provide evidence that substantiates the assertion of the component's identity.",
            examples=[
                "gitoid:blob:sha1:a94a8fe5ccb19ba61c4c0873d391e987982fbbd3",
                "gitoid:blob:sha256:9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
            ],
            title="OmniBOR Artifact Identifier (gitoid)",
        ),
    ] = None
    swhid: Annotated[
        list[str] | None,
        Field(
            description="Asserts the identity of the component using the Software Heritage persistent identifier (SWHID). The SWHID, if specified, must be valid and conform to the specification defined at: [https://docs.softwareheritage.org/devel/swh-model/persistent-identifiers.html](https://docs.softwareheritage.org/devel/swh-model/persistent-identifiers.html). Refer to `@.evidence.identity` to optionally provide evidence that substantiates the assertion of the component's identity.",
            examples=["swh:1:cnt:94a9ed024d3859793618152ea559a168bbcbb5e2"],
            title="Software Heritage Identifier",
        ),
    ] = None
    swid: Annotated[
        Swid | None,
        Field(
            description="Asserts the identity of the component using [ISO-IEC 19770-2 Software Identification (SWID) Tags](https://www.iso.org/standard/65666.html). Refer to `@.evidence.identity` to optionally provide evidence that substantiates the assertion of the component's identity.",
            title="SWID Tag",
        ),
    ] = None
    modified: Annotated[
        bool | None,
        Field(
            description="[Deprecated] This will be removed in a future version. Use the pedigree element instead to supply information on exactly how the component was modified.\nA boolean value indicating if the component has been modified from the original. A value of true indicates the component is a derivative of the original. A value of false indicates the component has not been modified from the original.",
            title="Component Modified From Original",
        ),
    ] = None
    pedigree: Annotated[
        Pedigree | None,
        Field(
            description="Component pedigree is a way to document complex supply chain scenarios where components are created, distributed, modified, redistributed, combined with other components, etc. Pedigree supports viewing this complex chain from the beginning, the end, or anywhere in the middle. It also provides a way to document variants where the exact relation may not be known.",
            title="Component Pedigree",
        ),
    ] = None
    external_references: Annotated[
        list[ExternalReference] | None,
        Field(
            alias="externalReferences",
            description="External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.",
            title="External References",
        ),
    ] = None
    components: Annotated[
        list[Component] | None,
        Field(
            description="A list of software and hardware components included in the parent component. This is not a dependency tree. It provides a way to specify a hierarchical representation of component assemblies, similar to system &#8594; subsystem &#8594; parts assembly in physical supply chains.",
            title="Components",
        ),
    ] = None
    evidence: Annotated[
        ComponentEvidence | None,
        Field(
            description="Provides the ability to document evidence collected through various forms of extraction or analysis.",
            title="Evidence",
        ),
    ] = None
    release_notes: Annotated[
        ReleaseNotes | None,
        Field(
            alias="releaseNotes",
            description="Specifies release notes.",
            title="Release notes",
        ),
    ] = None
    model_card: Annotated[ModelCard | None, Field(alias="modelCard", title="AI/ML Model Card")] = None
    data: Annotated[
        list[ComponentData] | None,
        Field(
            description="This object SHOULD be specified for any component of type `data` and must not be specified for other component types.",
            title="Data",
        ),
    ] = None
    crypto_properties: Annotated[
        CryptoProperties | None,
        Field(alias="cryptoProperties", title="Cryptographic Properties"),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None
    tags: Annotated[Tags | None, Field(title="Tags")] = None
    signature: Annotated[
        Signature | None,
        Field(
            description="Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).",
            title="Signature",
        ),
    ] = None


class Vulnerability(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the vulnerability elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ] = None
    id: Annotated[
        str | None,
        Field(
            description="The identifier that uniquely identifies the vulnerability.",
            examples=[
                "CVE-2021-39182",
                "GHSA-35m5-8cvj-8783",
                "SNYK-PYTHON-ENROCRYPT-1912876",
            ],
            title="ID",
        ),
    ] = None
    source: Annotated[
        VulnerabilitySource | None,
        Field(description="The source that published the vulnerability."),
    ] = None
    references: Annotated[
        list[Reference] | None,
        Field(
            description="Zero or more pointers to vulnerabilities that are the equivalent of the vulnerability specified. Often times, the same vulnerability may exist in multiple sources of vulnerability intelligence, but have different identifiers. References provide a way to correlate vulnerabilities across multiple sources of vulnerability intelligence.",
            title="References",
        ),
    ] = None
    ratings: Annotated[
        list[Rating] | None,
        Field(description="List of vulnerability ratings", title="Ratings"),
    ] = None
    cwes: Annotated[
        list[Cwe] | None,
        Field(
            description="List of Common Weaknesses Enumerations (CWEs) codes that describes this vulnerability.",
            examples=[399],
            title="CWEs",
        ),
    ] = None
    description: Annotated[
        str | None,
        Field(
            description="A description of the vulnerability as provided by the source.",
            title="Description",
        ),
    ] = None
    detail: Annotated[
        str | None,
        Field(
            description="If available, an in-depth description of the vulnerability as provided by the source organization. Details often include information useful in understanding root cause.",
            title="Details",
        ),
    ] = None
    recommendation: Annotated[
        str | None,
        Field(
            description="Recommendations of how the vulnerability can be remediated or mitigated.",
            title="Recommendation",
        ),
    ] = None
    workaround: Annotated[
        str | None,
        Field(
            description="A bypass, usually temporary, of the vulnerability that reduces its likelihood and/or impact. Workarounds often involve changes to configuration or deployments.",
            title="Workarounds",
        ),
    ] = None
    proof_of_concept: Annotated[
        ProofOfConcept | None,
        Field(
            alias="proofOfConcept",
            description="Evidence used to reproduce the vulnerability.",
            title="Proof of Concept",
        ),
    ] = None
    advisories: Annotated[
        list[Advisory] | None,
        Field(
            description="Published advisories of the vulnerability if provided.",
            title="Advisories",
        ),
    ] = None
    created: Annotated[
        AwareDatetime | None,
        Field(
            description="The date and time (timestamp) when the vulnerability record was created in the vulnerability database.",
            title="Created",
        ),
    ] = None
    published: Annotated[
        AwareDatetime | None,
        Field(
            description="The date and time (timestamp) when the vulnerability record was first published.",
            title="Published",
        ),
    ] = None
    updated: Annotated[
        AwareDatetime | None,
        Field(
            description="The date and time (timestamp) when the vulnerability record was last updated.",
            title="Updated",
        ),
    ] = None
    rejected: Annotated[
        AwareDatetime | None,
        Field(
            description="The date and time (timestamp) when the vulnerability record was rejected (if applicable).",
            title="Rejected",
        ),
    ] = None
    credits: Annotated[
        Credits | None,
        Field(
            description="Individuals or organizations credited with the discovery of the vulnerability.",
            title="Credits",
        ),
    ] = None
    tools: Annotated[
        Tools | list[Tool] | None,
        Field(
            description="The tool(s) used to identify, confirm, or score the vulnerability.",
            title="Tools",
        ),
    ] = None
    analysis: Annotated[
        Analysis | None,
        Field(
            description="An assessment of the impact and exploitability of the vulnerability.",
            title="Impact Analysis",
        ),
    ] = None
    affects: Annotated[
        list[Affect] | None,
        Field(
            description="The components or services that are affected by the vulnerability.",
            title="Affects",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


class Annotator(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        OrganizationalEntity,
        Field(description="The organization that created the annotation"),
    ]
    individual: Annotated[
        OrganizationalContact | None,
        Field(description="The person that created the annotation"),
    ] = None
    component: Annotated[
        Component | None,
        Field(description="The tool or component that created the annotation"),
    ] = None
    service: Annotated[Service | None, Field(description="The service that created the annotation")] = None


class Annotator1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        OrganizationalEntity | None,
        Field(description="The organization that created the annotation"),
    ] = None
    individual: Annotated[
        OrganizationalContact,
        Field(description="The person that created the annotation"),
    ]
    component: Annotated[
        Component | None,
        Field(description="The tool or component that created the annotation"),
    ] = None
    service: Annotated[Service | None, Field(description="The service that created the annotation")] = None


class Annotator2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        OrganizationalEntity | None,
        Field(description="The organization that created the annotation"),
    ] = None
    individual: Annotated[
        OrganizationalContact | None,
        Field(description="The person that created the annotation"),
    ] = None
    component: Annotated[
        Component,
        Field(description="The tool or component that created the annotation"),
    ]
    service: Annotated[Service | None, Field(description="The service that created the annotation")] = None


class Annotator3(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        OrganizationalEntity | None,
        Field(description="The organization that created the annotation"),
    ] = None
    individual: Annotated[
        OrganizationalContact | None,
        Field(description="The person that created the annotation"),
    ] = None
    component: Annotated[
        Component | None,
        Field(description="The tool or component that created the annotation"),
    ] = None
    service: Annotated[Service, Field(description="The service that created the annotation")]


class Annotations(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the annotation elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ] = None
    subjects: Annotated[
        list[RefLinkType | BomLinkElementType],
        Field(
            description="The object in the BOM identified by its bom-ref. This is often a component or service, but may be any object type supporting bom-refs.",
            title="Subjects",
        ),
    ]
    annotator: Annotated[
        Annotator | Annotator1 | Annotator2 | Annotator3,
        Field(
            description="The organization, person, component, or service which created the textual content of the annotation.",
            title="Annotator",
        ),
    ]
    timestamp: Annotated[
        AwareDatetime,
        Field(
            description="The date and time (timestamp) when the annotation was created.",
            title="Timestamp",
        ),
    ]
    text: Annotated[str, Field(description="The textual content of the annotation.", title="Text")]
    signature: Annotated[
        Signature | None,
        Field(
            description="Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).",
            title="Signature",
        ),
    ] = None


class Formula(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType | None,
        Field(
            alias="bom-ref",
            description="An identifier which can be used to reference the formula elsewhere in the BOM. Every `bom-ref` must be unique within the BOM.\nValue SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.",
            title="BOM Reference",
        ),
    ] = None
    components: Annotated[
        list[Component] | None,
        Field(
            description="Transient components that are used in tasks that constitute one or more of this formula's workflows",
            title="Components",
        ),
    ] = None
    services: Annotated[
        list[Service] | None,
        Field(
            description="Transient services that are used in tasks that constitute one or more of this formula's workflows",
            title="Services",
        ),
    ] = None
    workflows: Annotated[
        list[Workflow] | None,
        Field(
            description="List of workflows that can be declared to accomplish specific orchestrated goals and independently triggered.",
            title="Workflows",
        ),
    ] = None
    properties: Annotated[
        list[Property] | None,
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.",
            title="Properties",
        ),
    ] = None


Service.model_rebuild()
Targets.model_rebuild()
CyclonedxBillOfMaterialsStandard.model_rebuild()
Tools.model_rebuild()
Metadata.model_rebuild()
Pedigree.model_rebuild()
