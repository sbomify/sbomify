{# Alpine.js components for contact profile forms - shared between team settings and component metadata #}
<script>
    function initAlpineComponents() {
        if (!window.Alpine) {
            document.addEventListener('alpine:init', initAlpineComponents);
            return;
        }

        if (window._alpineContactProfilesInitialized) return;
        window._alpineContactProfilesInitialized = true;

    Alpine.data('contactProfileForm', (entitiesPrefix) => ({
        entitiesPrefix: entitiesPrefix,
        visibleEntitiesCount: 0,
        manufacturerCount: 0,
        supplierCount: 0,
        isInitialized: false,
        
        init() {
            // Wait for Alpine to fully initialize the component
            this.$nextTick(() => {
                this.isInitialized = true;
                this.updateCounts();
            });
        },
        
        initForm() {
            // Legacy method - can be removed
            this.updateCounts();
        },
        
        get hasErrors() {
            return document.querySelectorAll('.is-invalid').length > 0;
        },

        addEntity() {
            const container = document.getElementById('entities-container');
            const totalFormsInput = document.querySelector(`input[name="${this.entitiesPrefix}-TOTAL_FORMS"]`);
            const currentCount = parseInt(totalFormsInput.value);
            
            const template = document.getElementById('entity-template').content.cloneNode(true);
            const newRow = document.createElement('div');
            newRow.appendChild(template);
            
            const newHtml = newRow.innerHTML.replace(/__prefix__/g, currentCount);
            newRow.innerHTML = newHtml;

            const entityPrefix = `${this.entitiesPrefix}-${currentCount}`;
            const contactPrefix = `${entityPrefix}-contacts`;
            
            const mgmtDiv = document.createElement('div');
            mgmtDiv.innerHTML = `
                <input type="hidden" name="${contactPrefix}-TOTAL_FORMS" value="0" id="id_${contactPrefix}-TOTAL_FORMS">
                <input type="hidden" name="${contactPrefix}-INITIAL_FORMS" value="0" id="id_${contactPrefix}-INITIAL_FORMS">
                <input type="hidden" name="${contactPrefix}-MIN_NUM_FORMS" value="0" id="id_${contactPrefix}-MIN_NUM_FORMS">
                <input type="hidden" name="${contactPrefix}-MAX_NUM_FORMS" value="1000" id="id_${contactPrefix}-MAX_NUM_FORMS">
            `;
            const contactsList = newRow.querySelector('.contacts-list');
            if (contactsList) {
                contactsList.insertBefore(mgmtDiv, contactsList.firstChild);
            }

            container.appendChild(newRow.firstElementChild);
            const newEntityEl = container.lastElementChild;
            
            totalFormsInput.value = currentCount + 1;
            
            if (window.Alpine) {
                Alpine.initTree(newEntityEl);
            }
            
            this.updateCounts();
            
            setTimeout(() => {
                if (newEntityEl) {
                    const alpineData = Alpine.$data(newEntityEl);
                    if (alpineData) {
                        alpineData.editing = true;
                    }
                    newEntityEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }, 50);
        },
        
        submitForm(e) {
            e.preventDefault();
            
            // Find the form - try multiple strategies
            let form = null;
            if (this.$el) {
                form = this.$el.querySelector('form');
            }
            if (!form && e.target) {
                form = e.target.closest('form');
            }
            if (!form) {
                form = document.querySelector('.profile-form form');
            }
            // Also check for component metadata form container
            if (!form) {
                form = document.querySelector('.component-metadata-formset form');
            }
            
            if (!form) {
                console.error('[submitForm] Could not find form element');
                return;
            }
            
            // First, remove 'required' from deleted/hidden items before validation
            const isElementVisible = (el) => {
                if (!el) return false;
                const style = window.getComputedStyle(el);
                return style.display !== 'none' && 
                       style.visibility !== 'hidden' && 
                       el.offsetParent !== null;
            };
            
            document.querySelectorAll('.entity-card').forEach(card => {
                const deleteInput = card.querySelector('input[name$="-DELETE"]');
                const isDeleted = deleteInput && (deleteInput.value === 'true' || deleteInput.value === true);
                const isVisible = isElementVisible(card);
                
                if (isDeleted || !isVisible) {
                    card.querySelectorAll('input[required]').forEach(input => {
                        input.removeAttribute('required');
                    });
                }
            });
            
            document.querySelectorAll('.contact-card').forEach(card => {
                const deleteInput = card.querySelector('input[name$="-DELETE"]');
                const isDeleted = deleteInput && (deleteInput.value === 'true' || deleteInput.value === true);
                const isVisible = isElementVisible(card);
                
                if (isDeleted || !isVisible) {
                    card.querySelectorAll('input[required]').forEach(input => {
                        input.removeAttribute('required');
                    });
                }
            });
            
            // Mark entities as touched for custom validation display
            document.querySelectorAll('.entity-card').forEach(card => {
                const alpineData = Alpine.$data(card);
                if (alpineData && !alpineData.deleted) {
                    alpineData.touched = true;
                    alpineData.contactsTouched = true;
                    alpineData.updateContactCount();
                }
            });
            
            // ORDERED VALIDATION - Check each field in specific order
            
            // 1. Validate Profile Name first (only for contact profile forms, not component metadata)
            const profileNameInput = form.querySelector('input[name="name"]');
            if (profileNameInput && !profileNameInput.checkValidity()) {
                profileNameInput.reportValidity();
                profileNameInput.focus();
                return;
            }
            
            // 2. Validate Entities in order (role, name, email, contacts)
            const entityCards = Array.from(document.querySelectorAll('.entity-card'));
            for (const card of entityCards) {
                const alpineData = Alpine.$data(card);
                if (!alpineData || alpineData.deleted) continue;
                
                // 2a. Check entity role (at least one must be selected)
                if (!alpineData.isManufacturer && !alpineData.isSupplier && !alpineData.isAuthor) {
                    card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    return;
                }
                
                // 2b. Check entity name (only required for non-author-only entities)
                if (!alpineData.isAuthorOnly) {
                    const nameInput = card.querySelector('input[name$="-name"]');
                    if (nameInput && !nameInput.checkValidity()) {
                        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        nameInput.reportValidity();
                        nameInput.focus();
                        return;
                    }
                    
                    // 2c. Check entity email (only required for non-author-only entities)
                    const emailInput = card.querySelector('input[name$="-email"]');
                    if (emailInput && !emailInput.checkValidity()) {
                        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        emailInput.reportValidity();
                        emailInput.focus();
                        return;
                    }
                }
                
                // 2d. Check entity has at least one contact
                if (alpineData.activeContactsCount === 0) {
                    alpineData.editing = true;
                    card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    return;
                }
                
                // 2e. Validate contacts within this entity
                const contactCards = card.querySelectorAll('.contact-card');
                for (const contactCard of contactCards) {
                    const deleteInput = contactCard.querySelector('input[name$="-DELETE"]');
                    const isDeleted = deleteInput && (deleteInput.value === 'true' || deleteInput.value === true);
                    if (isDeleted || !isElementVisible(contactCard)) continue;
                    
                    // Check contact name
                    const contactName = contactCard.querySelector('input[name$="-name"]');
                    if (contactName && !contactName.checkValidity()) {
                        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        contactName.reportValidity();
                        contactName.focus();
                        return;
                    }
                    
                    // Check contact email
                    const contactEmail = contactCard.querySelector('input[name$="-email"]');
                    if (contactEmail && !contactEmail.checkValidity()) {
                        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        contactEmail.reportValidity();
                        contactEmail.focus();
                        return;
                    }
                }
            }
            
            // All validation passed, trigger HTMX submission
            htmx.trigger(form, 'htmx:submit');
        },
        
        updateCounts() {
            // Performance note: This iterates all cards but is acceptable since
            // CycloneDX limits profiles to 1 manufacturer + 1 supplier (typically 1-2 entities)
            let visibleEntities = 0;
            let mfgCount = 0;
            let supCount = 0;
            
            document.querySelectorAll('.entity-card').forEach(card => {
                const alpineData = Alpine.$data(card);
                if (alpineData && !alpineData.deleted) {
                    visibleEntities++;
                    // Only count roles for saved entities (not new ones being edited)
                    if (!alpineData.isNew || !alpineData.editing) {
                        if (alpineData.isManufacturer) mfgCount++;
                        if (alpineData.isSupplier) supCount++;
                    }
                }
            });
            
            this.visibleEntitiesCount = visibleEntities;
            this.manufacturerCount = mfgCount;
            this.supplierCount = supCount;
        }
    }));

    Alpine.data('contactEntity', (prefix) => ({
        name: '',
        email: '',
        phone: '',
        address: '',
        websites: '',
        isManufacturer: true,
        isSupplier: true,
        isAuthor: true,
        deleted: false,
        activeContactsCount: 0,
        contacts: [],  // Array of {name, isAuthor, isSecurityContact, isTechnicalContact}
        touched: false,
        contactsTouched: false,
        editing: false,
        isNew: false,
        snapshot: null,
        
        // Computed: is this an author-only entity (no manufacturer/supplier)?
        get isAuthorOnly() {
            return this.isAuthor && !this.isManufacturer && !this.isSupplier;
        },
        
        init() {
            const nameInput = document.querySelector(`input[name="${prefix}-name"]`);
            if (nameInput) this.name = nameInput.value.trim();
            
            const emailInput = document.querySelector(`input[name="${prefix}-email"]`);
            if (emailInput) this.email = emailInput.value.trim();

            const phoneInput = document.querySelector(`input[name="${prefix}-phone"]`);
            if (phoneInput) this.phone = phoneInput.value.trim();

            const addressInput = document.querySelector(`textarea[name="${prefix}-address"]`);
            if (addressInput) this.address = addressInput.value.trim();

            const webInput = document.querySelector(`textarea[name="${prefix}-website_urls_text"]`);
            if (webInput) this.websites = webInput.value;

            // Read initial roles from checkboxes (scoped to this component)
            const mfgCheckbox = this.$root.querySelector(`input[name="${prefix}-is_manufacturer"]`);
            const supCheckbox = this.$root.querySelector(`input[name="${prefix}-is_supplier"]`);
            const authorCheckbox = this.$root.querySelector(`input[name="${prefix}-is_author"]`);
            
            this.isNew = !this.name && !this.isAuthor;
            
            if (!this.isNew) {
                // For existing entities, read from checkboxes
                if (mfgCheckbox) {
                    this.isManufacturer = mfgCheckbox.checked;
                }
                if (supCheckbox) {
                    this.isSupplier = supCheckbox.checked;
                }
                if (authorCheckbox) {
                    this.isAuthor = authorCheckbox.checked;
                }
            } else {
                // For new entities, default to available roles
                const parent = this.$el.closest('.profile-form') || this.$el.closest('.component-metadata-formset');
                const formData = parent ? Alpine.$data(parent) : null;
                if (formData && (formData.manufacturerCount > 0 || formData.supplierCount > 0)) {
                    // If there are existing entities, only default to available roles
                    this.isManufacturer = formData.manufacturerCount < 1;
                    this.isSupplier = formData.supplierCount < 1;
                } else {
                    // First entity on profile OR no form data: default both to true
                    this.isManufacturer = true;
                    this.isSupplier = true;
                }
                this.isAuthor = true;
            }
            
            this.$watch('deleted', () => {
                window.dispatchEvent(new CustomEvent('update-counts')); 
            });
            
            this.$watch('isManufacturer', () => {
                window.dispatchEvent(new CustomEvent('update-counts'));
            });
            
            this.$watch('isSupplier', () => {
                window.dispatchEvent(new CustomEvent('update-counts'));
            });
            
            this.$watch('isAuthor', () => {
                window.dispatchEvent(new CustomEvent('update-counts'));
            });
            
            this.$watch('editing', (value) => {
                if (value && !this.snapshot) {
                    this.createSnapshot();
                }
                // Update counts when entity is saved (editing becomes false)
                if (!value) {
                    window.dispatchEvent(new CustomEvent('update-counts'));
                }
            });
            
            this.updateContactCount();
            
            // Trigger count update after entity initialization
            this.$nextTick(() => {
                window.dispatchEvent(new CustomEvent('update-counts'));
            });
        },

        get canSelectManufacturer() {
            const parent = this.$el.closest('.profile-form') || this.$el.closest('.component-metadata-formset');
            if (!parent) return true;
            const formData = Alpine.$data(parent);
            if (!formData) return true;
            // For new entities: only allow if no manufacturer exists
            // For existing entities: allow if no other manufacturer OR this entity is already the manufacturer
            if (this.isNew) {
                return formData.manufacturerCount < 1;
            }
            return formData.manufacturerCount < 1 || this.isManufacturer;
        },

        get canSelectSupplier() {
            const parent = this.$el.closest('.profile-form') || this.$el.closest('.component-metadata-formset');
            if (!parent) return true;
            const formData = Alpine.$data(parent);
            if (!formData) return true;
            // For new entities: only allow if no supplier exists
            // For existing entities: allow if no other supplier OR this entity is already the supplier
            if (this.isNew) {
                return formData.supplierCount < 1;
            }
            return formData.supplierCount < 1 || this.isSupplier;
        },

        get hasErrors() {
            if (this.deleted) return false;
            // At least one role required
            if (!this.isManufacturer && !this.isSupplier && !this.isAuthor) return true;
            // For non-author-only entities, name and email are required
            if (!this.isAuthorOnly) {
                if (!this.name || !this.email || !this.isValidEmail(this.email)) return true;
            }
            // Contacts always required
            return this.activeContactsCount === 0;
        },

        isValidEmail(email) {
            if (!email) return false;
            const input = document.createElement('input');
            input.type = 'email';
            input.value = email;
            return input.checkValidity();
        },

        createSnapshot() {
            this.snapshot = {
                name: this.name,
                email: this.email,
                phone: this.phone,
                address: this.address,
                websites: this.websites,
                isManufacturer: this.isManufacturer,
                isSupplier: this.isSupplier,
                isAuthor: this.isAuthor
            };
        },

        saveEdit() {
            this.touched = true;
            this.contactsTouched = true;
            
            const nameInput = document.querySelector(`input[name="${prefix}-name"]`);
            const emailInput = document.querySelector(`input[name="${prefix}-email"]`);
            
            // For non-author-only entities, name and email are required
            if (!this.isAuthorOnly) {
                // Validate name
                if (nameInput && !this.name) {
                    nameInput.focus();
                    nameInput.reportValidity();
                    return;
                }
                
                // Validate email - required
                if (emailInput) {
                    // Sync Alpine value to DOM
                    emailInput.value = this.email || '';
                    
                    if (!this.email) {
                        emailInput.setCustomValidity('Please enter an email address');
                        emailInput.focus();
                        emailInput.reportValidity();
                        // Clear custom validity on input
                        const clearValidity = () => {
                            emailInput.setCustomValidity('');
                            emailInput.removeEventListener('input', clearValidity);
                        };
                        emailInput.addEventListener('input', clearValidity);
                        return;
                    }
                    
                    // Validate email format
                    if (!this.isValidEmail(this.email)) {
                        emailInput.setCustomValidity('Please enter a valid email address (e.g., contact@example.com)');
                        emailInput.focus();
                        emailInput.reportValidity();
                        // Clear custom validity on input
                        const clearValidity = () => {
                            emailInput.setCustomValidity('');
                            emailInput.removeEventListener('input', clearValidity);
                        };
                        emailInput.addEventListener('input', clearValidity);
                        return;
                    }
                    
                    // Clear any previous custom validity
                    emailInput.setCustomValidity('');
                }
            }
            
            // Validate at least one role is selected
            if (!this.isManufacturer && !this.isSupplier && !this.isAuthor) {
                this.touched = true;
                const roleSection = this.$root.querySelector('.role-selection');
                if (roleSection) {
                    roleSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    // Find first checkbox to show tooltip
                    const firstCheckbox = roleSection.querySelector('input[type="checkbox"]');
                    if (firstCheckbox) {
                        firstCheckbox.setCustomValidity('Please select at least one role (Manufacturer, Supplier, or Author)');
                        firstCheckbox.focus();
                        firstCheckbox.reportValidity();
                        const clearValidity = () => {
                            firstCheckbox.setCustomValidity('');
                            firstCheckbox.removeEventListener('change', clearValidity);
                        };
                        firstCheckbox.addEventListener('change', clearValidity);
                    }
                }
                return;
            }
            
            // CycloneDX requirement: at least one contact per entity
            this.updateContactCount();
            if (this.activeContactsCount === 0) {
                const addContactBtn = this.$root.querySelector('.add-contact-btn');
                if (addContactBtn) {
                    addContactBtn.setCustomValidity('Please add at least one contact person for this entity');
                    addContactBtn.focus();
                    addContactBtn.reportValidity();
                    const clearValidity = () => {
                        addContactBtn.setCustomValidity('');
                        addContactBtn.removeEventListener('click', clearValidity);
                    };
                    addContactBtn.addEventListener('click', clearValidity);
                }
                return;
            }
            
            const contactPrefix = `${prefix}-contacts`;
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            let hasContactError = false;
            
            document.querySelectorAll(`input[name^="${contactPrefix}-"][name$="-name"]`).forEach(contactNameInput => {
                if (hasContactError) return;
                
                const contactCard = contactNameInput.closest('.contact-card');
                if (!contactCard) return;
                
                const contactEmailInput = contactCard.querySelector('input[name$="-email"]');
                const deleteInput = contactCard.querySelector('input[name$="-DELETE"]');
                
                const isDeleted = deleteInput && (deleteInput.value === 'true' || deleteInput.value === true);
                const isHidden = contactCard.style.display === 'none' || !contactCard.offsetParent;
                
                if (isDeleted || isHidden) return;
                
                const contactNameValue = contactNameInput.value.trim();
                const contactEmailValue = contactEmailInput ? contactEmailInput.value.trim() : '';
                
                // Validate name is required
                if (!contactNameValue) {
                    contactNameInput.setCustomValidity('Name is required for this contact');
                    contactNameInput.focus();
                    contactNameInput.reportValidity();
                    const clearValidity = () => {
                        contactNameInput.setCustomValidity('');
                        contactNameInput.removeEventListener('input', clearValidity);
                    };
                    contactNameInput.addEventListener('input', clearValidity);
                    hasContactError = true;
                    return;
                }
                
                // Validate email is required
                if (!contactEmailValue) {
                    contactEmailInput.setCustomValidity('Email is required for this contact');
                    contactEmailInput.focus();
                    contactEmailInput.reportValidity();
                    const clearValidity = () => {
                        contactEmailInput.setCustomValidity('');
                        contactEmailInput.removeEventListener('input', clearValidity);
                    };
                    contactEmailInput.addEventListener('input', clearValidity);
                    hasContactError = true;
                    return;
                }
                
                // Validate email format
                if (!emailRegex.test(contactEmailValue)) {
                    contactEmailInput.setCustomValidity('Please enter a valid email address');
                    contactEmailInput.focus();
                    contactEmailInput.reportValidity();
                    const clearValidity = () => {
                        contactEmailInput.setCustomValidity('');
                        contactEmailInput.removeEventListener('input', clearValidity);
                    };
                    contactEmailInput.addEventListener('input', clearValidity);
                    hasContactError = true;
                    return;
                }
                
                // Clear any previous validity
                contactNameInput.setCustomValidity('');
                if (contactEmailInput) {
                    contactEmailInput.setCustomValidity('');
                }
            });
            
            if (hasContactError) {
                return;
            }
            
            document.querySelectorAll(`input[name^="${contactPrefix}-"][name$="-name"]`).forEach(nameInput => {
                const contactCard = nameInput.closest('.contact-card');
                if (!contactCard) return;
                
                const emailInput = contactCard.querySelector('input[name$="-email"]');
                const deleteInput = contactCard.querySelector('input[name$="-DELETE"]');
                
                const nameValue = nameInput.value.trim();
                const emailValue = emailInput ? emailInput.value.trim() : '';
                const isDeleted = deleteInput && (deleteInput.value === 'true' || deleteInput.value === true);
                const isHidden = contactCard.style.display === 'none' || !contactCard.offsetParent;
                
                if (!nameValue && !emailValue && !isDeleted) {
                    if (deleteInput) {
                        deleteInput.value = 'true';
                    }
                    contactCard.querySelectorAll('input[required]').forEach(input => {
                        input.removeAttribute('required');
                    });
                    contactCard.style.display = 'none';
                }
                
                if (isDeleted || isHidden) {
                    contactCard.querySelectorAll('input[required]').forEach(input => {
                        input.removeAttribute('required');
                    });
                }
            });
            
            this.isNew = false;
            this.snapshot = null;
            this.editing = false;
            
            this.$nextTick(() => this.updateContactCount());
        },

        cancelEdit() {
            if (this.snapshot) {
                this.name = this.snapshot.name;
                this.email = this.snapshot.email;
                this.phone = this.snapshot.phone;
                this.address = this.snapshot.address;
                this.websites = this.snapshot.websites;
                this.isManufacturer = this.snapshot.isManufacturer;
                this.isSupplier = this.snapshot.isSupplier;
                this.isAuthor = this.snapshot.isAuthor;
            }
            if (this.isNew) {
                this.deleted = true;
                document.querySelectorAll(`input[name^="${prefix}-"][required]`).forEach(input => {
                    input.removeAttribute('required');
                });
            }
            this.snapshot = null;
            this.editing = false;
            this.touched = false;
            this.contactsTouched = false;
        },

        removeEntity() {
            const entityName = this.name || 'this entity';
            const self = this;
            window.showDeleteConfirmation(entityName, function() {
                self.deleted = true;
                self.editing = false;
                document.querySelectorAll(`input[name^="${prefix}-"][required]`).forEach(input => {
                    input.removeAttribute('required');
                });
                window.dispatchEvent(new CustomEvent('update-counts'));
            });
        },
        
        addContact() {
             const listContainer = this.$root.querySelector('.contacts-list');
             if (listContainer) {
                 window.addContactRow(listContainer, prefix);
                 this.$nextTick(() => {
                     this.updateContactCount();
                 });
             }
        },

        updateContactCount() {
             if (this.deleted) {
                 this.activeContactsCount = 0;
                 this.contacts = [];
                 return;
             }
             this.$nextTick(() => {
                 const list = this.$root.querySelector('.contacts-list');
                 if (list) {
                     const cards = list.querySelectorAll('.contact-card');
                     let count = 0;
                     const contactsData = [];
                     cards.forEach(card => {
                         const deleteInput = card.querySelector('input[name$="-DELETE"]');
                         if (!deleteInput || deleteInput.value !== 'true') {
                             count++;
                             // Collect contact details from Alpine data or DOM
                             const alpineData = Alpine.$data(card);
                             if (alpineData) {
                                 contactsData.push({
                                     name: alpineData.name || '',
                                     isAuthor: alpineData.isAuthor || false,
                                     isSecurityContact: alpineData.isSecurityContact || false,
                                     isTechnicalContact: alpineData.isTechnicalContact || false
                                 });
                             }
                         }
                     });
                     this.activeContactsCount = count;
                     this.contacts = contactsData;
                 }
             });
        }
    }));
    
    Alpine.data('contactEntry', () => ({
        deleted: false,
        isNew: true,
        name: '',
        email: '',
        isAuthor: false,
        isSecurityContact: false,
        isTechnicalContact: false,
        
        // Check if another security contact exists in the profile
        get securityContactDisabled() {
            // Find if any other contact has security contact checked
            let hasOtherSecurityContact = false;
            document.querySelectorAll('.contact-card').forEach(card => {
                if (card === this.$el) return;
                const alpineData = Alpine.$data(card);
                if (alpineData && !alpineData.deleted && alpineData.isSecurityContact) {
                    hasOtherSecurityContact = true;
                }
            });
            return hasOtherSecurityContact;
        },
        
        get editing() {
            // Access parent entity's editing state
            // Contacts should only be required when their parent entity is in editing mode
            const parent = this.$el.closest('.entity-card');
            if (!parent) return false;
            try {
                const parentData = Alpine.$data(parent);
                return parentData ? parentData.editing : false;
            } catch (e) {
                return false;
            }
        },
        
        init() {
            const nameInput = this.$el.querySelector('input[name$="-name"]');
            const emailInput = this.$el.querySelector('input[name$="-email"]');
            const authorCheckbox = this.$el.querySelector('input[name$="-is_author"]');
            const securityCheckbox = this.$el.querySelector('input[name$="-is_security_contact"]');
            const technicalCheckbox = this.$el.querySelector('input[name$="-is_technical_contact"]');
            
            if (nameInput) {
                this.name = nameInput.value.trim();
                this.isNew = !this.name;
                nameInput.addEventListener('input', () => {
                    this.name = nameInput.value.trim();
                    this.$dispatch('contact-updated');
                });
                nameInput.addEventListener('blur', () => this.checkEmpty());
            }
            
            if (emailInput) {
                this.email = emailInput.value.trim();
                emailInput.addEventListener('input', () => {
                    this.email = emailInput.value.trim();
                });
                emailInput.addEventListener('blur', () => this.checkEmpty());
            }
            
            // Read initial role flags and dispatch updates on change
            if (authorCheckbox) {
                this.isAuthor = authorCheckbox.checked;
                authorCheckbox.addEventListener('change', () => {
                    this.isAuthor = authorCheckbox.checked;
                    this.$dispatch('contact-updated');
                });
            }
            if (securityCheckbox) {
                this.isSecurityContact = securityCheckbox.checked;
                securityCheckbox.addEventListener('change', () => {
                    this.isSecurityContact = securityCheckbox.checked;
                    this.$dispatch('contact-updated');
                });
            }
            if (technicalCheckbox) {
                this.isTechnicalContact = technicalCheckbox.checked;
                technicalCheckbox.addEventListener('change', () => {
                    this.isTechnicalContact = technicalCheckbox.checked;
                    this.$dispatch('contact-updated');
                });
            }
        },
        
        get isEmpty() {
            return !this.name && !this.email;
        },
        
        checkEmpty() {
            if (this.isNew && this.isEmpty) {
                this.$nextTick(() => {
                    setTimeout(() => {
                        if (this.isEmpty && !this.$el.contains(document.activeElement)) {
                            this.removeContact();
                        }
                    }, 200);
                });
            }
        },
        
        removeContact() {
            this.deleted = true;
            this.$el.querySelectorAll('input, select, textarea').forEach(input => {
                input.setCustomValidity('');
                input.removeAttribute('required');
            });
            this.$dispatch('contact-removed');
        }
    }));

    
    Alpine.data('contactProfileList', () => ({
        profiles: [],
        filteredProfiles: [],
        searchQuery: '',
        expandedProfiles: [],
        sortColumn: 'name',
        sortDirection: 'asc',

        init() {
            this.$nextTick(() => {
                const profilesScript = document.getElementById('profiles-data');
                if (profilesScript) {
                    try {
                        this.profiles = JSON.parse(profilesScript.textContent);
                        this.applyFilterAndSort();
                    } catch (e) {
                        this.profiles = [];
                    }
                }

                // Process HTMX after Alpine renders the rows
                this.$nextTick(() => {
                    // HTMX needs to process dynamically bound attributes in x-for templates
                    if (window.htmx && this.$el) {
                        htmx.process(this.$el);
                    }
                });
            });
        },

        sort(column) {
            if (this.sortColumn === column) {
                this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                this.sortColumn = column;
                this.sortDirection = 'asc';
            }
            this.applyFilterAndSort();
        },

        applyFilterAndSort() {
            const query = this.searchQuery.toLowerCase().trim();

            // Filter first
            let result = this.profiles.map(profile => {
                let matches = true;
                if (query) {
                    const nameMatch = profile.name?.toLowerCase().includes(query);
                    const mfgMatch = profile.manufacturer?.name?.toLowerCase().includes(query);
                    const supMatch = profile.supplier?.name?.toLowerCase().includes(query);
                    const authorMatch = (profile.authors || []).some(a =>
                        a.name?.toLowerCase().includes(query)
                    );
                    matches = nameMatch || mfgMatch || supMatch || authorMatch;
                }
                return {...profile, hidden: !matches};
            });

            // Then sort
            result.sort((a, b) => {
                let aVal = a[this.sortColumn];
                let bVal = b[this.sortColumn];

                // Handle null/undefined values
                if (aVal == null) aVal = '';
                if (bVal == null) bVal = '';

                // String comparison (case-insensitive)
                if (typeof aVal === 'string') aVal = aVal.toLowerCase();
                if (typeof bVal === 'string') bVal = bVal.toLowerCase();

                if (aVal < bVal) return this.sortDirection === 'asc' ? -1 : 1;
                if (aVal > bVal) return this.sortDirection === 'asc' ? 1 : -1;
                return 0;
            });

            this.filteredProfiles = result;

            // Reprocess HTMX after filtering/sorting
            this.$nextTick(() => {
                if (window.htmx && this.$el) {
                    htmx.process(this.$el);
                }
            });
        },

        togglePreview(profileId) {
            if (this.expandedProfiles.includes(profileId)) {
                this.expandedProfiles = this.expandedProfiles.filter(id => id !== profileId);
            } else {
                this.expandedProfiles.push(profileId);
            }
        },
        
        filterProfiles() {
            this.applyFilterAndSort();
        },
        
        formatDate(dateStr) {
            if (!dateStr) return '';
            const date = new Date(dateStr);
            return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
        },

        editProfile(profileId) {
            // Get the base URL from the data attribute set on the container
            const container = document.getElementById('contact-profiles-content');
            const baseUrl = container?.dataset.editUrl || '';
            if (baseUrl) {
                const url = baseUrl.replace('0000', profileId);
                htmx.ajax('GET', url, {target: '#contact-profiles-content', swap: 'innerHTML'});
            }
        },

        setDefaultProfile(profileId) {
            const container = document.getElementById('contact-profiles-content');
            const url = container?.dataset.listUrl || '';
            if (url) {
                // Get CSRF token from cookie
                const csrfToken = document.cookie.split('; ')
                    .find(row => row.startsWith('csrftoken='))
                    ?.split('=')[1] || '';

                htmx.ajax('POST', url, {
                    target: '#contact-profiles-content',
                    swap: 'innerHTML',
                    values: { '_method': 'PATCH', 'profile_id': profileId, 'csrfmiddlewaretoken': csrfToken }
                });
            }
        }
    }));
    }

    initAlpineComponents();

    // Immediately initialize any component-metadata-formset or profile-form elements
    // This is necessary when this script is loaded via HTMX - by the time the htmx:afterSettle
    // event fires, this script hasn't set up its listeners yet. So we need to init immediately.
    (function() {
        if (window.Alpine) {
            requestAnimationFrame(() => {
                // Initialize component metadata form container (loaded via HTMX on component page)
                const metadataFormset = document.querySelector('.component-metadata-formset');
                if (metadataFormset && !metadataFormset._x_dataStack) {
                    Alpine.initTree(metadataFormset);
                }
                // Initialize profile form (loaded via HTMX on team settings page)
                const profileForm = document.querySelector('.profile-form');
                if (profileForm && !profileForm._x_dataStack) {
                    Alpine.initTree(profileForm);
                }
            });
        }
    })();

    window.addContactRow = function(container, entityPrefix) {
    // Validate required DOM elements - these checks are for debugging edge cases
    // The UI flow should always provide valid parameters; errors here indicate bugs
    if (!container) {
        console.warn('addContactRow: container element not found');
        return;
    }
    if (!entityPrefix) {
        console.warn('addContactRow: entityPrefix is required');
        return;
    }
    const contactPrefix = `${entityPrefix}-contacts`;
    const entityCard = container.closest('.entity-card');
    if (!entityCard) {
        console.warn('addContactRow: entity-card element not found');
        return;
    }

    let totalInput = container.querySelector(`input[name="${contactPrefix}-TOTAL_FORMS"]`);
    if (!totalInput) {
        totalInput = entityCard.querySelector(`input[name="${contactPrefix}-TOTAL_FORMS"]`);
    }
    
    // Create management form inputs if they don't exist
    if (!totalInput) {
        const mgmtDiv = document.createElement('div');
        mgmtDiv.innerHTML = `
            <input type="hidden" name="${contactPrefix}-TOTAL_FORMS" value="0" id="id_${contactPrefix}-TOTAL_FORMS">
            <input type="hidden" name="${contactPrefix}-INITIAL_FORMS" value="0" id="id_${contactPrefix}-INITIAL_FORMS">
            <input type="hidden" name="${contactPrefix}-MIN_NUM_FORMS" value="0" id="id_${contactPrefix}-MIN_NUM_FORMS">
            <input type="hidden" name="${contactPrefix}-MAX_NUM_FORMS" value="1000" id="id_${contactPrefix}-MAX_NUM_FORMS">
        `;
        container.insertBefore(mgmtDiv, container.firstChild);
        totalInput = container.querySelector(`input[name="${contactPrefix}-TOTAL_FORMS"]`);
    }
    
    // Final safety check after creating management form
    if (!totalInput) {
        console.error('addContactRow: failed to create/find TOTAL_FORMS input');
        return;
    }
    
    if (typeof totalInput.value === 'undefined') {
        console.error('addContactRow: TOTAL_FORMS input has no value to parse');
        return;
    }
    const index = parseInt(totalInput.value);
    const newPrefix = `${contactPrefix}-${index}`;
    
    let newRow = null;
    const existingContact = container.querySelector('.contact-card');
    
    if (existingContact) {
        newRow = existingContact.cloneNode(true);
        newRow.querySelectorAll('input, select, textarea').forEach(input => {
            if (input.name) {
                const nameMatch = input.name.match(/^(.+?)-(name|email|phone|DELETE|id|is_author|is_security_contact|is_technical_contact)$/);
                if (nameMatch) {
                    input.name = `${newPrefix}-${nameMatch[2]}`;
                    input.id = `id_${input.name}`;
                    
                    // Clear the ID field value to prevent duplicate primary key conflicts
                    // when creating new contacts from cloned rows. Empty IDs allow Django
                    // to generate new unique IDs for the new contact instances.
                    if (nameMatch[2] === 'id') {
                        input.value = '';
                    }
                    // Uncheck role checkboxes for new contacts
                    if (['is_author', 'is_security_contact', 'is_technical_contact'].includes(nameMatch[2])) {
                        input.checked = false;
                    }
                }
            }
        });
        newRow.querySelectorAll('input[type="text"], input[type="email"]').forEach(input => {
            if (input.name && !input.name.includes('DELETE') && !input.name.includes('id')) {
                input.value = '';
            }
        });
        const deleteInput = newRow.querySelector(`input[name="${newPrefix}-DELETE"]`);
        if (deleteInput) {
            deleteInput.value = '';
        }
    } else {
        // Create new contact card using Tailwind classes (matching contact.html.j2 template)
        // This template is static and contains no user-provided content
        newRow = document.createElement('div');
        newRow.className = 'contact-card border-b border-border last:border-b-0';
        newRow.setAttribute('x-data', 'contactEntry()');
        newRow.setAttribute('x-show', '!deleted');
        newRow.setAttribute('x-transition:enter', 'transition ease-out duration-200');
        newRow.setAttribute('x-transition:enter-start', 'opacity-0');
        newRow.setAttribute('x-transition:enter-end', 'opacity-100');

        // Build the template using DOM methods for clarity
        const template = `
            <input type="hidden" name="${newPrefix}-id" id="id_${newPrefix}-id">
            <input type="hidden" name="${newPrefix}-DELETE" x-model="deleted" value="">
            <div class="flex items-start gap-3 p-3">
                <div class="flex-shrink-0 mt-1">
                    <div class="w-8 h-8 rounded-full bg-primary/10 flex items-center justify-center">
                        <i class="fas fa-user text-primary text-xs"></i>
                    </div>
                </div>
                <div class="flex-grow min-w-0">
                    <div class="flex flex-wrap gap-2 mb-2">
                        <div class="flex-grow min-w-[120px]">
                            <input type="text" name="${newPrefix}-name" id="id_${newPrefix}-name" class="w-full px-3 py-1.5 text-sm border border-border rounded-lg bg-background text-text placeholder:text-text-muted focus:outline-none focus:ring-2 focus:ring-primary/30 focus:border-primary transition-colors" placeholder="Name *" maxlength="255" :required="!deleted && editing" aria-label="Contact Name">
                        </div>
                        <div class="flex-grow min-w-[160px]">
                            <input type="email" name="${newPrefix}-email" id="id_${newPrefix}-email" class="w-full px-3 py-1.5 text-sm border border-border rounded-lg bg-background text-text placeholder:text-text-muted focus:outline-none focus:ring-2 focus:ring-primary/30 focus:border-primary transition-colors" placeholder="Email" maxlength="254" aria-label="Contact Email">
                        </div>
                        <div class="w-32 flex-shrink-0">
                            <input type="text" name="${newPrefix}-phone" id="id_${newPrefix}-phone" class="w-full px-3 py-1.5 text-sm border border-border rounded-lg bg-background text-text placeholder:text-text-muted focus:outline-none focus:ring-2 focus:ring-primary/30 focus:border-primary transition-colors" placeholder="Phone" aria-label="Contact Phone">
                        </div>
                    </div>
                    <div class="flex flex-wrap gap-4">
                        <label class="flex items-center gap-1.5 cursor-pointer text-xs group">
                            <input type="checkbox" name="${newPrefix}-is_author" id="id_${newPrefix}-is_author" class="w-3.5 h-3.5 rounded border-border text-primary focus:ring-primary" x-model="isAuthor">
                            <span class="text-text-muted group-hover:text-text transition-colors"><i class="fas fa-pen-fancy mr-1 text-warning"></i>Author</span>
                        </label>
                        <label class="flex items-center gap-1.5 cursor-pointer text-xs group" :title="securityContactDisabled && !isSecurityContact ? 'Another contact is already designated as security contact' : 'Security/vulnerability reporting contact'" :class="securityContactDisabled && !isSecurityContact ? 'opacity-50' : ''">
                            <input type="checkbox" name="${newPrefix}-is_security_contact" id="id_${newPrefix}-is_security_contact" class="w-3.5 h-3.5 rounded border-border text-primary focus:ring-primary" x-model="isSecurityContact" :disabled="securityContactDisabled && !isSecurityContact">
                            <span class="text-text-muted group-hover:text-text transition-colors"><i class="fas fa-shield-halved mr-1 text-danger"></i>Security</span>
                        </label>
                        <label class="flex items-center gap-1.5 cursor-pointer text-xs group">
                            <input type="checkbox" name="${newPrefix}-is_technical_contact" id="id_${newPrefix}-is_technical_contact" class="w-3.5 h-3.5 rounded border-border text-primary focus:ring-primary" x-model="isTechnicalContact">
                            <span class="text-text-muted group-hover:text-text transition-colors"><i class="fas fa-code mr-1 text-info"></i>Technical</span>
                        </label>
                    </div>
                </div>
                <div class="flex-shrink-0">
                    <button type="button" class="tw-icon-btn tw-icon-btn-sm text-text-muted hover:text-danger hover:bg-danger/10" @click="removeContact" title="Remove contact" aria-label="Remove contact">
                        <i class="fas fa-times text-xs"></i>
                    </button>
                </div>
            </div>
        `;
        newRow.innerHTML = template;
        if (window.Alpine) {
            Alpine.initTree(newRow);
        }
    }
    
    container.appendChild(newRow);
    totalInput.value = index + 1;
};

    document.body.addEventListener('htmx:afterSettle', function(event) {
        if (event.detail.target.id === 'contact-profiles-content' || event.detail.target.id === 'custom-contact-form-container') {
            initAlpineComponents();
            requestAnimationFrame(() => {
                if (window.Alpine) {
                    Alpine.initTree(event.detail.target);
                }
            });
        }
    });

    // Delete confirmation modal functionality (Alpine-based)
    window.showDeleteConfirmation = function(itemName, callback) {
        window.dispatchEvent(new CustomEvent('open-entity-delete-modal', {
            detail: { displayName: itemName, callback: callback }
        }));
    };
</script>
{# Delete Confirmation Modal for Entity/Contact removal - Alpine/Tailwind version #}
<div id="entity-delete-modal"
     x-data="{ open: false, displayName: '', deleteCallback: null, openModal(event) { this.open = true; if (event.detail) { this.displayName = event.detail.displayName || ''; this.deleteCallback = event.detail.callback || null; } }, close() { this.open = false; this.displayName = ''; this.deleteCallback = null; }, confirm() { if (this.deleteCallback) { this.deleteCallback(); } this.close(); } }"
     @open-entity-delete-modal.window="openModal($event)">
    <template x-teleport="body">
        <div x-show="open"
             x-cloak
             class="fixed inset-0 z-[100]"
             role="alertdialog"
             aria-modal="true"
             aria-labelledby="entity-delete-modal-label">
            <div x-show="open"
                 x-transition:enter="transition ease-out duration-200"
                 x-transition:enter-start="opacity-0"
                 x-transition:enter-end="opacity-100"
                 x-transition:leave="transition ease-in duration-150"
                 x-transition:leave-start="opacity-100"
                 x-transition:leave-end="opacity-0"
                 class="tw-modal-overlay"
                 @click="close()"></div>
            <div class="tw-modal"
                 x-show="open"
                 x-transition:enter="transition ease-out duration-200"
                 x-transition:enter-start="opacity-0 scale-95"
                 x-transition:enter-end="opacity-100 scale-100"
                 x-transition:leave="transition ease-in duration-150"
                 x-transition:leave-start="opacity-100 scale-100"
                 x-transition:leave-end="opacity-0 scale-95"
                 @click.stop
                 @keydown.escape.window="if(open) close()">
                <div class="tw-modal-content tw-modal-sm">
                    <div class="tw-modal-body text-center py-6">
                        <button type="button"
                                class="tw-modal-close absolute top-4 right-4"
                                @click="close()"
                                aria-label="Close">
                            <i class="fas fa-times"></i>
                        </button>
                        <div class="w-14 h-14 mx-auto mb-4 rounded-full bg-danger/10 flex items-center justify-center">
                            <i class="fas fa-exclamation-triangle text-danger text-xl"></i>
                        </div>
                        <h3 id="entity-delete-modal-label" class="tw-modal-title mb-2">Remove Item</h3>
                        <p class="text-sm text-text mb-2">
                            Are you sure you want to remove <span class="font-semibold text-text" x-text="displayName"></span>?
                        </p>
                        <p class="text-xs text-text-muted">This action cannot be undone.</p>
                    </div>
                    <div class="tw-modal-footer justify-center">
                        <button type="button" class="tw-btn-ghost" @click="close()">Cancel</button>
                        <button type="button" class="tw-btn-danger" @click="confirm()">
                            <i class="fas fa-trash mr-2"></i>Remove
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </template>
</div>
