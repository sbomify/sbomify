"""API endpoints for vulnerability scanning settings and management."""

import logging
from collections import defaultdict
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from django.http import HttpRequest
from django.shortcuts import get_object_or_404
from django.utils import timezone
from ninja import Router
from ninja.params import Query
from ninja.security import django_auth
from pydantic import BaseModel, Field

from sbomify.apps.access_tokens.auth import PersonalAccessTokenAuth
from sbomify.apps.core.api.errors import api_error_response
from sbomify.apps.core.domain.exceptions import DomainError, NotFoundError, PermissionDeniedError, ValidationError
from sbomify.apps.core.utils import token_to_number
from sbomify.apps.plugins.models import AssessmentRun
from sbomify.apps.teams.models import Member, Team
from sbomify.apps.teams.queries import require_team_member

from .models import (
    DependencyTrackServer,
    ReleaseDependencyTrackMapping,
    TeamVulnerabilitySettings,
)
from .services import VulnerabilityScanningService


def _extract_severity_counts(result_json: dict | None) -> dict[str, int]:
    """Extract severity counts from AssessmentRun result JSON."""
    if not result_json:
        return {"total": 0, "critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
    summary = result_json.get("summary", {})
    by_severity = summary.get("by_severity", {})
    return {
        "total": summary.get("total_findings", 0),
        "critical": by_severity.get("critical", 0),
        "high": by_severity.get("high", 0),
        "medium": by_severity.get("medium", 0),
        "low": by_severity.get("low", 0),
        "info": by_severity.get("info", 0),
    }


def _apply_latest_sbom_filter(queryset, component_id):
    """Filter queryset to the latest SBOM for a component."""
    from sbomify.apps.sboms.queries import get_latest_sbom_id_for_component

    latest_sbom_id = get_latest_sbom_id_for_component(component_id)
    if not latest_sbom_id:
        return queryset.none()
    return queryset.filter(sbom_id=latest_sbom_id)


def _security_assessments_for_team(team):
    """Base queryset for completed security assessment runs for a team."""
    return AssessmentRun.objects.filter(
        sbom__component__team=team,
        category="security",
        status="completed",
    )


def _is_guest_member(request: HttpRequest, team: Team) -> bool:
    """Check if the current user is a guest member of the specified team."""
    if not request.user.is_authenticated:
        return False
    try:
        Member.objects.get(user=request.user, team=team, role="guest")
        return True
    except Member.DoesNotExist:
        return False


logger = logging.getLogger(__name__)

router = Router(tags=["Vulnerability Scanning"], auth=(PersonalAccessTokenAuth(), django_auth))


def _validate_team_access(request: HttpRequest, team_key: str, allowed_roles: list[str]) -> Team:
    """
    Validate team access supporting both session-based (web UI) and token-based (API) authentication.
    Raises DomainError on failure.
    """
    if not request.user.is_authenticated:
        raise PermissionDeniedError("Not logged in")

    try:
        team_id = token_to_number(team_key)
        team = Team.objects.get(pk=team_id)
    except (ValueError, Team.DoesNotExist):
        raise NotFoundError("Workspace not found")

    member = Member.objects.filter(user=request.user, team=team).only("role").first()
    if not member:
        raise PermissionDeniedError("Access denied")

    if member.role not in allowed_roles:
        raise PermissionDeniedError("You don't have sufficient permissions to access this page")

    current_team = request.session.get("current_team", {})
    current_team_key = current_team.get("key")
    if current_team_key is not None and current_team_key != team_key:
        raise PermissionDeniedError("Access denied - please switch to this team first")

    return team


# Schemas
class VulnerabilityProviderChoice(BaseModel):
    """Available vulnerability provider choices."""

    value: str
    label: str
    description: str
    available: bool = True
    plan_required: Optional[str] = None


class DependencyTrackServerInfo(BaseModel):
    """Information about a Dependency Track server."""

    id: str
    name: str
    health_status: str
    is_active: bool
    description: Optional[str] = None
    # Note: URL field removed to prevent server exposure to end users


class TeamVulnerabilitySettingsResponse(BaseModel):
    """Response schema for team vulnerability settings."""

    vulnerability_provider: str
    custom_dt_server: Optional[DependencyTrackServerInfo] = None
    available_providers: List[VulnerabilityProviderChoice]
    available_dt_servers: List[DependencyTrackServerInfo]
    can_use_custom_dt: bool
    current_plan: str


class UpdateVulnerabilitySettingsRequest(BaseModel):
    """Request to update vulnerability settings."""

    vulnerability_provider: str = Field(..., description="Vulnerability provider ('osv' or 'dependency_track')")
    custom_dt_server_id: Optional[str] = Field(None, description="Custom DT server ID (Enterprise only)")


class ErrorResponse(BaseModel):
    """Standard error response."""

    detail: str
    error_code: str | None = None


@router.get(
    "/workspaces/{team_key}/vulnerability-settings",
    response={200: TeamVulnerabilitySettingsResponse, 403: ErrorResponse, 404: ErrorResponse},
    summary="Get workspace vulnerability scanning settings",
    description=(
        "Retrieve vulnerability scanning configuration for a workspace including available options "
        "based on billing plan. Note: 'team_key' parameter name is retained for backward compatibility and "
        "represents the workspace key."
    ),
    tags=["Vulnerability Scanning"],
)
def get_team_vulnerability_settings(request: HttpRequest, team_key: str):
    """Get vulnerability scanning settings for a team."""
    try:
        team = _validate_team_access(request, team_key, ["owner", "admin"])
    except DomainError as exc:
        return api_error_response(exc)

    # Block guest members from internal vulnerability APIs (double-check)
    if _is_guest_member(request, team):
        return 403, {"detail": "Guest members can only access public pages"}

    # Get or create team settings
    service = VulnerabilityScanningService()
    team_settings = service.get_or_create_team_settings(team)

    # Determine available providers based on billing plan
    available_providers = _get_available_providers(team)

    # Get available DT servers for Enterprise teams
    available_dt_servers = []
    can_use_custom_dt = team.billing_plan == "enterprise"

    if can_use_custom_dt:
        available_dt_servers = [
            DependencyTrackServerInfo(
                id=str(server.id),
                name=server.name,
                health_status=server.health_status,
                is_active=server.is_active,
                description=(
                    f"Priority: {server.priority}, Capacity: {server.current_scan_count}/{server.max_concurrent_scans}"
                ),
            )
            for server in DependencyTrackServer.objects.filter(is_active=True).order_by("priority", "name")
        ]

    # Format custom DT server info
    custom_dt_server = None
    if team_settings.custom_dt_server:
        custom_dt_server = DependencyTrackServerInfo(
            id=str(team_settings.custom_dt_server.id),
            name=team_settings.custom_dt_server.name,
            health_status=team_settings.custom_dt_server.health_status,
            is_active=team_settings.custom_dt_server.is_active,
        )

    return 200, TeamVulnerabilitySettingsResponse(
        vulnerability_provider=team_settings.vulnerability_provider,
        custom_dt_server=custom_dt_server,
        available_providers=available_providers,
        available_dt_servers=available_dt_servers,
        can_use_custom_dt=can_use_custom_dt,
        current_plan=team.billing_plan or "community",
    )


@router.put(
    "/workspaces/{team_key}/vulnerability-settings",
    response={200: TeamVulnerabilitySettingsResponse, 400: ErrorResponse, 403: ErrorResponse, 404: ErrorResponse},
    summary="Update workspace vulnerability scanning settings",
    description=(
        "Update vulnerability scanning configuration for a workspace. Only workspace owners can modify settings. "
        "Note: 'team_key' parameter name is retained for backward compatibility and represents the workspace key."
    ),
    tags=["Vulnerability Scanning"],
)
def update_team_vulnerability_settings(
    request: HttpRequest, team_key: str, payload: UpdateVulnerabilitySettingsRequest
):
    """Update vulnerability scanning settings for a team."""
    try:
        team = _validate_team_access(request, team_key, ["owner"])
    except DomainError as exc:
        return api_error_response(exc)

    # Validate provider choice
    if payload.vulnerability_provider not in ["osv", "dependency_track"]:
        return api_error_response(ValidationError("Invalid vulnerability provider"))

    # Validate billing plan restrictions
    if payload.vulnerability_provider == "dependency_track":
        if not team.billing_plan or team.billing_plan not in ["business", "enterprise"]:
            return api_error_response(
                ValidationError("Dependency Track is only available for Business and Enterprise plans")
            )

    # Validate custom DT server restrictions
    custom_dt_server = None
    if payload.custom_dt_server_id:
        if team.billing_plan != "enterprise":
            return api_error_response(
                ValidationError("Custom Dependency Track servers are only available for Enterprise plans")
            )

        if payload.vulnerability_provider != "dependency_track":
            return api_error_response(
                ValidationError("Custom DT server can only be used with Dependency Track provider")
            )

        try:
            custom_dt_server = DependencyTrackServer.objects.get(id=payload.custom_dt_server_id, is_active=True)
        except DependencyTrackServer.DoesNotExist:
            return api_error_response(ValidationError("Invalid or inactive Dependency Track server"))

    # Update or create team settings
    team_settings, created = TeamVulnerabilitySettings.objects.update_or_create(
        team=team,
        defaults={"vulnerability_provider": payload.vulnerability_provider, "custom_dt_server": custom_dt_server},
    )

    logger.info(
        f"Updated vulnerability settings for team {team.key}: "
        f"provider={payload.vulnerability_provider}, "
        f"custom_server={custom_dt_server.name if custom_dt_server else None}"
    )

    # Return updated settings (reuse the GET logic)
    return get_team_vulnerability_settings(request, team_key)


@router.get(
    "/workspaces/{team_key}/vulnerability-stats",
    response={200: Dict[str, Any], 403: ErrorResponse, 404: ErrorResponse},
    summary="Get workspace vulnerability scanning statistics",
    description="Get vulnerability scanning statistics and recent assessment results for a workspace. "
    "Note: 'team_key' parameter name is retained for backward compatibility and represents the workspace key.",
    tags=["Vulnerability Scanning"],
)
def get_team_vulnerability_stats(
    request: HttpRequest,
    team_key: str,
    component_id: Optional[str] = Query(None, description="Filter to specific component"),
    product_id: Optional[str] = Query(None, description="Filter to specific product"),
    release_id: Optional[str] = Query(None, description="Filter to specific release/version"),
    latest_sbom_only: bool = Query(False, description="For component view: only show vulnerabilities from latest SBOM"),
):
    """Get vulnerability scanning statistics for a team."""
    try:
        team_id = token_to_number(team_key)
        team = get_object_or_404(Team, pk=team_id)
        try:
            if _is_guest_member(request, team):
                return 403, {"detail": "Guest members can only access public pages"}
            require_team_member(request.user, team, ["owner", "admin"])
        except DomainError as exc:
            return api_error_response(exc)

        from sbomify.apps.core.models import Component

        recent_results_query = _security_assessments_for_team(team)

        if product_id:
            recent_results_query = recent_results_query.filter(sbom__component__projects__products__id=product_id)

        if release_id:
            from sbomify.apps.core.models import ReleaseArtifact

            sbom_ids_in_release = ReleaseArtifact.objects.filter(release_id=release_id, sbom__isnull=False).values_list(
                "sbom_id", flat=True
            )
            recent_results_query = recent_results_query.filter(sbom_id__in=sbom_ids_in_release)

        if component_id:
            recent_results_query = recent_results_query.filter(sbom__component_id=component_id)
            if latest_sbom_only:
                recent_results_query = _apply_latest_sbom_filter(recent_results_query, component_id)

        recent_results = list(recent_results_query.select_related("sbom__component__team").order_by("-created_at")[:10])

        total_scans = len(recent_results)
        provider_stats = {}
        total_vulnerabilities = 0

        for run in recent_results:
            counts = _extract_severity_counts(run.result)
            plugin = run.plugin_name
            if plugin not in provider_stats:
                provider_stats[plugin] = {"count": 0, "vulnerabilities": 0}
            provider_stats[plugin]["count"] += 1
            provider_stats[plugin]["vulnerabilities"] += counts["total"]
            total_vulnerabilities += counts["total"]

        dt_mappings = []
        if team.billing_plan in ["business", "enterprise"]:
            mappings = ReleaseDependencyTrackMapping.objects.filter(release__product__team=team).select_related(
                "dt_server", "release", "release__product"
            )

            dt_mappings = [
                {
                    "release_name": mapping.release.name,
                    "product_name": mapping.release.product.name,
                    "dt_server_id": str(mapping.dt_server.id),
                    "dt_project_name": mapping.dt_project_name,
                    "last_upload": mapping.last_sbom_upload.isoformat() if mapping.last_sbom_upload else None,
                    "last_sync": mapping.last_metrics_sync.isoformat() if mapping.last_metrics_sync else None,
                }
                for mapping in mappings
            ]

        return 200, {
            "total_components": Component.objects.filter(team=team).count(),
            "total_scans": total_scans,
            "total_vulnerabilities": total_vulnerabilities,
            "provider_stats": provider_stats,
            "dt_mappings": dt_mappings,
            "recent_results": [
                {
                    "id": str(run.id),
                    "sbom_id": str(run.sbom.id),
                    "sbom_name": run.sbom.name,
                    "sbom_version": run.sbom.version,
                    "component_name": run.sbom.component.name,
                    "provider": run.plugin_name,
                    "scan_trigger": run.run_reason,
                    "vulnerability_count": _extract_severity_counts(run.result),
                    "total_vulnerabilities": _extract_severity_counts(run.result)["total"],
                    "critical_vulnerabilities": _extract_severity_counts(run.result)["critical"],
                    "high_vulnerabilities": _extract_severity_counts(run.result)["high"],
                    "medium_vulnerabilities": _extract_severity_counts(run.result)["medium"],
                    "low_vulnerabilities": _extract_severity_counts(run.result)["low"],
                    "scan_date": run.created_at.isoformat(),
                    "created_at": run.created_at.isoformat(),
                }
                for run in recent_results
            ],
        }

    except ValueError:
        return api_error_response(NotFoundError("Workspace not found"))


@router.get(
    "/workspaces/{team_key}/vulnerability-timeseries",
    response={200: Dict[str, Any], 403: ErrorResponse, 404: ErrorResponse},
    summary="Get vulnerability scanning time series data",
    description="Get historical vulnerability data for time series charts including trends by severity and provider. "
    "Note: 'team_key' parameter name is retained for backward compatibility and represents the workspace key.",
    tags=["Vulnerability Scanning"],
)
def get_team_vulnerability_timeseries(
    request: HttpRequest,
    team_key: str,
    component_id: Optional[str] = Query(None, description="Filter to specific component"),
    product_id: Optional[str] = Query(None, description="Filter to specific product"),
    release_id: Optional[str] = Query(None, description="Filter to specific release/version"),
    latest_sbom_only: bool = Query(
        False, description="For component view: only show vulnerabilities from latest SBOM over time"
    ),
    days: int = Query(30, description="Number of days to include in time series", ge=7, le=365),
):
    """Get vulnerability time series data for charts."""
    try:
        team_id = token_to_number(team_key)
        team = get_object_or_404(Team, pk=team_id)
        try:
            if _is_guest_member(request, team):
                return 403, {"detail": "Guest members can only access public pages"}
            require_team_member(request.user, team, ["owner", "admin"])
        except DomainError as exc:
            return api_error_response(exc)

        end_date = timezone.now()
        start_date = end_date - timedelta(days=days)

        results_query = _security_assessments_for_team(team).filter(
            created_at__gte=start_date, created_at__lte=end_date
        )

        if product_id:
            results_query = results_query.filter(sbom__component__projects__products__id=product_id)

        if release_id:
            from sbomify.apps.core.models import ReleaseArtifact

            sbom_ids_in_release = ReleaseArtifact.objects.filter(release_id=release_id, sbom__isnull=False).values_list(
                "sbom_id", flat=True
            )
            results_query = results_query.filter(sbom_id__in=sbom_ids_in_release)

        if component_id:
            results_query = results_query.filter(sbom__component_id=component_id)
            if latest_sbom_only:
                results_query = _apply_latest_sbom_filter(results_query, component_id)

        results = list(results_query.order_by("created_at"))

        daily_data = defaultdict(
            lambda: {
                "scans_count": 0,
                "total_vulnerabilities": 0,
                "severities": {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0},
                "providers": defaultdict(lambda: {"scans": 0, "vulnerabilities": 0}),
            }
        )

        for run in results:
            day_key = run.created_at.date().isoformat()
            day_data = daily_data[day_key]
            day_data["scans_count"] += 1

            counts = _extract_severity_counts(run.result)
            day_data["total_vulnerabilities"] += counts["total"]

            for severity in ["critical", "high", "medium", "low", "info"]:
                day_data["severities"][severity] += counts[severity]

            day_data["providers"][run.plugin_name]["scans"] += 1
            day_data["providers"][run.plugin_name]["vulnerabilities"] += counts["total"]

        time_series = []
        current_date = start_date.date()
        while current_date <= end_date.date():
            day_key = current_date.isoformat()
            day_data = daily_data.get(
                day_key,
                {
                    "scans_count": 0,
                    "total_vulnerabilities": 0,
                    "severities": {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0},
                    "providers": {},
                },
            )

            time_series.append(
                {
                    "date": day_key,
                    "scans_count": day_data["scans_count"],
                    "total_vulnerabilities": day_data["total_vulnerabilities"],
                    "severities": day_data["severities"],
                    "providers": dict(day_data["providers"]),
                }
            )

            current_date += timedelta(days=1)

        total_scans = sum(day["scans_count"] for day in time_series)
        total_vulnerabilities = sum(day["total_vulnerabilities"] for day in time_series)

        severity_totals = {
            severity: sum(day["severities"][severity] for day in time_series)
            for severity in ["critical", "high", "medium", "low", "info"]
        }

        provider_summary = defaultdict(lambda: {"scans": 0, "vulnerabilities": 0})
        for day in time_series:
            for provider, stats in day["providers"].items():
                provider_summary[provider]["scans"] += stats["scans"]
                provider_summary[provider]["vulnerabilities"] += stats["vulnerabilities"]

        return 200, {
            "time_series": time_series,
            "summary": {
                "total_scans": total_scans,
                "total_vulnerabilities": total_vulnerabilities,
                "severity_totals": severity_totals,
                "provider_summary": dict(provider_summary),
                "date_range": {
                    "start": start_date.date().isoformat(),
                    "end": end_date.date().isoformat(),
                    "days": days,
                },
            },
        }

    except ValueError:
        return api_error_response(NotFoundError("Workspace not found"))


@router.get(
    "/workspaces/{team_key}/vulnerability-drill-down",
    response={200: Dict[str, Any], 403: ErrorResponse, 404: ErrorResponse},
    summary="Get detailed vulnerability drill-down data",
    description=(
        "Get detailed breakdown of vulnerabilities with components, "
        "SBOMs, and vulnerability details for drill-down views. "
        "Note: 'team_key' parameter name is retained for backward compatibility and represents the workspace key."
    ),
    tags=["Vulnerability Scanning"],
)
def get_team_vulnerability_drill_down(
    request: HttpRequest,
    team_key: str,
    filter_type: str = Query(..., description="Filter type: 'date', 'severity', or 'provider'"),
    filter_value: str = Query(..., description="Filter value based on filter_type"),
    component_id: Optional[str] = Query(None, description="Filter to specific component"),
    product_id: Optional[str] = Query(None, description="Filter to specific product"),
    release_id: Optional[str] = Query(None, description="Filter to specific release/version"),
    latest_sbom_only: bool = Query(False, description="For component view: only show vulnerabilities from latest SBOM"),
    days: int = Query(30, description="Number of days for context", ge=7, le=365),
):
    """Get detailed vulnerability drill-down data for charts."""
    try:
        team_id = token_to_number(team_key)
        team = get_object_or_404(Team, pk=team_id)
        try:
            if _is_guest_member(request, team):
                return 403, {"detail": "Guest members can only access public pages"}
            require_team_member(request.user, team, ["owner", "admin"])
        except DomainError as exc:
            return api_error_response(exc)

        end_date = timezone.now()
        start_date = end_date - timedelta(days=days)

        results_query = (
            _security_assessments_for_team(team)
            .filter(created_at__gte=start_date, created_at__lte=end_date)
            .select_related("sbom__component__team")
        )

        if product_id:
            results_query = results_query.filter(sbom__component__projects__products__id=product_id)

        if release_id:
            from sbomify.apps.core.models import ReleaseArtifact

            sbom_ids_in_release = ReleaseArtifact.objects.filter(release_id=release_id, sbom__isnull=False).values_list(
                "sbom_id", flat=True
            )
            results_query = results_query.filter(sbom_id__in=sbom_ids_in_release)

        if component_id:
            results_query = results_query.filter(sbom__component_id=component_id)
            if latest_sbom_only:
                results_query = _apply_latest_sbom_filter(results_query, component_id)

        if filter_type == "date":
            target_date = datetime.fromisoformat(filter_value).date()
            results_query = results_query.filter(created_at__date=target_date)
        elif filter_type == "severity":
            # Post-filter in Python since severity counts are in JSON
            pass
        elif filter_type == "provider":
            results_query = results_query.filter(plugin_name=filter_value)

        results = list(results_query.order_by("-created_at"))

        # Post-filter for severity if needed (can't do JSON field lookups efficiently)
        if filter_type == "severity" and filter_value in ("critical", "high", "medium", "low"):
            results = [run for run in results if _extract_severity_counts(run.result).get(filter_value, 0) > 0]

        components_data = defaultdict(
            lambda: {
                "id": "",
                "name": "",
                "sbom_count": 0,
                "vulnerability_count": 0,
                "severities": {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0},
            }
        )

        sboms_data = defaultdict(
            lambda: {
                "id": "",
                "name": "",
                "format": "",
                "format_version": "",
                "component_name": "",
                "vulnerability_count": 0,
                "severities": {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0},
                "last_scan_date": None,
            }
        )

        all_vulnerabilities = []
        vulnerability_counts = defaultdict(int)

        for run in results:
            component = run.sbom.component
            sbom = run.sbom
            counts = _extract_severity_counts(run.result)

            comp_key = str(component.id)
            comp_data = components_data[comp_key]
            comp_data["id"] = str(component.id)
            comp_data["name"] = component.name
            comp_data["sbom_count"] += 1
            comp_data["vulnerability_count"] += counts["total"]
            for sev in ["critical", "high", "medium", "low", "info"]:
                comp_data["severities"][sev] += counts[sev]

            sbom_key = str(sbom.id)
            sbom_data = sboms_data[sbom_key]
            sbom_data["id"] = str(sbom.id)
            sbom_data["name"] = f"{sbom.name}{f' {sbom.version}' if sbom.version else ''}"
            sbom_data["format"] = sbom.format or "Unknown"
            sbom_data["format_version"] = sbom.format_version or ""
            sbom_data["component_name"] = component.name
            sbom_data["last_scan_date"] = run.created_at.isoformat()
            sbom_data["vulnerability_count"] += counts["total"]
            for sev in ["critical", "high", "medium", "low", "info"]:
                sbom_data["severities"][sev] += counts[sev]

            # Extract findings from AssessmentRun result JSON
            findings = (run.result or {}).get("findings", [])

            for vuln in findings:
                vuln_id = vuln.get("id", "unknown")
                if vuln_id and vuln_id != "unknown":
                    if vuln_id not in vulnerability_counts:
                        external_url = None
                        references = vuln.get("references", [])
                        if references:
                            if isinstance(references[0], dict):
                                external_url = references[0].get("url")
                            elif isinstance(references[0], str):
                                external_url = references[0]

                        if not external_url:
                            metadata = vuln.get("metadata", {})
                            if metadata:
                                external_url = metadata.get("url")

                        vulnerability_detail = {
                            "id": vuln_id,
                            "summary": vuln.get("title") or vuln.get("description", ""),
                            "severity": vuln.get("severity", "unknown").upper(),
                            "affected_components": 1,
                            "external_url": external_url,
                            "component_name": (vuln.get("component") or {}).get("name", "Unknown"),
                            "cvss_score": vuln.get("cvss_score"),
                        }
                        all_vulnerabilities.append(vulnerability_detail)
                        vulnerability_counts[vuln_id] = 1
                    else:
                        vulnerability_counts[vuln_id] += 1
                        for v in all_vulnerabilities:
                            if v["id"] == vuln_id:
                                v["affected_components"] = vulnerability_counts[vuln_id]
                                break

        components_list = sorted(list(components_data.values()), key=lambda x: x["vulnerability_count"], reverse=True)
        sboms_list = sorted(list(sboms_data.values()), key=lambda x: x["vulnerability_count"], reverse=True)

        severity_order = {"CRITICAL": 0, "HIGH": 1, "MEDIUM": 2, "LOW": 3, "INFO": 4, "UNKNOWN": 5}
        vulnerabilities_list = sorted(
            all_vulnerabilities, key=lambda x: (severity_order.get(x["severity"], 5), -x["affected_components"])
        )

        return 200, {
            "filter_type": filter_type,
            "filter_value": filter_value,
            "total_results": len(results),
            "components": components_list,
            "sboms": sboms_list,
            "vulnerabilities": vulnerabilities_list,
            "summary": {
                "total_components": len(components_list),
                "total_sboms": len(sboms_list),
                "total_vulnerabilities": len(vulnerabilities_list),
                "date_range": {
                    "start": start_date.date().isoformat(),
                    "end": end_date.date().isoformat(),
                    "days": days,
                },
            },
        }

    except ValueError:
        return api_error_response(NotFoundError("Workspace not found"))


@router.get(
    "/workspaces/{team_key}/vulnerability-trends",
    response={200: Dict[str, Any], 403: ErrorResponse, 404: ErrorResponse},
    summary="Get vulnerability trends over time for time series analysis",
    description="Get historical vulnerability trends showing changes over time for dashboard charts and analysis. "
    "Note: 'team_key' parameter name is retained for backward compatibility and represents the workspace key.",
    tags=["Vulnerability Scanning"],
)
def get_team_vulnerability_trends(
    request: HttpRequest,
    team_key: str,
    days: int = Query(30, description="Number of days to analyze (default: 30)"),
    granularity: str = Query("day", description="Time granularity: 'day', 'week', or 'month'"),
    component_id: Optional[str] = Query(None, description="Filter by specific component ID"),
    provider: Optional[str] = Query(None, description="Filter by vulnerability provider (plugin name)"),
):
    """
    Get vulnerability trends over time for comprehensive time series analysis.

    Returns aggregated vulnerability data points over the specified time period,
    grouped by the requested granularity (day/week/month).
    """
    from sbomify.apps.core.utils import verify_item_access

    try:
        team = get_object_or_404(Team, key=team_key)

        if _is_guest_member(request, team):
            return 403, {"detail": "Guest members can only access public pages"}

        if not verify_item_access(request, team, ["owner", "admin"]):
            return 403, {"detail": "Access denied"}

        end_date = timezone.now()
        start_date = end_date - timedelta(days=days)

        queryset = _security_assessments_for_team(team).filter(created_at__gte=start_date, created_at__lte=end_date)

        if component_id:
            queryset = queryset.filter(sbom__component_id=component_id)
        if provider:
            queryset = queryset.filter(plugin_name=provider)

        runs = list(queryset.order_by("created_at"))

        # Group by period and compute aggregations in Python
        def _get_period_key(dt):
            if granularity == "week":
                # ISO week start (Monday)
                return (dt.date() - timedelta(days=dt.weekday())).isoformat()
            elif granularity == "month":
                return dt.date().replace(day=1).isoformat()
            else:
                return dt.date().isoformat()

        period_data = defaultdict(list)
        for run in runs:
            period_data[_get_period_key(run.created_at)].append(run)

        time_series = []
        for period, period_runs in sorted(period_data.items()):
            severity_totals = [_extract_severity_counts(r.result) for r in period_runs]
            n = len(period_runs)
            time_series.append(
                {
                    "date": period,
                    "scan_count": n,
                    "avg_total_vulnerabilities": round(sum(s["total"] for s in severity_totals) / n, 1),
                    "avg_critical_vulnerabilities": round(sum(s["critical"] for s in severity_totals) / n, 1),
                    "avg_high_vulnerabilities": round(sum(s["high"] for s in severity_totals) / n, 1),
                    "avg_medium_vulnerabilities": round(sum(s["medium"] for s in severity_totals) / n, 1),
                    "avg_low_vulnerabilities": round(sum(s["low"] for s in severity_totals) / n, 1),
                    "max_total_vulnerabilities": max((s["total"] for s in severity_totals), default=0),
                    "min_total_vulnerabilities": min((s["total"] for s in severity_totals), default=0),
                }
            )

        # Provider breakdown
        provider_groups = defaultdict(list)
        for run in runs:
            provider_groups[run.plugin_name].append(run)

        provider_breakdown = []
        for pname, pruns in provider_groups.items():
            totals = [_extract_severity_counts(r.result)["total"] for r in pruns]
            provider_breakdown.append(
                {
                    "provider": pname,
                    "total_scans": len(pruns),
                    "avg_vulnerabilities": round(sum(totals) / len(pruns), 1) if pruns else 0,
                }
            )

        # Component breakdown
        component_breakdown = []
        if not component_id:
            comp_groups = defaultdict(list)
            for run in runs:
                comp_name = run.sbom.component.name if hasattr(run, "_sbom_cache") else None
                comp_groups[(run.sbom.component_id, comp_name)].append(run)

            # Re-query for component names efficiently
            comp_runs = defaultdict(list)
            for run in queryset.select_related("sbom__component").order_by("created_at"):
                comp_runs[(str(run.sbom.component_id), run.sbom.component.name)].append(run)

            comp_list = []
            for (comp_id, comp_name), cruns in comp_runs.items():
                totals = [_extract_severity_counts(r.result)["total"] for r in cruns]
                comp_list.append(
                    {
                        "component_name": comp_name,
                        "component_id": comp_id,
                        "total_scans": len(cruns),
                        "avg_vulnerabilities": round(sum(totals) / len(cruns), 1) if cruns else 0,
                        "latest_scan": cruns[-1].created_at.isoformat() if cruns else None,
                    }
                )
            component_breakdown = sorted(comp_list, key=lambda x: x["avg_vulnerabilities"], reverse=True)[:10]

        return 200, {
            "time_series": time_series,
            "provider_breakdown": provider_breakdown,
            "component_breakdown": component_breakdown,
            "summary": {
                "total_scans": len(runs),
                "date_range": {"start": start_date.isoformat(), "end": end_date.isoformat(), "days": days},
                "granularity": granularity,
                "filters": {"component_id": component_id, "provider": provider},
            },
        }

    except Exception as e:
        logger.error(f"Failed to get vulnerability trends for team {team_key}: {e}")
        return 400, {"detail": "Failed to get vulnerability trends"}


@router.get(
    "/workspaces/{team_key}/vulnerability-heatmap",
    response={200: Dict[str, Any], 403: ErrorResponse, 404: ErrorResponse},
    summary="Get vulnerability heatmap data for visual analysis",
    description="Get vulnerability density data across components and time periods for heatmap visualizations. "
    "Note: 'team_key' parameter name is retained for backward compatibility and represents the workspace key.",
    tags=["Vulnerability Scanning"],
)
def get_team_vulnerability_heatmap(
    request: HttpRequest,
    team_key: str,
    days: int = Query(30, description="Number of days to analyze (default: 30)"),
    severity_focus: str = Query("total", description="Focus severity: 'total', 'critical', 'high', 'medium', 'low'"),
):
    """
    Get vulnerability heatmap data showing density across components and time.

    Returns a matrix-style dataset perfect for heatmap visualizations,
    showing vulnerability density patterns across different components over time.
    """
    from sbomify.apps.core.utils import verify_item_access

    try:
        team = get_object_or_404(Team, key=team_key)

        if _is_guest_member(request, team):
            return 403, {"detail": "Guest members can only access public pages"}

        if not verify_item_access(request, team, ["owner", "admin"]):
            return 403, {"detail": "Access denied"}

        end_date = timezone.now()
        start_date = end_date - timedelta(days=days)

        runs = list(
            _security_assessments_for_team(team)
            .filter(created_at__gte=start_date, created_at__lte=end_date)
            .select_related("sbom__component")
            .order_by("sbom__component__name", "created_at")
        )

        # Build component x date matrix in Python
        components = {}
        dates = set()

        for run in runs:
            component_name = run.sbom.component.name
            component_id = str(run.sbom.component_id)
            date_key = run.created_at.date().isoformat()
            counts = _extract_severity_counts(run.result)
            severity_value = counts[severity_focus] if severity_focus in counts else counts["total"]

            if component_name not in components:
                components[component_name] = {
                    "component_id": component_id,
                    "component_name": component_name,
                    "dates": defaultdict(lambda: {"values": [], "scan_count": 0}),
                }

            entry = components[component_name]["dates"][date_key]
            entry["values"].append(severity_value)
            entry["scan_count"] += 1
            dates.add(date_key)

        # Compute avg/max per date bucket
        for comp_data in components.values():
            new_dates = {}
            for date_key, entry in comp_data["dates"].items():
                vals = entry["values"]
                new_dates[date_key] = {
                    "avg_vulnerabilities": round(sum(vals) / len(vals), 1) if vals else 0,
                    "max_vulnerabilities": max(vals, default=0),
                    "scan_count": entry["scan_count"],
                }
            comp_data["dates"] = new_dates

        sorted_dates = sorted(list(dates))
        for comp_data in components.values():
            for date in sorted_dates:
                if date not in comp_data["dates"]:
                    comp_data["dates"][date] = {
                        "avg_vulnerabilities": 0,
                        "max_vulnerabilities": 0,
                        "scan_count": 0,
                    }

        # Overall statistics
        all_severity_values = [
            _extract_severity_counts(r.result)[severity_focus]
            if severity_focus in _extract_severity_counts(r.result)
            else _extract_severity_counts(r.result)["total"]
            for r in runs
        ]

        return 200, {
            "heatmap_data": list(components.values()),
            "dates": sorted_dates,
            "components": [
                {"id": comp_data["component_id"], "name": comp_data["component_name"]}
                for comp_data in components.values()
            ],
            "statistics": {
                "total_scans": len(runs),
                "avg_vulnerabilities": (
                    round(sum(all_severity_values) / len(all_severity_values), 1) if all_severity_values else 0
                ),
                "max_vulnerabilities": max(all_severity_values, default=0),
                "component_count": len(components),
                "severity_focus": severity_focus,
                "date_range": {"start": start_date.isoformat(), "end": end_date.isoformat(), "days": days},
            },
        }

    except Exception as e:
        logger.error(f"Failed to get vulnerability heatmap for team {team_key}: {e}")
        return 400, {"detail": "Failed to get vulnerability heatmap"}


@router.get(
    "/workspaces/{team_key}/products-releases",
    response={200: Dict[str, Any], 403: ErrorResponse, 404: ErrorResponse},
    summary="Get products and releases for vulnerability filtering",
    description="Get list of products and their releases for dashboard filtering controls. "
    "Note: 'team_key' parameter name is retained for backward compatibility and represents the workspace key.",
    tags=["Vulnerability Scanning"],
)
def get_team_products_releases(request: HttpRequest, team_key: str):
    """Get products and releases for dropdown controls."""
    try:
        team_id = token_to_number(team_key)
        team = get_object_or_404(Team, pk=team_id)

        # Check if user is a member of this team
        if not Member.objects.filter(user=request.user, team=team).exists():
            return 403, {"detail": "Access denied"}

        from sbomify.apps.core.models import Product, Release

        # Get all products for this team
        products = Product.objects.filter(team=team).order_by("name")

        products_data = []
        for product in products:
            # Get releases for this product
            releases = Release.objects.filter(product=product).order_by("-released_at", "-created_at")

            releases_data = [
                {
                    "id": str(release.id),
                    "name": release.name,
                    "description": release.description,
                    "is_latest": release.is_latest,
                    "is_prerelease": release.is_prerelease,
                    "created_at": release.created_at.isoformat(),
                    "released_at": release.released_at.isoformat() if release.released_at else None,
                }
                for release in releases
            ]

            products_data.append(
                {
                    "id": str(product.id),
                    "name": product.name,
                    "description": product.description,
                    "releases": releases_data,
                }
            )

        return 200, {"products": products_data}

    except Exception as e:
        logger.error(f"Failed to get products and releases for team {team_key}: {e}")
        return 400, {"detail": "Failed to get products and releases"}


def _get_available_providers(team: Team) -> List[VulnerabilityProviderChoice]:
    """Get available vulnerability providers based on team's billing plan."""
    providers = [
        VulnerabilityProviderChoice(
            value="osv",
            label="OSV (Google Open Source Vulnerabilities)",
            description="Free, comprehensive vulnerability database from Google",
            available=True,
        )
    ]

    # DT is available for Business and Enterprise plans
    if team.billing_plan in ["business", "enterprise"]:
        providers.append(
            VulnerabilityProviderChoice(
                value="dependency_track",
                label="Dependency Track",
                description="Advanced vulnerability management with detailed metrics and analysis",
                available=True,
                plan_required="business",
            )
        )
    else:
        providers.append(
            VulnerabilityProviderChoice(
                value="dependency_track",
                label="Dependency Track",
                description="Advanced vulnerability management (Business/Enterprise only)",
                available=False,
                plan_required="business",
            )
        )

    return providers
