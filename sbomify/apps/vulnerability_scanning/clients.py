"""Dependency Track API client for vulnerability scanning integration."""

import json
import logging
from typing import Any, Optional
from urllib.parse import urljoin

import requests

logger = logging.getLogger(__name__)


class DependencyTrackAPIError(Exception):
    """Exception raised for Dependency Track API errors."""

    def __init__(self, message: str, status_code: Optional[int] = None, response_data: Optional[dict] = None):
        self.status_code = status_code
        self.response_data = response_data
        super().__init__(message)


class DependencyTrackClient:
    """Client for interacting with Dependency Track API.

    Handles authentication, project management, SBOM uploads, and vulnerability retrieval.
    """

    def __init__(self, base_url: str, api_key: str, timeout: int = 30):
        self.base_url = base_url.rstrip("/")
        self.api_key = api_key
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update(
            {
                "X-Api-Key": api_key,
                "Accept": "application/json",
            }
        )

    def _make_request(
        self,
        method: str,
        endpoint: str,
        data: Optional[dict] = None,
        files: Optional[dict] = None,
        params: Optional[dict] = None,
    ) -> dict[str, Any]:
        """Make an HTTP request to the Dependency Track API."""
        # Health endpoints are on the root path, not under /api
        if endpoint.startswith("/health") or endpoint == "/version":
            url = urljoin(f"{self.base_url}/", endpoint.lstrip("/"))
        else:
            url = urljoin(f"{self.base_url}/api/", endpoint.lstrip("/"))

        try:
            if files:
                response = self.session.request(
                    method=method, url=url, data=data, files=files, params=params, timeout=self.timeout
                )
            else:
                headers = self.session.headers.copy()
                headers["Content-Type"] = "application/json"
                response = self.session.request(
                    method=method, url=url, json=data, params=params, timeout=self.timeout, headers=headers
                )

            logger.debug(f"DT API {method} {url} -> {response.status_code}")

            if response.status_code == 204:
                return {}

            if not response.ok:
                error_data = None
                try:
                    error_data = response.json()
                    error_msg = self._format_dt_error(response.status_code, error_data)
                except (ValueError, json.JSONDecodeError):
                    error_msg = f"DT API request failed ({response.status_code}): {response.text}"
                    error_data = {"raw_error": response.text}

                raise DependencyTrackAPIError(
                    error_msg,
                    status_code=response.status_code,
                    response_data=error_data,
                )

            response_data = response.json() if response.content else {}

            if "X-Total-Count" in response.headers:
                if isinstance(response_data, list):
                    response_data = {
                        "content": response_data,
                        "totalElements": int(response.headers["X-Total-Count"]),
                        "paginated": True,
                    }
                elif isinstance(response_data, dict):
                    response_data["totalElements"] = int(response.headers["X-Total-Count"])
                    response_data["paginated"] = True

            return response_data

        except requests.exceptions.RequestException as e:
            raise DependencyTrackAPIError(f"Request failed: {str(e)}")

    def _format_dt_error(self, status_code: int, error_data: dict[str, Any]) -> str:
        """Format error responses from Dependency Track API."""
        if not isinstance(error_data, dict):
            return f"DT API error ({status_code}): {error_data}"

        message_parts = [f"Dependency Track error ({status_code})"]

        if "title" in error_data:
            message_parts.append(str(error_data["title"]))

        if "detail" in error_data:
            message_parts.append(str(error_data["detail"]))

        if "message" in error_data and "title" not in error_data:
            message_parts.append(str(error_data["message"]))

        if "error" in error_data and len(message_parts) == 1:
            message_parts.append(str(error_data["error"]))

        if len(message_parts) == 1:
            message_parts.append(json.dumps(error_data))

        return ": ".join(message_parts)

    def _make_paginated_request(
        self,
        endpoint: str,
        params: Optional[dict] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
    ) -> dict[str, Any]:
        """Make a paginated GET request to the Dependency Track API."""
        paginated_params = params.copy() if params else {}

        if limit is not None:
            paginated_params["limit"] = limit
        if offset is not None:
            paginated_params["offset"] = offset

        return self._make_request("GET", endpoint, params=paginated_params)

    def health_check(self) -> dict[str, Any]:
        """Check the health status of the Dependency Track server."""
        try:
            response = self._make_request("GET", "/health/ready")
            return {"status": "healthy", "details": response}
        except DependencyTrackAPIError:
            try:
                response = self._make_request("GET", "/health")
                return {"status": "degraded", "details": response}
            except DependencyTrackAPIError:
                return {"status": "unhealthy", "error": "Service unavailable"}

    def get_version(self) -> dict[str, Any]:
        """Get the version information of the Dependency Track server."""
        return self._make_request("GET", "/version")

    def create_project(
        self, name: str, version: str = "1.0.0", description: Optional[str] = None, tags: Optional[list[str]] = None
    ) -> dict[str, Any]:
        """Create a new project in Dependency Track."""
        project_data: dict[str, Any] = {
            "name": name,
            "version": version,
            "classifier": "APPLICATION",
        }

        if description:
            project_data["description"] = description

        if tags:
            project_data["tags"] = tags

        return self._make_request("PUT", "/v1/project", data=project_data)

    def get_project(self, project_uuid: str) -> dict[str, Any]:
        """Get project details by UUID."""
        return self._make_request("GET", f"/v1/project/{project_uuid}")

    def update_project(
        self,
        project_uuid: str,
        name: Optional[str] = None,
        version: Optional[str] = None,
        description: Optional[str] = None,
    ) -> dict[str, Any]:
        """Update an existing project."""
        current_project = self.get_project(project_uuid)

        if name is not None:
            current_project["name"] = name
        if version is not None:
            current_project["version"] = version
        if description is not None:
            current_project["description"] = description

        return self._make_request("POST", "/v1/project", data=current_project)

    def upload_sbom(self, project_uuid: str, sbom_data: bytes, auto_create: bool = True) -> dict[str, Any]:
        """Upload an SBOM to a project.

        CRITICAL: Dependency Track ONLY supports CycloneDX format, NOT SPDX!
        """
        try:
            content = json.loads(sbom_data.decode("utf-8"))
            if content.get("bomFormat") != "CycloneDX":
                if content.get("spdxVersion"):
                    raise DependencyTrackAPIError(
                        "SPDX format is not supported by Dependency Track. Only CycloneDX format is supported."
                    )
                else:
                    raise DependencyTrackAPIError(
                        "Invalid SBOM format. Dependency Track only supports CycloneDX format."
                    )
        except json.JSONDecodeError:
            raise DependencyTrackAPIError("Invalid SBOM: Content is not valid JSON")

        upload_data = {"project": project_uuid, "autoCreate": str(auto_create).lower()}
        files = {"bom": ("sbom.json", sbom_data, "application/json")}

        return self._make_request("POST", "/v1/bom", data=upload_data, files=files)

    def upload_sbom_with_project_creation(
        self, project_name: str, project_version: str, sbom_data: bytes, auto_create: bool = True
    ) -> dict[str, Any]:
        """Upload an SBOM and create a project in a single operation.

        CRITICAL: Dependency Track ONLY supports CycloneDX format, NOT SPDX!
        """
        try:
            content = json.loads(sbom_data.decode("utf-8"))
            if content.get("bomFormat") != "CycloneDX":
                if content.get("spdxVersion"):
                    raise DependencyTrackAPIError(
                        "SPDX format is not supported by Dependency Track. Only CycloneDX format is supported."
                    )
                else:
                    raise DependencyTrackAPIError(
                        "Invalid SBOM format. Dependency Track only supports CycloneDX format."
                    )
        except json.JSONDecodeError:
            raise DependencyTrackAPIError("Invalid SBOM: Content is not valid JSON")

        upload_data = {
            "projectName": project_name,
            "projectVersion": project_version,
            "autoCreate": str(auto_create).lower(),
        }

        files = {"bom": ("sbom.json", sbom_data, "application/json")}

        return self._make_request("POST", "/v1/bom", data=upload_data, files=files)

    def find_project_by_name_version(self, project_name: str, project_version: str) -> Optional[dict[str, Any]]:
        """Find a project by name and version using the optimized lookup endpoint."""
        try:
            params = {"name": project_name, "version": project_version}
            return self._make_request("GET", "/v1/project/lookup", params=params)
        except DependencyTrackAPIError:
            return None

    def get_project_metrics(self, project_uuid: str) -> dict[str, Any]:
        """Get vulnerability metrics for a project."""
        return self._make_request("GET", f"/v1/metrics/project/{project_uuid}/current")

    def get_project_vulnerabilities(
        self, project_uuid: str, suppressed: bool = False, limit: Optional[int] = None, offset: Optional[int] = None
    ) -> dict[str, Any]:
        """Get vulnerabilities for a project using the optimized finding endpoint."""
        params = {"suppressed": str(suppressed).lower()}
        response = self._make_paginated_request(f"/v1/finding/project/{project_uuid}", params, limit, offset)

        if isinstance(response, dict) and "content" in response:
            return response
        elif isinstance(response, list):
            return {"content": response, "totalElements": len(response), "paginated": False}
        else:
            return {"content": [], "totalElements": 0, "paginated": False}

    def get_project_components(self, project_uuid: str) -> list[dict[str, Any]]:
        """Get all components for a project."""
        response = self._make_request("GET", f"/v1/component/project/{project_uuid}")

        if isinstance(response, list):
            return response
        elif isinstance(response, dict) and "content" in response:
            return response["content"]
        else:
            return []

    def delete_project(self, project_uuid: str) -> None:
        """Delete a project."""
        self._make_request("DELETE", f"/v1/project/{project_uuid}")

    def get_analysis(
        self, component_uuid: str, vulnerability_uuid: str, project_uuid: Optional[str] = None
    ) -> dict[str, Any]:
        """Get vulnerability analysis for a component."""
        params: dict[str, str] = {"component": component_uuid, "vulnerability": vulnerability_uuid}
        if project_uuid:
            params["project"] = project_uuid

        return self._make_request("GET", "/v1/analysis", params=params)
