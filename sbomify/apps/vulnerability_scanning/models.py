"""Models for vulnerability scanning integration."""

import uuid

from django.apps import apps
from django.core.exceptions import ValidationError
from django.db import models


# Stub validators kept for migration compatibility (referenced by 0002 migration)
def validate_findings_array(value):
    pass


def validate_vulnerability_count(value):
    pass


class DependencyTrackServer(models.Model):
    """Represents a Dependency Track server instance in the pool.

    Admin-managed pool of DT servers for load balancing and scaling.
    """

    class Meta:
        db_table = apps.get_app_config("vulnerability_scanning").label + "_dt_servers"
        indexes = [
            models.Index(fields=["is_active", "priority"]),
            models.Index(fields=["url"]),
        ]
        ordering = ["priority", "name"]

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=255, help_text="Friendly name for this DT server")
    url = models.URLField(max_length=500, unique=True, help_text="Base URL of the Dependency Track server")
    api_key = models.CharField(max_length=255, help_text="API key for authentication")
    is_active = models.BooleanField(default=True, help_text="Whether this server is available for use")
    priority = models.IntegerField(default=100, help_text="Lower numbers = higher priority for load balancing")
    max_concurrent_scans = models.IntegerField(default=500, help_text="Maximum concurrent SBOM uploads/scans")
    current_scan_count = models.IntegerField(default=0, help_text="Current number of active scans")
    last_health_check = models.DateTimeField(null=True, blank=True)
    health_status = models.CharField(
        max_length=20,
        choices=[
            ("healthy", "Healthy"),
            ("degraded", "Degraded"),
            ("unhealthy", "Unhealthy"),
            ("unknown", "Unknown"),
        ],
        default="unknown",
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self) -> str:
        return f"{self.name} (ID: {self.id})"

    def clean(self) -> None:
        super().clean()
        if self.priority < 1:
            raise ValidationError({"priority": "Priority must be positive"})
        if self.max_concurrent_scans < 1:
            raise ValidationError({"max_concurrent_scans": "Must allow at least 1 concurrent scan"})

    @property
    def is_available_for_scan(self) -> bool:
        """Check if server can accept new scans."""
        return (
            self.is_active
            and self.health_status in ["healthy", "degraded"]
            and self.current_scan_count < self.max_concurrent_scans
        )

    def increment_scan_count(self) -> bool:
        """Atomically increment the scan count if under the limit."""
        from django.db.models import F

        rows_updated = DependencyTrackServer.objects.filter(
            id=self.id, current_scan_count__lt=F("max_concurrent_scans")
        ).update(current_scan_count=F("current_scan_count") + 1)

        if rows_updated > 0:
            self.refresh_from_db(fields=["current_scan_count"])
            return True
        return False

    def decrement_scan_count(self) -> None:
        """Atomically decrement the scan count."""
        from django.db.models import Case, F, Value, When

        DependencyTrackServer.objects.filter(id=self.id).update(
            current_scan_count=Case(When(current_scan_count__gt=0, then=F("current_scan_count") - 1), default=Value(0))
        )

        self.refresh_from_db(fields=["current_scan_count"])


class TeamVulnerabilitySettings(models.Model):
    """Team-specific vulnerability scanning configuration.

    Allows Business/Enterprise teams to configure their vulnerability scanning preferences:
    - Business teams: Can choose OSV or Dependency Track (shared pool only)
    - Enterprise teams: Can choose OSV, Dependency Track (shared pool), or bring their own DT instance
    """

    class Meta:
        db_table = apps.get_app_config("vulnerability_scanning").label + "_team_settings"
        indexes = [models.Index(fields=["team"])]

    VULNERABILITY_PROVIDER_CHOICES = [
        ("osv", "OSV (Google Open Source Vulnerabilities)"),
        ("dependency_track", "Dependency Track"),
    ]

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    team = models.OneToOneField("teams.Team", on_delete=models.CASCADE, related_name="vulnerability_settings")
    vulnerability_provider = models.CharField(
        max_length=20,
        choices=VULNERABILITY_PROVIDER_CHOICES,
        default="osv",
        help_text="Choose between OSV and Dependency Track for vulnerability scanning",
    )

    custom_dt_server = models.ForeignKey(
        DependencyTrackServer,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="teams_using_custom",
        help_text="Custom Dependency Track server (Enterprise only). Business plans use the shared server pool.",
    )

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self) -> str:
        return f"{self.team.name} - {self.get_vulnerability_provider_display()}"

    def clean(self) -> None:
        super().clean()
        if self.vulnerability_provider == "dependency_track":
            if not self.team.billing_plan or self.team.billing_plan not in ["business", "enterprise"]:
                raise ValidationError(
                    {"vulnerability_provider": "Dependency Track is only available for Business and Enterprise plans"}
                )

        if self.custom_dt_server:
            if self.team.billing_plan != "enterprise":
                raise ValidationError(
                    {"custom_dt_server": "Custom Dependency Track servers are only available for Enterprise plans"}
                )

            if self.vulnerability_provider != "dependency_track":
                raise ValidationError(
                    {
                        "custom_dt_server": (
                            "Custom DT server can only be used when vulnerability provider is set to Dependency Track"
                        )
                    }
                )


class ReleaseDependencyTrackMapping(models.Model):
    """Maps Product Releases to Dependency Track projects.

    Each release gets its own DT project for per-version vulnerability tracking.
    DT project naming: {env_prefix}-sbomify-{product.name}-{release.name}
    """

    class Meta:
        db_table = apps.get_app_config("vulnerability_scanning").label + "_release_mappings"
        unique_together = [("release", "dt_server")]
        indexes = [
            models.Index(fields=["release"]),
            models.Index(fields=["dt_server", "dt_project_uuid"]),
        ]

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    release = models.ForeignKey("core.Release", on_delete=models.CASCADE, related_name="dependency_track_mappings")
    dt_server = models.ForeignKey(DependencyTrackServer, on_delete=models.CASCADE, related_name="release_mappings")
    dt_project_uuid = models.UUIDField(help_text="UUID of the project in Dependency Track")
    dt_project_name = models.CharField(max_length=255, help_text="Name of the project in DT")
    last_sbom_upload = models.DateTimeField(null=True, blank=True)
    last_metrics_sync = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self) -> str:
        return f"{self.release} -> {self.dt_server.name}/{self.dt_project_name}"
