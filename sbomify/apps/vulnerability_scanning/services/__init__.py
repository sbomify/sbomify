"""Service layer for vulnerability scanning integration.

Provides DT server selection, health checks, and team vulnerability settings.
Scanning is handled by the plugin framework (OSV and DT plugins).
"""

import logging
import os
from typing import Any
from urllib.parse import urlparse

from django.conf import settings
from django.db import models
from django.utils import timezone

from ..clients import DependencyTrackClient
from ..models import DependencyTrackServer, TeamVulnerabilitySettings

logger = logging.getLogger(__name__)


class VulnerabilityScanningService:
    """Service for managing vulnerability scanning configuration and DT infrastructure.

    After the plugin migration (OSV + DT plugins), this service retains only:
    - DT server selection and health checks
    - Team vulnerability settings management
    - Environment prefix logic (used by DT plugin for project naming)
    """

    def _get_environment_prefix(self) -> str:
        """Generate an environment prefix based on APP_BASE_URL for DT project naming.

        This helps differentiate projects between environments (dev, staging, prod)
        when using a shared Dependency Track instance.

        You can override the automatic detection by setting the DT_ENVIRONMENT_PREFIX
        environment variable.

        Returns:
            Environment prefix string
        """
        try:
            override_prefix = os.environ.get("DT_ENVIRONMENT_PREFIX", "").strip()
            if override_prefix:
                logger.info(f"Using explicit DT environment prefix: {override_prefix}")
                return override_prefix

            app_base_url = getattr(settings, "APP_BASE_URL", "")

            if not app_base_url:
                return "unknown"

            parsed = urlparse(app_base_url)
            hostname = parsed.hostname

            if not hostname:
                netloc_parts = parsed.netloc.split(":")
                if netloc_parts and netloc_parts[0]:
                    hostname = netloc_parts[0]
                else:
                    return "unknown"

            if hostname in ["localhost", "127.0.0.1", "0.0.0.0"]:  # nosec B104
                return "local"

            hostname_lower = hostname.lower()
            if "staging" in hostname_lower:
                return "staging"
            elif "dev" in hostname_lower or "development" in hostname_lower:
                return "dev"
            elif "test" in hostname_lower:
                return "test"
            elif "prod" in hostname_lower:
                return "prod"
            else:
                if hostname_lower.endswith(".com") or hostname_lower.endswith(".org"):
                    parts = hostname_lower.split(".")
                    if len(parts) >= 3:
                        first_part = parts[0]
                        if first_part not in ["app", "www", "api"]:
                            return first_part
                    return "prod"
                else:
                    parts = hostname_lower.split(".")
                    return parts[0] if parts and parts[0] else "unknown"

        except Exception as e:
            logger.warning(f"Failed to determine environment prefix from APP_BASE_URL: {e}")
            return "unknown"

    def get_or_create_team_settings(self, team) -> TeamVulnerabilitySettings:
        """Get or create team vulnerability settings."""
        team_settings, created = TeamVulnerabilitySettings.objects.get_or_create(
            team=team, defaults={"vulnerability_provider": "osv"}
        )

        if created:
            logger.info(f"Created default vulnerability settings for team {team.key}")

        return team_settings

    def get_team_vulnerability_provider(self, team) -> str:
        """Get the vulnerability scanning provider for a team.

        Args:
            team: Team instance

        Returns:
            Provider name ('osv' or 'dependency_track')
        """
        try:
            settings_obj = TeamVulnerabilitySettings.objects.get(team=team)
            return settings_obj.vulnerability_provider
        except TeamVulnerabilitySettings.DoesNotExist:
            return "osv"

    def select_dependency_track_server(self, team) -> DependencyTrackServer:
        """Select a Dependency Track server for a team.

        - Enterprise teams: Can use custom server OR shared pool
        - Business teams: Can only use shared pool
        - Uses round-robin selection from available servers in the pool
        - Performs just-in-time health checks if no healthy servers are available

        Args:
            team: Team instance

        Returns:
            DependencyTrackServer instance

        Raises:
            RuntimeError: If no suitable server is available
        """
        # Check for custom DT server (Enterprise only)
        if team.billing_plan == "enterprise":
            try:
                team_settings = TeamVulnerabilitySettings.objects.get(team=team)
                if team_settings.custom_dt_server and team_settings.custom_dt_server.is_available_for_scan:
                    return team_settings.custom_dt_server
            except TeamVulnerabilitySettings.DoesNotExist:
                pass

        # Use server pool with round-robin selection
        available_servers = (
            DependencyTrackServer.objects.filter(is_active=True, health_status__in=["healthy", "degraded"])
            .exclude(current_scan_count__gte=models.F("max_concurrent_scans"))
            .order_by("priority", "current_scan_count")
        )

        if available_servers.exists():
            selected_server = available_servers.first()

            DependencyTrackServer.objects.filter(id=selected_server.id).update(
                current_scan_count=models.F("current_scan_count") + 1
            )

            return selected_server

        # No healthy servers found - try just-in-time health checks
        logger.warning("No healthy DT servers found, attempting just-in-time health checks")

        candidate_servers = (
            DependencyTrackServer.objects.filter(is_active=True)
            .exclude(current_scan_count__gte=models.F("max_concurrent_scans"))
            .order_by("priority", "current_scan_count")
        )

        for server in candidate_servers:
            try:
                logger.info(f"Performing just-in-time health check for DT server: {server.name}")
                health_result = self.check_dependency_track_server_health(server)

                if health_result["status"] in ["healthy", "degraded"]:
                    DependencyTrackServer.objects.filter(id=server.id).update(
                        current_scan_count=models.F("current_scan_count") + 1
                    )
                    logger.info(f"Successfully validated DT server {server.name} via just-in-time health check")
                    return server
                else:
                    error_msg = health_result.get("error", "Unknown error")
                    logger.warning(f"DT server {server.name} failed just-in-time health check: {error_msg}")

            except Exception as e:
                logger.warning(f"Just-in-time health check failed for DT server {server.name}: {e}")
                continue

        raise RuntimeError("No available Dependency Track servers")

    def check_dependency_track_server_health(self, server: DependencyTrackServer) -> dict[str, Any]:
        """Check the health of a Dependency Track server and update its status.

        Args:
            server: DependencyTrackServer instance to check

        Returns:
            Health check results
        """
        logger.info(f"Starting health check for DT server: {server.name}")

        try:
            client = DependencyTrackClient(server.url, server.api_key)
            health_result = client.health_check()

            if health_result.get("status") == "degraded":
                server_status = "degraded"
            else:
                server_status = "healthy"

            server.health_status = server_status
            server.last_health_check = timezone.now()
            server.save(update_fields=["health_status", "last_health_check"])

            logger.info(f"Health check successful for DT server: {server.name} (status: {server_status})")

            return {
                "server_id": str(server.id),
                "status": server_status,
                "application": health_result.get("details", {}).get("application", "Unknown"),
                "version": health_result.get("details", {}).get("version", "Unknown"),
                "timestamp": health_result.get("details", {}).get("timestamp"),
                "message": "Health check successful",
            }

        except Exception as e:
            server.health_status = "unhealthy"
            server.last_health_check = timezone.now()
            server.save(update_fields=["health_status", "last_health_check"])

            logger.error(f"Health check failed for DT server: {server.name}: {e}")

            return {
                "server_id": str(server.id),
                "status": "unhealthy",
                "error": str(e),
                "message": "Health check failed",
            }

    def check_all_dependency_track_servers_health(self) -> list[dict[str, Any]]:
        """Check the health of all active Dependency Track servers.

        Returns:
            List of health check results for all servers
        """
        servers = DependencyTrackServer.objects.filter(is_active=True)
        results = []

        for server in servers:
            result = self.check_dependency_track_server_health(server)
            results.append(result)

        logger.info(f"Completed health checks for {len(results)} DT servers")
        return results
