"""Tests for vulnerability scanning clients using real Dependency Track API schemas."""

import pytest
import uuid
from unittest.mock import patch

from ..clients import DependencyTrackClient, DependencyTrackAPIError


@pytest.mark.django_db
class TestDependencyTrackClient:
    """Test DependencyTrackClient with real API schemas."""

    def test_init_client(self):
        """Test client initialization."""
        client = DependencyTrackClient("https://dt.example.com", "test-api-key")
        assert client.base_url == "https://dt.example.com"
        assert client.api_key == "test-api-key"
        assert client.timeout == 30

    def test_init_client_custom_timeout(self):
        """Test client initialization with custom timeout."""
        client = DependencyTrackClient("https://dt.example.com", "test-api-key", timeout=60)
        assert client.timeout == 60

    @patch('sbomify.apps.vulnerability_scanning.clients.DependencyTrackClient._make_request')
    def test_health_check_success(self, mock_make_request):
        """Test successful health check using readiness endpoint."""
        # Mock response based on /health/ready endpoint from DT API
        mock_make_request.return_value = {
            "status": "UP",
            "checks": [
                {"name": "database", "status": "UP"},
                {"name": "messaging", "status": "UP"}
            ]
        }

        client = DependencyTrackClient("https://dt.example.com", "test-api-key")
        result = client.health_check()

        assert result["status"] == "healthy"
        assert "details" in result
        assert result["details"]["status"] == "UP"
        mock_make_request.assert_called_once_with('GET', '/health/ready')

    @patch('sbomify.apps.vulnerability_scanning.clients.DependencyTrackClient._make_request')
    def test_health_check_failure(self, mock_make_request):
        """Test health check failure with graceful degradation."""
        # Both health endpoints fail
        mock_make_request.side_effect = DependencyTrackAPIError("Connection failed")

        client = DependencyTrackClient("https://dt.example.com", "test-api-key")
        result = client.health_check()

        # Should return unhealthy status instead of raising exception
        assert result["status"] == "unhealthy"
        assert "error" in result
        assert "Service unavailable" in str(result["error"])

        # Should try both endpoints
        assert mock_make_request.call_count == 2
        mock_make_request.assert_any_call('GET', '/health/ready')
        mock_make_request.assert_any_call('GET', '/health')

    @patch('sbomify.apps.vulnerability_scanning.clients.DependencyTrackClient._make_request')
    def test_create_project_success(self, mock_make_request):
        """Test successful project creation using real Project schema."""
        project_uuid = uuid.uuid4()

        # Mock response based on Project schema from DT API
        mock_make_request.return_value = {
            "uuid": str(project_uuid),
            "name": "Test Component",
            "version": "1.0.0",
            "description": "Test project for component scanning",
            "classifier": "APPLICATION",
            "active": True,
            "tags": [],
            "properties": [],
            "lastBomImport": None,
            "lastBomImportFormat": None,
            "lastInheritedRiskScore": 0.0,
            "metrics": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0,
                "unassigned": 0,
                "vulnerabilities": 0,
                "vulnerableComponents": 0,
                "components": 0,
                "suppressed": 0,
                "findingsTotal": 0,
                "findingsAudited": 0,
                "findingsUnaudited": 0,
                "inheritedRiskScore": 0.0,
                "policyViolationsFail": 0,
                "policyViolationsWarn": 0,
                "policyViolationsInfo": 0,
                "policyViolationsTotal": 0,
                "policyViolationsAudited": 0,
                "policyViolationsUnaudited": 0,
                "policyViolationsSecurityTotal": 0,
                "policyViolationsSecurityAudited": 0,
                "policyViolationsSecurityUnaudited": 0,
                "policyViolationsLicenseTotal": 0,
                "policyViolationsLicenseAudited": 0,
                "policyViolationsLicenseUnaudited": 0,
                "policyViolationsOperationalTotal": 0,
                "policyViolationsOperationalAudited": 0,
                "policyViolationsOperationalUnaudited": 0
            }
        }

        client = DependencyTrackClient("https://dt.example.com", "test-api-key")
        result = client.create_project("Test Component", "1.0.0", "Test project for component scanning")

        assert result["uuid"] == str(project_uuid)
        assert result["name"] == "Test Component"
        assert result["version"] == "1.0.0"

        expected_payload = {
            "name": "Test Component",
            "version": "1.0.0",
            "classifier": "APPLICATION",
            "description": "Test project for component scanning"
        }
        mock_make_request.assert_called_once_with(
            'PUT', '/v1/project', data=expected_payload
        )

    @patch('sbomify.apps.vulnerability_scanning.clients.DependencyTrackClient._make_request')
    def test_create_project_api_error(self, mock_make_request):
        """Test project creation API error handling."""
        mock_make_request.side_effect = DependencyTrackAPIError(
            "Invalid project name",
            status_code=400,
            response_data={"detail": "Invalid project name"}
        )

        client = DependencyTrackClient("https://dt.example.com", "test-api-key")

        with pytest.raises(DependencyTrackAPIError) as exc_info:
            client.create_project("", "1.0.0")  # Invalid empty name

        assert exc_info.value.status_code == 400
        assert "Invalid project name" in str(exc_info.value)

    @patch('sbomify.apps.vulnerability_scanning.clients.DependencyTrackClient._make_request')
    def test_upload_sbom_success(self, mock_make_request):
        """Test successful SBOM upload using real BomSubmitRequest schema."""
        # Mock response based on BomProcessingResponse schema from DT API
        mock_make_request.return_value = {
            "token": str(uuid.uuid4()),
            "processing": True
        }

        client = DependencyTrackClient("https://dt.example.com", "test-api-key")
        sbom_data = b'{"bomFormat": "CycloneDX", "specVersion": "1.5"}'
        project_uuid = uuid.uuid4()

        result = client.upload_sbom(str(project_uuid), sbom_data)

        assert "token" in result
        assert result["processing"] is True

        expected_data = {
            "project": str(project_uuid),
            "autoCreate": "true"
        }
        mock_make_request.assert_called_once()
        # Check that the call was made with POST method and correct endpoint
        call_args = mock_make_request.call_args
        assert call_args[0][0] == 'POST'  # method
        assert call_args[0][1] == '/v1/bom'  # endpoint

    @patch('sbomify.apps.vulnerability_scanning.clients.DependencyTrackClient._make_request')
    def test_upload_sbom_validation_error(self, mock_make_request):
        """Test SBOM upload with validation error (400) produces formatted error message."""
        # Mock validation error response from DT (based on actual DT API format)
        error_response = {
            "title": "The uploaded BOM is invalid",
            "detail": "Schema validation failed"
        }

        mock_make_request.side_effect = DependencyTrackAPIError(
            "Dependency Track error (400): The uploaded BOM is invalid: Schema validation failed",
            status_code=400,
            response_data=error_response
        )

        client = DependencyTrackClient("https://dt.example.com", "test-api-key")
        sbom_data = b'{"bomFormat": "CycloneDX", "specVersion": "1.5"}'
        project_uuid = uuid.uuid4()

        with pytest.raises(DependencyTrackAPIError) as exc_info:
            client.upload_sbom(str(project_uuid), sbom_data)

        error_msg = str(exc_info.value)
        assert "Dependency Track error (400)" in error_msg
        assert "The uploaded BOM is invalid" in error_msg
        assert "Schema validation failed" in error_msg
        assert exc_info.value.status_code == 400
        assert exc_info.value.response_data == error_response

    @patch('sbomify.apps.vulnerability_scanning.clients.DependencyTrackClient._make_request')
    def test_get_project_metrics_success(self, mock_make_request):
        """Test successful project metrics retrieval using real ProjectMetrics schema."""
        project_uuid = uuid.uuid4()

        # Mock response based on ProjectMetrics schema from DT API
        mock_make_request.return_value = {
            "critical": 2,
            "high": 5,
            "medium": 8,
            "low": 12,
            "unassigned": 0,
            "vulnerabilities": 27,
            "vulnerableComponents": 15,
            "components": 150,
            "suppressed": 3,
            "findingsTotal": 27,
            "findingsAudited": 5,
            "findingsUnaudited": 22,
            "inheritedRiskScore": 7.2,
            "policyViolationsFail": 1,
            "policyViolationsWarn": 2,
            "policyViolationsInfo": 0,
            "policyViolationsTotal": 3,
            "policyViolationsAudited": 1,
            "policyViolationsUnaudited": 2,
            "policyViolationsSecurityTotal": 2,
            "policyViolationsSecurityAudited": 1,
            "policyViolationsSecurityUnaudited": 1,
            "policyViolationsLicenseTotal": 1,
            "policyViolationsLicenseAudited": 0,
            "policyViolationsLicenseUnaudited": 1,
            "policyViolationsOperationalTotal": 0,
            "policyViolationsOperationalAudited": 0,
            "policyViolationsOperationalUnaudited": 0
        }

        client = DependencyTrackClient("https://dt.example.com", "test-api-key")
        result = client.get_project_metrics(str(project_uuid))

        assert result["vulnerabilities"] == 27
        assert result["critical"] == 2
        assert result["high"] == 5
        assert result["inheritedRiskScore"] == 7.2

        mock_make_request.assert_called_once_with(
            'GET', f'/v1/metrics/project/{project_uuid}/current'
        )

    @patch('sbomify.apps.vulnerability_scanning.clients.DependencyTrackClient._make_paginated_request')
    def test_get_project_vulnerabilities_success(self, mock_make_paginated_request):
        """Test successful project vulnerabilities retrieval using real Finding schema."""
        project_uuid = uuid.uuid4()

        # Mock response based on Finding schema from DT API with pagination metadata
        mock_make_paginated_request.return_value = {
            "content": [
            {
                "component": {
                    "uuid": str(uuid.uuid4()),
                    "group": "org.apache.logging.log4j",
                    "name": "log4j-core",
                    "version": "2.14.1",
                    "classifier": "LIBRARY",
                    "filename": "log4j-core-2.14.1.jar",
                    "extension": "jar",
                    "md5": "abc123",
                    "sha1": "def456",
                    "sha256": "ghi789",
                    "sha512": "jkl012",
                    "purl": "pkg:maven/org.apache.logging.log4j/log4j-core@2.14.1",
                    "cpe": "cpe:2.3:a:apache:log4j:2.14.1:*:*:*:*:*:*:*"
                },
                "vulnerability": {
                    "uuid": str(uuid.uuid4()),
                    "vulnId": "CVE-2021-44228",
                    "source": "NVD",
                    "title": "Apache Log4j2 JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints",
                    "subtitle": "",
                    "description": "Apache Log4j2 2.0-beta9 through 2.15.0 (excluding security releases 2.12.2, 2.12.3, and 2.3.1) JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints. An attacker who can control log messages or log message parameters can execute arbitrary code loaded from LDAP servers when message lookup substitution is enabled. From log4j 2.15.0, this behavior has been disabled by default.",
                    "recommendation": "Upgrade to Apache Log4j 2.16.0 or later",
                    "references": "https://nvd.nist.gov/vuln/detail/CVE-2021-44228",
                    "created": "2021-12-10T10:15:09.000+0000",
                    "published": "2021-12-10T10:15:09.000+0000",
                    "updated": "2021-12-14T12:30:15.000+0000",
                    "severity": "CRITICAL",
                    "cvssV2BaseScore": 10.0,
                    "cvssV2ImpactSubScore": 10.0,
                    "cvssV2ExploitabilitySubScore": 10.0,
                    "cvssV2Vector": "AV:N/AC:L/Au:N/C:C/I:C/A:C",
                    "cvssV3BaseScore": 10.0,
                    "cvssV3ImpactSubScore": 6.0,
                    "cvssV3ExploitabilitySubScore": 3.9,
                    "cvssV3Vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
                    "owaspRRLikelihoodScore": 5.0,
                    "owaspRRTechnicalImpactScore": 9.0,
                    "owaspRRBusinessImpactScore": 3.0
                },
                "analysis": {
                    "state": "NOT_AFFECTED",
                    "isSuppressed": False,
                    "response": "WILL_NOT_FIX",
                    "detail": "This vulnerability does not affect our usage of log4j"
                },
                "matrix": str(uuid.uuid4())
            }
            ],
            "totalElements": 1,
            "paginated": True
        }

        client = DependencyTrackClient("https://dt.example.com", "test-api-key")
        result = client.get_project_vulnerabilities(str(project_uuid))

        assert result["totalElements"] == 1
        assert len(result["content"]) == 1
        assert result["content"][0]["vulnerability"]["vulnId"] == "CVE-2021-44228"
        assert result["content"][0]["vulnerability"]["severity"] == "CRITICAL"
        assert result["content"][0]["component"]["name"] == "log4j-core"

        mock_make_paginated_request.assert_called_once_with(
            f'/v1/finding/project/{project_uuid}', {'suppressed': 'false'}, None, None
        )


