import json
from collections import defaultdict
from datetime import timedelta

from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import HttpRequest, HttpResponse, HttpResponseForbidden, HttpResponseNotFound
from django.shortcuts import render
from django.utils import timezone
from django.views import View

from sbomify.apps.core.models import Component, Product
from sbomify.apps.core.utils import token_to_number
from sbomify.apps.teams.models import Member, Team

from ..models import VulnerabilityScanResult


class VulnerabilityTrendsView(LoginRequiredMixin, View):
    """Main view for rendering the Vulnerability Trends component."""

    template_name = "vulnerability_scanning/components/vulnerability_trends.html.j2"

    def get(self, request: HttpRequest) -> HttpResponse:
        team_data = request.session.get("current_team", {})
        team_key = team_data.get("key")

        if not team_key:
            return HttpResponse("No workspace selected", status=400)

        try:
            team_id = token_to_number(team_key)
            team = Team.objects.get(pk=team_id)
        except (ValueError, Team.DoesNotExist):
            return HttpResponseNotFound("Workspace not found")

        if not Member.objects.filter(user=request.user, team=team).exists():
            return HttpResponseForbidden("Access denied")

        component_id = request.GET.get("component_id")
        show_product_filter = request.GET.get("show_product_filter", "false") == "true"
        hide_recent_scans = request.GET.get("hide_recent_scans", "false") == "true"
        selected_days = self._get_selected_days(request)
        selected_product_id = request.GET.get("product_id", "")

        # Validate component_id belongs to team
        if component_id:
            if not Component.objects.filter(id=component_id, team=team).exists():
                return HttpResponseForbidden("Component not found or access denied")

        # Validate product_id belongs to team
        if selected_product_id:
            if not Product.objects.filter(id=selected_product_id, team=team).exists():
                return HttpResponseForbidden("Product not found or access denied")

        products = []
        if show_product_filter:
            products = list(Product.objects.filter(team=team).values("id", "name").order_by("name"))

        trends_data = self._get_trends_data(team, selected_days, component_id, selected_product_id)

        context = {
            "team_key": team_key,
            "component_id": component_id,
            "show_product_filter": show_product_filter,
            "hide_recent_scans": hide_recent_scans,
            "selected_days": selected_days,
            "selected_product_id": selected_product_id,
            "products": products,
            "days_options": [7, 30, 90, 180, 365],
            **trends_data,
        }

        return render(request, self.template_name, context)

    def _get_selected_days(self, request: HttpRequest) -> int:
        days_param = request.GET.get("days", "30")
        try:
            days_value = int(days_param)
            return max(min(days_value, 365), 7)
        except (TypeError, ValueError):
            return 30

    def _get_trends_data(
        self,
        team: Team,
        days: int,
        component_id: str | None = None,
        product_id: str | None = None,
    ) -> dict:
        end_date = timezone.now()
        start_date = end_date - timedelta(days=days)

        # Build base query with proper select_related to avoid N+1 queries
        base_query = VulnerabilityScanResult.objects.filter(
            sbom__component__team=team,
            created_at__gte=start_date,
            created_at__lte=end_date,
        ).select_related("sbom", "sbom__component")

        if component_id:
            base_query = base_query.filter(sbom__component_id=component_id)

        if product_id:
            # Use distinct() to handle cases where component is in multiple projects/products
            base_query = base_query.filter(sbom__component__projects__products__id=product_id).distinct()

        # Use iterator() for large datasets to avoid loading everything into memory
        # Process results in chunks for time series aggregation
        daily_data = defaultdict(
            lambda: {
                "total": 0,
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0,
            }
        )

        provider_data = defaultdict(lambda: {"scans": 0, "vulnerabilities": 0})

        # Iterate through results without loading all into memory
        for result in base_query.iterator(chunk_size=1000):
            day_key = result.created_at.date().isoformat()
            daily_data[day_key]["total"] += result.total_vulnerabilities
            daily_data[day_key]["critical"] += result.critical_vulnerabilities
            daily_data[day_key]["high"] += result.high_vulnerabilities
            daily_data[day_key]["medium"] += result.medium_vulnerabilities
            daily_data[day_key]["low"] += result.low_vulnerabilities

            provider_data[result.provider]["scans"] += 1
            provider_data[result.provider]["vulnerabilities"] += result.total_vulnerabilities

        # Build time series with all days (including zeros)
        time_series = []
        current_date = start_date.date()
        while current_date <= end_date.date():
            day_key = current_date.isoformat()
            day_data = daily_data.get(
                day_key,
                {"total": 0, "critical": 0, "high": 0, "medium": 0, "low": 0},
            )
            time_series.append(
                {
                    "date": day_key,
                    "label": current_date.strftime("%b %d"),
                    **day_data,
                }
            )
            current_date += timedelta(days=1)

        # Calculate summary from aggregated daily data (more efficient than summing time_series)
        summary = {
            "total": sum(d["total"] for d in daily_data.values()),
            "critical": sum(d["critical"] for d in daily_data.values()),
            "high": sum(d["high"] for d in daily_data.values()),
            "medium": sum(d["medium"] for d in daily_data.values()),
            "low": sum(d["low"] for d in daily_data.values()),
        }

        chart_labels = [d["label"] for d in time_series]
        chart_data = {
            "labels": json.dumps(chart_labels),
            "critical": json.dumps([d["critical"] for d in time_series]),
            "high": json.dumps([d["high"] for d in time_series]),
            "medium": json.dumps([d["medium"] for d in time_series]),
            "low": json.dumps([d["low"] for d in time_series]),
            "severity_labels": json.dumps(["Critical", "High", "Medium", "Low"]),
            "severity_values": json.dumps(
                [
                    summary["critical"],
                    summary["high"],
                    summary["medium"],
                    summary["low"],
                ]
            ),
            "provider_labels": json.dumps(list(provider_data.keys())),
            "provider_values": json.dumps([p["vulnerabilities"] for p in provider_data.values()]),
        }

        # Build separate query for recent scans (don't reuse the evaluated query)
        recent_scans_query = VulnerabilityScanResult.objects.filter(
            sbom__component__team=team,
            created_at__gte=start_date,
            created_at__lte=end_date,
        ).select_related("sbom", "sbom__component")

        if component_id:
            recent_scans_query = recent_scans_query.filter(sbom__component_id=component_id)

        if product_id:
            recent_scans_query = recent_scans_query.filter(
                sbom__component__projects__products__id=product_id
            ).distinct()

        recent_scans = list(
            recent_scans_query.order_by("-created_at")[:5].values(
                "id",
                "sbom__id",
                "sbom__name",
                "sbom__version",
                "sbom__component__id",
                "sbom__component__name",
                "provider",
                "total_vulnerabilities",
                "critical_vulnerabilities",
                "high_vulnerabilities",
                "medium_vulnerabilities",
                "low_vulnerabilities",
                "created_at",
            )
        )

        formatted_scans = []
        for scan in recent_scans:
            version = scan["sbom__version"] or ""
            version_display = version[:17] + "..." if len(version) > 20 else version
            formatted_scans.append(
                {
                    "id": str(scan["id"]),
                    "sbom_id": str(scan["sbom__id"]),
                    "component_id": str(scan["sbom__component__id"]),
                    "sbom_name": scan["sbom__name"],
                    "sbom_version": version_display,
                    "sbom_version_full": version,
                    "component_name": scan["sbom__component__name"],
                    "provider": scan["provider"],
                    "total": scan["total_vulnerabilities"],
                    "critical": scan["critical_vulnerabilities"],
                    "high": scan["high_vulnerabilities"],
                    "medium": scan["medium_vulnerabilities"],
                    "low": scan["low_vulnerabilities"],
                    "scan_date": scan["created_at"].strftime("%b %d, %Y %H:%M"),
                }
            )

        return {
            "summary": summary,
            "time_series": time_series,
            "chart_labels": chart_labels,
            "chart_data": chart_data,
            "has_data": summary["total"] > 0,
            "recent_scans": formatted_scans,
        }
