from datetime import timedelta

from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.http import HttpRequest, HttpResponse, HttpResponseForbidden, HttpResponseNotFound
from django.shortcuts import render
from django.utils import timezone
from django.views import View

from sbomify.apps.core.errors import error_response
from sbomify.apps.core.utils import token_to_number
from sbomify.apps.plugins.models import AssessmentRun
from sbomify.apps.teams.models import Member, Team
from sbomify.apps.teams.permissions import GuestAccessBlockedMixin

from .utils import extract_severity_counts


class VulnerabilityScansView(GuestAccessBlockedMixin, LoginRequiredMixin, View):
    template_name = "vulnerability_scanning/vulnerability_scans.html.j2"
    page_size = 25

    def get(self, request: HttpRequest, team_key: str) -> HttpResponse:
        try:
            team_id = token_to_number(team_key)
            team = Team.objects.get(pk=team_id)
        except (ValueError, Team.DoesNotExist):
            return error_response(request, HttpResponseNotFound("Workspace not found"))

        if not Member.objects.filter(user=request.user, team=team).exists():
            return error_response(request, HttpResponseForbidden("Access denied"))

        selected_days = self._get_selected_days(request)

        scans_qs = AssessmentRun.objects.filter(
            sbom__component__team=team,
            category="security",
            status="completed",
        )
        if selected_days:
            start_date = timezone.now() - timedelta(days=selected_days)
            scans_qs = scans_qs.filter(created_at__gte=start_date)

        scans_qs = scans_qs.select_related("sbom__component").order_by("-created_at")

        # Compute summary by streaming results to avoid loading all into memory
        summary = {
            "total_scans": 0,
            "total_vulnerabilities": 0,
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
        }
        for result_json in scans_qs.values_list("result", flat=True).iterator():
            counts = extract_severity_counts(result_json)
            summary["total_scans"] += 1
            summary["total_vulnerabilities"] += counts["total"]
            summary["critical"] += counts["critical"]
            summary["high"] += counts["high"]
            summary["medium"] += counts["medium"]
            summary["low"] += counts["low"]

        summary["critical_high"] = summary["critical"] + summary["high"]
        summary["medium_low"] = summary["medium"] + summary["low"]

        paginator = Paginator(scans_qs, self.page_size)
        page_number = request.GET.get("page")
        page_obj = paginator.get_page(page_number)

        days_value = "all" if selected_days is None else selected_days
        time_range_label = "All time" if selected_days is None else f"Last {selected_days} days"

        context = {
            "team": team,
            "page_obj": page_obj,
            "selected_days": selected_days,
            "days_options": [7, 30, 90, 180, 365],
            "summary": summary,
            "time_range_label": time_range_label,
            "days_value": days_value,
        }

        return render(request, self.template_name, context)

    @staticmethod
    def _get_selected_days(request: HttpRequest) -> int | None:
        """Extract and validate the days filter from query params."""
        days_param = request.GET.get("days")

        if days_param is None or days_param == "":
            return 30

        if days_param == "all":
            return None

        try:
            days_value = int(days_param)
            return max(min(days_value, 365), 1)
        except (TypeError, ValueError):
            return 30
