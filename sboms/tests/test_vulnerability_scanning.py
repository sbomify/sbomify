"""
Tests for vulnerability scanning functionality with timeout handling.
"""

import json
import subprocess
from unittest.mock import Mock, patch

from django.conf import settings
from django.test import TestCase, override_settings

from core.models import User
from sbomify.tasks import scan_sbom_for_vulnerabilities_unified
from sboms.models import SBOM, Component
from teams.models import Team


class VulnerabilityScanningTimeoutTests(TestCase):
    """Test timeout handling in vulnerability scanning tasks."""

    def setUp(self):
        """Set up test data."""
        self.user = User.objects.create_user(
            username="testuser", email="test@example.com", first_name="Test", last_name="User"
        )
        self.team = Team.objects.create(name="Test Team")
        self.component = Component.objects.create(name="test-component", team=self.team, is_public=False)
        self.sbom = SBOM.objects.create(
            name="test-sbom",
            component=self.component,
            format="cyclonedx",
            format_version="1.6",
            version="1.0.0",
            sbom_filename="test-sbom.cdx.json",
            source="test",
        )

    @patch("sbomify.tasks.S3Client")
    @patch("vulnerability_scanning.clients.subprocess.run")
    @patch("sbomify.tasks.dramatiq.get_broker")
    def test_subprocess_timeout_handling(self, mock_broker, mock_subprocess, mock_s3_client):
        """Test that subprocess timeouts are handled gracefully."""
        # Mock S3 client to return valid SBOM data
        mock_s3_instance = Mock()
        mock_s3_instance.get_sbom_data.return_value = b'{"bomFormat": "CycloneDX", "specVersion": "1.6"}'
        mock_s3_client.return_value = mock_s3_instance

        # Mock subprocess to raise TimeoutExpired
        mock_subprocess.side_effect = subprocess.TimeoutExpired(cmd=["osv-scanner", "scan", "source"], timeout=240)

        # Mock Redis client
        mock_redis = Mock()
        mock_broker.return_value.client = mock_redis

        # Call the task
        result = scan_sbom_for_vulnerabilities_unified(str(self.sbom.id))

        # Verify timeout was handled gracefully
        self.assertIsInstance(result, dict)
        self.assertIn("sbom_id", result)
        self.assertEqual(result["sbom_id"], str(self.sbom.id))
        self.assertIn("provider", result)
        self.assertEqual(result["provider"], "osv")

        # Verify empty results due to timeout (scan failed but returned standardized empty results)
        self.assertIn("vulnerability_count", result)
        self.assertEqual(result["vulnerability_count"]["total"], 0)

    @patch("sbomify.tasks.S3Client")
    @patch("vulnerability_scanning.clients.subprocess.run")
    @patch("sbomify.tasks.dramatiq.get_broker")
    def test_successful_scan_with_timeout_setting(self, mock_broker, mock_subprocess, mock_s3_client):
        """Test that successful scans use the timeout setting."""
        # Mock S3 client to return valid SBOM data
        mock_s3_instance = Mock()
        mock_s3_instance.get_sbom_data.return_value = b'{"bomFormat": "CycloneDX", "specVersion": "1.6"}'
        mock_s3_client.return_value = mock_s3_instance

        # Mock successful subprocess run
        mock_process = Mock()
        mock_process.returncode = 0
        mock_process.stdout = '{"results": []}'
        mock_process.stderr = ""
        mock_subprocess.return_value = mock_process

        # Mock Redis client
        mock_redis = Mock()
        mock_broker.return_value.client = mock_redis

        # Call the task
        result = scan_sbom_for_vulnerabilities_unified(str(self.sbom.id))

        # Verify successful result
        self.assertIsInstance(result, dict)
        self.assertIn("sbom_id", result)
        self.assertEqual(result["sbom_id"], str(self.sbom.id))
        self.assertIn("provider", result)
        self.assertEqual(result["provider"], "osv")
        self.assertIn("vulnerability_count", result)
        self.assertIn("scan_metadata", result)

        # Verify subprocess was called with timeout
        mock_subprocess.assert_called_once()
        call_args = mock_subprocess.call_args
        self.assertEqual(call_args.kwargs["timeout"], settings.OSV_SCANNER_TIMEOUT_SECONDS)

    @override_settings(OSV_SCANNER_TIMEOUT_SECONDS=60)
    @patch("sbomify.tasks.S3Client")
    @patch("vulnerability_scanning.clients.subprocess.run")
    @patch("sbomify.tasks.dramatiq.get_broker")
    def test_custom_timeout_setting(self, mock_broker, mock_subprocess, mock_s3_client):
        """Test that custom timeout settings are respected."""
        # Mock S3 client to return valid SBOM data
        mock_s3_instance = Mock()
        mock_s3_instance.get_sbom_data.return_value = b'{"bomFormat": "CycloneDX", "specVersion": "1.6"}'
        mock_s3_client.return_value = mock_s3_instance

        # Mock subprocess to raise TimeoutExpired with custom timeout
        mock_subprocess.side_effect = subprocess.TimeoutExpired(cmd=["osv-scanner", "scan", "source"], timeout=60)

        # Mock Redis client
        mock_redis = Mock()
        mock_broker.return_value.client = mock_redis

        # Call the task
        result = scan_sbom_for_vulnerabilities_unified(str(self.sbom.id))

        # Verify scan completed with error handling
        self.assertIn("sbom_id", result)
        self.assertEqual(result["sbom_id"], str(self.sbom.id))
        self.assertIn("provider", result)
        self.assertEqual(result["provider"], "osv")

        # Verify subprocess was called with timeout
        mock_subprocess.assert_called_once()
        call_args = mock_subprocess.call_args
        self.assertEqual(call_args.kwargs["timeout"], 60)

    def test_timeout_setting_default_value(self):
        """Test that the default timeout setting is reasonable."""
        # Default should be 300 seconds (5 minutes)
        self.assertEqual(settings.OSV_SCANNER_TIMEOUT_SECONDS, 300)

        # Should be less than Dramatiq's time limit (360 seconds)
        self.assertLess(settings.OSV_SCANNER_TIMEOUT_SECONDS, 360)
